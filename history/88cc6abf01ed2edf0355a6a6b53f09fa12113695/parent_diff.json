{"from": {"secList": ["sec-asyncgenerator-definitions-evaluation", "sec-runtime-semantics-classdefinitionevaluation", "sec-createperiterationenvironment", "sec-variablestatements-in-catch-blocks", "sec-initializeboundname", "sec-web-compat-globaldeclarationinstantiation", "sec-source-text-module-record-initialize-environment", "sec-function-definitions-runtime-semantics-evaluation", "sec-globaldeclarationinstantiation", "sec-with-statement-runtime-semantics-evaluation", "sec-newfunctionenvironment", "sec-web-compat-functiondeclarationinstantiation", "sec-async-function-definitions-runtime-semantics-evaluation", "sec-blockdeclarationinstantiation", "sec-ecmascript-function-objects-construct-argumentslist-newtarget", "sec-for-statement-runtime-semantics-labelledevaluation", "sec-ordinarycallbindthis", "sec-web-compat-evaldeclarationinstantiation", "sec-newmoduleenvironment", "sec-web-compat-blockdeclarationinstantiation", "sec-runtime-semantics-forinofheadevaluation", "sec-module-namespace-exotic-objects-get-p-receiver", "sec-evaldeclarationinstantiation", "sec-newglobalenvironment", "sec-functiondeclarationinstantiation", "sec-newdeclarativeenvironment", "sec-newobjectenvironment", "sec-generator-function-definitions-runtime-semantics-evaluation", "sec-globalthis", "sec-getthisenvironment", "sec-runtime-semantics-bindinginstantiation", "sec-module-environment-records-getbindingvalue-n-s", "sec-runtime-semantics-catchclauseevaluation", "sec-getidentifierreference"], "secData": {"sec-asyncgenerator-definitions-evaluation": {"num": "14.5.14", "title": "#sec-asyncgenerator-definitions-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-asyncgenerator-definitions-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgenerator-definitions-evaluation\">#sec-asyncgenerator-definitions-evaluation</span> Runtime Semantics: Evaluation</h1>\n\n      <emu-grammar><emu-production name=\"AsyncGeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"c51514e0\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>*</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncGeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"13d2cc33\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be !&#160;<emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>envRec</var> be <var>funcEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be !&#160;<emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-asyncgeneratorfunction-prototype\"><a href=\"#sec-asyncgeneratorfunction-prototype\">%AsyncGenerator%</a></emu-xref>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform !&#160;<emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Let <var>prototype</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%AsyncGenerator.prototype%).</li><li>Perform !&#160;<emu-xref aoid=\"DefinePropertyOrThrow\"><a href=\"#sec-definepropertyorthrow\">DefinePropertyOrThrow</a></emu-xref>(<var>closure</var>, <emu-val>\"prototype\"</emu-val>, PropertyDescriptor { [[Value]]: <var>prototype</var>, [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }).</li><li>Perform ! <var>envRec</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt>.</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in an <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt> to allow the generator code to call itself recursively. However, unlike in an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in an <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt>.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-runtime-semantics-classdefinitionevaluation": {"num": "14.6.14", "title": "#sec-runtime-semantics-classdefinitionevaluation Runtime Semantics: ClassDefinitionEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-classdefinitionevaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-classdefinitionevaluation\">#sec-runtime-semantics-classdefinitionevaluation</span> Runtime Semantics: ClassDefinitionEvaluation</h1>\n      <p>With parameters <var>classBinding</var> and <var>className</var>.</p>\n      <emu-grammar><emu-production name=\"ClassTail\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassTail\">ClassTail</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b8ea6aa5\"><emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>{</emu-t><emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>lex</var> be the LexicalEnvironment of the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>classScope</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>lex</var>).</li><li>Let <var>classScopeEnvRec</var> be <var>classScope</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScopeEnvRec</var>.CreateImmutableBinding(<var>classBinding</var>, <emu-val>true</emu-val>).</li></ol></li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, then<ol><li>Let <var>protoParent</var> be %Object.prototype%.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else,<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>Let <var>superclassRef</var> be the result of evaluating <emu-nt><a href=\"#prod-ClassHeritage\">ClassHeritage</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>lex</var>.</li><li>Let <var>superclass</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>superclassRef</var>).</li><li>If <var>superclass</var> is <emu-val>null</emu-val>, then<ol><li>Let <var>protoParent</var> be <emu-val>null</emu-val>.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else if <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>superclass</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Else,<ol><li>Let <var>protoParent</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>superclass</var>, <emu-val>\"prototype\"</emu-val>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>protoParent</var>) is neither Object nor Null, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorParent</var> be <var>superclass</var>.</li></ol></li></ol></li><li>Let <var>proto</var> be <emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<var>protoParent</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>constructor</var> be <emu-const>empty</emu-const>.</li><li>Else, let <var>constructor</var> be ConstructorMethod of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>If <var>constructor</var> is <emu-const>empty</emu-const>, then<ol><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, then<ol><li>Set <var>constructor</var> to the result of parsing the source text\n              <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">constructor</span>(...args) { <span class=\"hljs-keyword\">super</span>(...args); }</code></pre>\n              using the syntactic grammar with the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> <emu-nt params=\"~Yield, ~Await\"><a href=\"#prod-MethodDefinition\">MethodDefinition</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params></emu-mods></emu-nt>.</li></ol></li><li>Else,<ol><li>Set <var>constructor</var> to the result of parsing the source text\n              <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">constructor</span>() {}</code></pre>\n              using the syntactic grammar with the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> <emu-nt params=\"~Yield, ~Await\"><a href=\"#prod-MethodDefinition\">MethodDefinition</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params></emu-mods></emu-nt>.</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>Let <var>constructorInfo</var> be ! DefineMethod of <var>constructor</var> with arguments <var>proto</var> and <var>constructorParent</var>.</li><li>Let <var>F</var> be <var>constructorInfo</var>.[[Closure]].</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>F</var>, <var>className</var>).</li><li>Perform <emu-xref aoid=\"MakeConstructor\"><a href=\"#sec-makeconstructor\">MakeConstructor</a></emu-xref>(<var>F</var>, <emu-val>false</emu-val>, <var>proto</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, set <var>F</var>.[[ConstructorKind]] to <emu-const>derived</emu-const>.</li><li>Perform <emu-xref aoid=\"MakeClassConstructor\"><a href=\"#sec-makeclassconstructor\">MakeClassConstructor</a></emu-xref>(<var>F</var>).</li><li>Perform <emu-xref aoid=\"CreateMethodProperty\"><a href=\"#sec-createmethodproperty\">CreateMethodProperty</a></emu-xref>(<var>proto</var>, <emu-val>\"constructor\"</emu-val>, <var>F</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>methods</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Else, let <var>methods</var> be NonConstructorMethodDefinitions of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>For each <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <var>m</var> in order from <var>methods</var>, do<ol><li>If IsStatic of <var>m</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>status</var> be PropertyDefinitionEvaluation of <var>m</var> with arguments <var>proto</var> and <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>Let <var>status</var> be PropertyDefinitionEvaluation of <var>m</var> with arguments <var>F</var> and <emu-val>false</emu-val>.</li></ol></li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>lex</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>lex</var>.</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScopeEnvRec</var>.InitializeBinding(<var>classBinding</var>, <var>F</var>).</li></ol></li><li>Return <var>F</var>.\n      </li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-createperiterationenvironment": {"num": "13.7.4.9", "title": "#sec-createperiterationenvironment Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings )", "html": "<emu-clause id=\"sec-createperiterationenvironment\" aoid=\"CreatePerIterationEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-createperiterationenvironment\">#sec-createperiterationenvironment</span> Runtime Semantics: CreatePerIterationEnvironment ( <var>perIterationBindings</var> )</h1>\n        <p>The abstract operation CreatePerIterationEnvironment takes argument <var>perIterationBindings</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>perIterationBindings</var> has any elements, then<ol><li>Let <var>lastIterationEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>lastIterationEnvRec</var> be <var>lastIterationEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>outer</var> be <var>lastIterationEnv</var>.[[OuterEnv]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>outer</var> is not <emu-val>null</emu-val>.</li><li>Let <var>thisIterationEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>outer</var>).</li><li>Let <var>thisIterationEnvRec</var> be <var>thisIterationEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>For each element <var>bn</var> of <var>perIterationBindings</var>, do<ol><li>Perform ! <var>thisIterationEnvRec</var>.CreateMutableBinding(<var>bn</var>, <emu-val>false</emu-val>).</li><li>Let <var>lastValue</var> be ? <var>lastIterationEnvRec</var>.GetBindingValue(<var>bn</var>, <emu-val>true</emu-val>).</li><li>Perform <var>thisIterationEnvRec</var>.InitializeBinding(<var>bn</var>, <var>lastValue</var>).</li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>thisIterationEnv</var>.</li></ol></li><li>Return <emu-val>undefined</emu-val>.\n        </li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-variablestatements-in-catch-blocks": {"num": "B.3.5", "title": "#sec-variablestatements-in-catch-blocks VariableStatements in Catch Blocks", "html": "<emu-annex id=\"sec-variablestatements-in-catch-blocks\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-variablestatements-in-catch-blocks\">#sec-variablestatements-in-catch-blocks</span> VariableStatements in Catch Blocks</h1>\n      <p>The content of subclause  <emu-xref href=\"#sec-try-statement-static-semantics-early-errors\"><a href=\"#sec-try-statement-static-semantics-early-errors\" class=\"excluded-xref\" excluded-id=\"sec-try-statement-static-semantics-early-errors\">#sec-try-statement-static-semantics-early-errors</a></emu-xref> is replaced with the following:</p>\n      <emu-grammar><emu-production name=\"Catch\" collapsed=\"\" id=\"prod-annexB-Catch\">\n    <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"ddc13c36\"><emu-t>catch</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <ul>\n        <li>\n          It is a Syntax Error if BoundNames of <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> contains any duplicate elements.\n        \n        </li>\n        <li>\n          It is a Syntax Error if any element of the BoundNames of <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>.\n        \n        </li>\n        <li>\n          It is a Syntax Error if any element of the BoundNames of <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> also occurs in the VarDeclaredNames of <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt> unless <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> is  <emu-grammar><emu-production name=\"CatchParameter\" collapsed=\"\" id=\"prod-annexB-CatchParameter\" class=\" inline\">\n    <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"50e97238\"><emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>.\n        \n        </li>\n      </ul>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause may contain <code>var</code> declarations that bind a name that is also bound by the <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt>. At runtime, such bindings are instantiated in the VariableDeclarationEnvironment. They do not shadow the same-named bindings introduced by the <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> and hence the <emu-nt><a href=\"#prod-Initializer\">Initializer</a></emu-nt> for such <code>var</code> declarations will assign to the corresponding catch parameter rather than the <code>var</code> binding.</p>\n      </div></emu-note>\n      <p>This modified behaviour also applies to <code>var</code> and <code>function</code> declarations introduced by <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> calls contained within the <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause. This change is accomplished by modifying the algorithm of  <emu-xref href=\"#sec-evaldeclarationinstantiation\"><a href=\"#sec-evaldeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-evaldeclarationinstantiation\">#sec-evaldeclarationinstantiation</a></emu-xref> as follows:</p>\n      <p>Step 5.d.ii.2.a.i is replaced by:</p>\n      <emu-alg type=\"i\"><ol><li>If <var>thisEnvRec</var> is not the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause, throw a <emu-val>SyntaxError</emu-val> exception.\n      </li></ol></emu-alg>\n      <p>Step 9.d.ii.4.b.i.i is replaced by:</p>\n      <emu-alg type=\"i\"><ol><li>If <var>thisEnvRec</var> is not the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause, let <var>bindingExists</var> be <emu-val>true</emu-val>.\n      </li></ol></emu-alg>\n    </emu-annex>\n\n    "}, "sec-initializeboundname": {"num": "12.1.5.1", "title": "#sec-initializeboundname Runtime Semantics: InitializeBoundName ( name, value, environment )", "html": "<emu-clause id=\"sec-initializeboundname\" aoid=\"InitializeBoundName\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-initializeboundname\">#sec-initializeboundname</span> Runtime Semantics: InitializeBoundName ( <var>name</var>, <var>value</var>, <var>environment</var> )</h1>\n        <p>The abstract operation InitializeBoundName takes arguments <var>name</var>, <var>value</var>, and <var>environment</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>name</var>) is String.</li><li>If <var>environment</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>env</var> be the <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> component of <var>environment</var>.</li><li>Perform <var>env</var>.InitializeBinding(<var>name</var>, <var>value</var>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>lhs</var> be <emu-xref aoid=\"ResolveBinding\"><a href=\"#sec-resolvebinding\">ResolveBinding</a></emu-xref>(<var>name</var>).</li><li>Return ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhs</var>, <var>value</var>).\n        </li></ol></li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-web-compat-globaldeclarationinstantiation": {"num": "B.3.3.2", "title": "#sec-web-compat-globaldeclarationinstantiation Changes to GlobalDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-globaldeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-globaldeclarationinstantiation\">#sec-web-compat-globaldeclarationinstantiation</span> Changes to GlobalDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"GlobalDeclarationInstantiation\"><a href=\"#sec-globaldeclarationinstantiation\">GlobalDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 14:</p>\n        <emu-alg><ol><li>Let <var>strict</var> be IsStrict of <var>script</var>.</li><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>declaredFunctionOrVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredFunctionNames</var>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredVarNames</var>.</li><li>For each <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> that is directly contained in the <emu-nt><a href=\"#prod-StatementList\">StatementList</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>, <emu-nt><a href=\"#prod-CaseClause\">CaseClause</a></emu-nt>, or <emu-nt><a href=\"#prod-DefaultClause\">DefaultClause</a></emu-nt> Contained within <var>script</var>, do<ol><li>Let <var>F</var> be StringValue of the <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> of <var>f</var>.</li><li>If replacing the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> with a <emu-nt><a href=\"#prod-VariableStatement\">VariableStatement</a></emu-nt> that has <var>F</var> as a <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> would not produce any Early Errors for <var>script</var>, then<ol><li>If <var>envRec</var>.HasLexicalDeclaration(<var>F</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>fnDefinable</var> be ? <var>envRec</var>.CanDeclareGlobalVar(<var>F</var>).</li><li>If <var>fnDefinable</var> is <emu-val>true</emu-val>, then<ol><li>NOTE: A var binding for <var>F</var> is only instantiated here if it is neither a VarDeclaredName nor the name of another <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>.</li><li>If <var>declaredFunctionOrVarNames</var> does not contain <var>F</var>, then<ol><li>Perform ? <var>envRec</var>.CreateGlobalVarBinding(<var>F</var>, <emu-val>false</emu-val>).</li><li>Append <var>F</var> to <var>declaredFunctionOrVarNames</var>.</li></ol></li><li>When the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> is evaluated, perform the following steps in place of the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> Evaluation algorithm provided in <emu-xref href=\"#sec-function-definitions-runtime-semantics-evaluation\"><a href=\"#sec-function-definitions-runtime-semantics-evaluation\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</a></emu-xref>:<ol><li>Let <var>genv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s VariableEnvironment.</li><li>Let <var>genvRec</var> be <var>genv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>benv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>benvRec</var> be <var>benv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>fobj</var> be ! <var>benvRec</var>.GetBindingValue(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform ? <var>genvRec</var>.SetMutableBinding(<var>F</var>, <var>fobj</var>, <emu-val>false</emu-val>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n      </emu-annex>\n      "}, "sec-source-text-module-record-initialize-environment": {"num": "15.2.1.17.4", "title": "#sec-source-text-module-record-initialize-environment InitializeEnvironment ( ) Concrete Method", "html": "<emu-clause id=\"sec-source-text-module-record-initialize-environment\" aoid=\"InitializeEnvironment\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-source-text-module-record-initialize-environment\">#sec-source-text-module-record-initialize-environment</span> InitializeEnvironment ( ) Concrete Method</h1>\n          <p>The InitializeEnvironment concrete method of a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> abstract method.</p>\n          <p>This abstract method performs the following steps:</p>\n\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>.</li><li>For each <emu-xref href=\"#exportentry-record\"><a href=\"#exportentry-record\">ExportEntry Record</a></emu-xref> <var>e</var> in <var>module</var>.[[IndirectExportEntries]], do<ol><li>Let <var>resolution</var> be ? <var>module</var>.ResolveExport(<var>e</var>.[[ExportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resolution</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: All named exports from <var>module</var> are resolvable.</li><li>Let <var>realm</var> be <var>module</var>.[[Realm]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>realm</var> is not <emu-val>undefined</emu-val>.</li><li>Let <var>env</var> be <emu-xref aoid=\"NewModuleEnvironment\"><a href=\"#sec-newmoduleenvironment\">NewModuleEnvironment</a></emu-xref>(<var>realm</var>.[[GlobalEnv]]).</li><li>Set <var>module</var>.[[Environment]] to <var>env</var>.</li><li>Let <var>envRec</var> be <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>For each <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Record</a></emu-xref> <var>in</var> in <var>module</var>.[[ImportEntries]], do<ol><li>Let <var>importedModule</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>in</var>.[[ModuleRequest]]).</li><li>NOTE: The above call cannot fail because imported module requests are a subset of <var>module</var>.[[RequestedModules]], and these have been resolved earlier in this algorithm.</li><li>If <var>in</var>.[[ImportName]] is <emu-val>\"*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>importedModule</var>).</li><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>envRec</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Let <var>resolution</var> be ? <var>importedModule</var>.ResolveExport(<var>in</var>.[[ImportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>resolution</var>.[[BindingName]] is <emu-val>\"*namespace*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>resolution</var>.[[Module]]).</li><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>envRec</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Call <var>envRec</var>.CreateImportBinding(<var>in</var>.[[LocalName]], <var>resolution</var>.[[Module]], <var>resolution</var>.[[BindingName]]).</li></ol></li></ol></li></ol></li><li>Let <var>moduleContext</var> be a new ECMAScript code <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleContext</var> to <emu-val>null</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> of <var>moduleContext</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleContext</var> to <var>module</var>.</li><li>Set the VariableEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set <var>module</var>.[[Context]] to <var>moduleContext</var>.</li><li>Push <var>moduleContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>moduleContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>code</var> be <var>module</var>.[[ECMAScriptCode]].</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>code</var>.</li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each element <var>d</var> in <var>varDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If <var>dn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li><li>Call <var>envRec</var>.InitializeBinding(<var>dn</var>, <emu-val>undefined</emu-val>).</li><li>Append <var>dn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li><li>If <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, then<ol><li>Let <var>fo</var> be InstantiateFunctionObject of <var>d</var> with argument <var>env</var>.</li><li>Call <var>envRec</var>.InitializeBinding(<var>dn</var>, <var>fo</var>).</li></ol></li></ol></li></ol></li><li>Remove <var>moduleContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-function-definitions-runtime-semantics-evaluation": {"num": "14.1.25", "title": "#sec-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"FunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"81739a57\"><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>An alternative semantics is provided in  <emu-xref href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\"><a href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" class=\"excluded-xref\" excluded-id=\"sec-block-level-function-declarations-web-legacy-compatibility-semantics\">#sec-block-level-function-declarations-web-legacy-compatibility-semantics</a></emu-xref>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"FunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b26bacea\"><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"FunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b26bacea\"><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"FunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"81739a57\"><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>envRec</var> be <var>funcEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform <var>envRec</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be <emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Perform <emu-xref aoid=\"MakeConstructor\"><a href=\"#sec-makeconstructor\">MakeConstructor</a></emu-xref>(<var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>.</li><li>Perform <var>envRec</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt> to allow the function to call itself recursively. However, unlike in a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n        <p>A <emu-val>\"prototype\"</emu-val> property is automatically created for every function defined using a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> or <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>, to allow for the possibility that the function will be used as a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"FunctionStatementList\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionStatementList\">FunctionStatementList</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"37b9c04c\"><emu-gann>[empty]</emu-gann></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).\n      </li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-globaldeclarationinstantiation": {"num": "15.1.11", "title": "#sec-globaldeclarationinstantiation Runtime Semantics: GlobalDeclarationInstantiation ( script, env )", "html": "<emu-clause id=\"sec-globaldeclarationinstantiation\" aoid=\"GlobalDeclarationInstantiation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-globaldeclarationinstantiation\">#sec-globaldeclarationinstantiation</span> Runtime Semantics: GlobalDeclarationInstantiation ( <var>script</var>, <var>env</var> )</h1>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>When an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is established for evaluating scripts, declarations are instantiated in the current <emu-xref href=\"#global-environment\"><a href=\"#global-environment\">global environment</a></emu-xref>. Each global binding declared in the code is instantiated.</p>\n      </div></emu-note>\n      <p>The abstract operation GlobalDeclarationInstantiation takes arguments <var>script</var> (a <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> for <emu-nt><a href=\"#prod-ScriptBody\">ScriptBody</a></emu-nt>) and <var>env</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). <var>script</var> is the <emu-nt><a href=\"#prod-ScriptBody\">ScriptBody</a></emu-nt> for which the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is being established. <var>env</var> is the global lexical environment in which bindings are to be created. It performs the following steps when called:</p>\n      <!--\n        WARNING: If you add, remove, rename, or repurpose any variable names\n                 within this algorithm, you may need to update\n                 #sec-web-compat-globaldeclarationinstantiation accordingly.\n      -->\n      <emu-alg><ol><li>Let <var>envRec</var> be <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>envRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Let <var>lexNames</var> be the LexicallyDeclaredNames of <var>script</var>.</li><li>Let <var>varNames</var> be the VarDeclaredNames of <var>script</var>.</li><li>For each <var>name</var> in <var>lexNames</var>, do<ol><li>If <var>envRec</var>.HasVarDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>envRec</var>.HasLexicalDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>Let <var>hasRestrictedGlobal</var> be ? <var>envRec</var>.HasRestrictedGlobalProperty(<var>name</var>).</li><li>If <var>hasRestrictedGlobal</var> is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li></ol></li><li>For each <var>name</var> in <var>varNames</var>, do<ol><li>If <var>envRec</var>.HasLexicalDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li></ol></li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>script</var>.</li><li>Let <var>functionsToInitialize</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>declaredFunctionNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, in reverse list order, do<ol><li>If <var>d</var> is neither a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt> nor a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt> nor a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is either a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>.</li><li>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</li><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>If <var>fn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>Let <var>fnDefinable</var> be ? <var>envRec</var>.CanDeclareGlobalFunction(<var>fn</var>).</li><li>If <var>fnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Append <var>fn</var> to <var>declaredFunctionNames</var>.</li><li>Insert <var>d</var> as the first element of <var>functionsToInitialize</var>.</li></ol></li></ol></li></ol></li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, do<ol><li>If <var>d</var> is a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>, or a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li>For each String <var>vn</var> in the BoundNames of <var>d</var>, do<ol><li>If <var>vn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>Let <var>vnDefinable</var> be ? <var>envRec</var>.CanDeclareGlobalVar(<var>vn</var>).</li><li>If <var>vnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>vn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Append <var>vn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>NOTE: No abnormal terminations occur after this algorithm step if the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is an <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref>. However, if the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is a <emu-xref href=\"#proxy-exotic-object\"><a href=\"#proxy-exotic-object\">Proxy exotic object</a></emu-xref> it may exhibit behaviours that cause abnormal terminations in some of the following steps.</li><li>NOTE: Annex <emu-xref href=\"#sec-web-compat-globaldeclarationinstantiation\"><a href=\"#sec-web-compat-globaldeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-web-compat-globaldeclarationinstantiation\">#sec-web-compat-globaldeclarationinstantiation</a></emu-xref> adds additional steps at this point.</li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>script</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>NOTE: Lexically declared names are only instantiated here but not initialized.</li><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ? <var>envRec</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ? <var>envRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> <var>f</var> in <var>functionsToInitialize</var>, do<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>f</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>f</var> with argument <var>env</var>.</li><li>Perform ? <var>envRec</var>.CreateGlobalFunctionBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).</li></ol></li><li>For each String <var>vn</var> in <var>declaredVarNames</var>, in list order, do<ol><li>Perform ? <var>envRec</var>.CreateGlobalVarBinding(<var>vn</var>, <emu-val>false</emu-val>).</li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>Early errors specified in  <emu-xref href=\"#sec-scripts-static-semantics-early-errors\"><a href=\"#sec-scripts-static-semantics-early-errors\" class=\"excluded-xref\" excluded-id=\"sec-scripts-static-semantics-early-errors\">#sec-scripts-static-semantics-early-errors</a></emu-xref> prevent name conflicts between function/var declarations and let/const/class declarations as well as redeclaration of let/const/class bindings for declaration contained within a single <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt>. However, such conflicts and redeclarations that span more than one <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt> are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> and some global declarations not being instantiated. If this occurs, the code for the <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt> is not evaluated.</p>\n        <p>Unlike explicit var or function declarations, properties that are directly created on the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> result in global bindings that may be shadowed by let/const/class declarations.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-with-statement-runtime-semantics-evaluation": {"num": "13.11.7", "title": "#sec-with-statement-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-with-statement-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-with-statement-runtime-semantics-evaluation\">#sec-with-statement-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"WithStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-WithStatement\">WithStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"23bd2456\"><emu-t>with</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>val</var> be the result of evaluating <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>val</var>)).</li><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>newEnv</var> be <emu-xref aoid=\"NewObjectEnvironment\"><a href=\"#sec-newobjectenvironment\">NewObjectEnvironment</a></emu-xref>(<var>obj</var>, <var>oldEnv</var>).</li><li>Set the <var>withEnvironment</var> flag of <var>newEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> to <emu-val>true</emu-val>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>newEnv</var>.</li><li>Let <var>C</var> be the result of evaluating <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<emu-xref aoid=\"UpdateEmpty\"><a href=\"#sec-updateempty\">UpdateEmpty</a></emu-xref>(<var>C</var>, <emu-val>undefined</emu-val>)).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>No matter how control leaves the embedded <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, whether normally or by some form of <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> or exception, the LexicalEnvironment is always restored to its former state.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-newfunctionenvironment": {"num": "8.1.2.4", "title": "#sec-newfunctionenvironment NewFunctionEnvironment ( F, newTarget )", "html": "<emu-clause id=\"sec-newfunctionenvironment\" aoid=\"NewFunctionEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newfunctionenvironment\">#sec-newfunctionenvironment</span> NewFunctionEnvironment ( <var>F</var>, <var>newTarget</var> )</h1>\n        <p>The abstract operation NewFunctionEnvironment takes arguments <var>F</var> and <var>newTarget</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>F</var> is an ECMAScript function.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>newTarget</var>) is Undefined or Object.</li><li>Let <var>env</var> be a new <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>.</li><li>Let <var>envRec</var> be a new <emu-xref href=\"#sec-function-environment-records\"><a href=\"#sec-function-environment-records\">function Environment Record</a></emu-xref> containing no bindings.</li><li>Set <var>envRec</var>.[[FunctionObject]] to <var>F</var>.</li><li>If <var>F</var>.[[ThisMode]] is <emu-const>lexical</emu-const>, set <var>envRec</var>.[[ThisBindingStatus]] to <emu-const>lexical</emu-const>.</li><li>Else, set <var>envRec</var>.[[ThisBindingStatus]] to <emu-const>uninitialized</emu-const>.</li><li>Let <var>home</var> be <var>F</var>.[[HomeObject]].</li><li>Set <var>envRec</var>.[[HomeObject]] to <var>home</var>.</li><li>Set <var>envRec</var>.[[NewTarget]] to <var>newTarget</var>.</li><li>Set <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> to <var>envRec</var>.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>F</var>.[[Environment]].</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-web-compat-functiondeclarationinstantiation": {"num": "B.3.3.1", "title": "#sec-web-compat-functiondeclarationinstantiation Changes to FunctionDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-functiondeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-functiondeclarationinstantiation\">#sec-web-compat-functiondeclarationinstantiation</span> Changes to FunctionDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"FunctionDeclarationInstantiation\"><a href=\"#sec-functiondeclarationinstantiation\">FunctionDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 29:</p>\n        <emu-alg><ol><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>For each <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> that is directly contained in the <emu-nt><a href=\"#prod-StatementList\">StatementList</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>, <emu-nt><a href=\"#prod-CaseClause\">CaseClause</a></emu-nt>, or <emu-nt><a href=\"#prod-DefaultClause\">DefaultClause</a></emu-nt>, do<ol><li>Let <var>F</var> be StringValue of the <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> of <var>f</var>.</li><li>If replacing the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> with a <emu-nt><a href=\"#prod-VariableStatement\">VariableStatement</a></emu-nt> that has <var>F</var> as a <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> would not produce any Early Errors for <var>func</var> and <var>F</var> is not an element of <var>parameterNames</var>, then<ol><li>NOTE: A var binding for <var>F</var> is only instantiated here if it is neither a VarDeclaredName, the name of a formal parameter, or another <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>.</li><li>If <var>initializedBindings</var> does not contain <var>F</var> and <var>F</var> is not <emu-val>\"arguments\"</emu-val>, then<ol><li>Perform ! <var>varEnvRec</var>.CreateMutableBinding(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform <var>varEnvRec</var>.InitializeBinding(<var>F</var>, <emu-val>undefined</emu-val>).</li><li>Append <var>F</var> to <var>instantiatedVarNames</var>.</li></ol></li><li>When the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> is evaluated, perform the following steps in place of the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> Evaluation algorithm provided in <emu-xref href=\"#sec-function-definitions-runtime-semantics-evaluation\"><a href=\"#sec-function-definitions-runtime-semantics-evaluation\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</a></emu-xref>:<ol><li>Let <var>fenv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s VariableEnvironment.</li><li>Let <var>fenvRec</var> be <var>fenv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>benv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>benvRec</var> be <var>benv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>fobj</var> be ! <var>benvRec</var>.GetBindingValue(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform ! <var>fenvRec</var>.SetMutableBinding(<var>F</var>, <var>fobj</var>, <emu-val>false</emu-val>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n      </emu-annex>\n      "}, "sec-async-function-definitions-runtime-semantics-evaluation": {"num": "14.7.14", "title": "#sec-async-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-async-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-function-definitions-runtime-semantics-evaluation\">#sec-async-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"AsyncFunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e2632ddf\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncFunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"6a076671\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncFunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"6a076671\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncFunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e2632ddf\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the LexicalEnvironment of the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>funcEnv</var> be !&#160;<emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>envRec</var> be <var>funcEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be !&#160;<emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(%AsyncFunction.prototype%, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform !&#160;<emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Perform ! <var>envRec</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt>.</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AwaitExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AwaitExpression\">AwaitExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"ef22da1b\"><emu-t>await</emu-t><emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).\n      </li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-blockdeclarationinstantiation": {"num": "13.2.14", "title": "#sec-blockdeclarationinstantiation Runtime Semantics: BlockDeclarationInstantiation ( code, env )", "html": "<emu-clause id=\"sec-blockdeclarationinstantiation\" aoid=\"BlockDeclarationInstantiation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-blockdeclarationinstantiation\">#sec-blockdeclarationinstantiation</span> Runtime Semantics: BlockDeclarationInstantiation ( <var>code</var>, <var>env</var> )</h1>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>When a <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt> or <emu-nt><a href=\"#prod-CaseBlock\">CaseBlock</a></emu-nt> is evaluated a new declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</p>\n      </div></emu-note>\n      <p>The abstract operation BlockDeclarationInstantiation takes arguments <var>code</var> (a <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref>) and <var>env</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). <var>code</var> is the <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> corresponding to the body of the block. <var>env</var> is the <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref> in which bindings are to be created. It performs the following steps when called:</p>\n      <!--\n        WARNING: If you add, remove, rename, or repurpose any variable names\n                 within this algorithm, you may need to update\n                 #sec-web-compat-blockdeclarationinstantiation accordingly.\n      -->\n      <emu-alg><ol><li>Let <var>envRec</var> be <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>envRec</var> is a declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Let <var>declarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>declarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li><li>If <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, then<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>d</var> with argument <var>env</var>.</li><li>Perform <var>envRec</var>.InitializeBinding(<var>fn</var>, <var>fo</var>).\n      </li></ol></li></ol></li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-ecmascript-function-objects-construct-argumentslist-newtarget": {"num": "9.2.2", "title": "#sec-ecmascript-function-objects-construct-argumentslist-newtarget [[Construct]] ( argumentsList, newTarget )", "html": "<emu-clause id=\"sec-ecmascript-function-objects-construct-argumentslist-newtarget\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-function-objects-construct-argumentslist-newtarget\">#sec-ecmascript-function-objects-construct-argumentslist-newtarget</span> [[Construct]] ( <var>argumentsList</var>, <var>newTarget</var> )</h1>\n      <p>The [[Construct]] internal method for an ECMAScript <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> <var>F</var> is called with parameters <var>argumentsList</var> and <var>newTarget</var>. <var>argumentsList</var> is a possibly empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of ECMAScript language values. The following steps are taken:</p>\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>F</var> is an ECMAScript <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>newTarget</var>) is Object.</li><li>Let <var>callerContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>kind</var> be <var>F</var>.[[ConstructorKind]].</li><li>If <var>kind</var> is <emu-const>base</emu-const>, then<ol><li>Let <var>thisArgument</var> be ?&#160;<emu-xref aoid=\"OrdinaryCreateFromConstructor\"><a href=\"#sec-ordinarycreatefromconstructor\">OrdinaryCreateFromConstructor</a></emu-xref>(<var>newTarget</var>, <emu-val>\"%Object.prototype%\"</emu-val>).</li></ol></li><li>Let <var>calleeContext</var> be <emu-xref aoid=\"PrepareForOrdinaryCall\"><a href=\"#sec-prepareforordinarycall\">PrepareForOrdinaryCall</a></emu-xref>(<var>F</var>, <var>newTarget</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>calleeContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>kind</var> is <emu-const>base</emu-const>, perform <emu-xref aoid=\"OrdinaryCallBindThis\"><a href=\"#sec-ordinarycallbindthis\">OrdinaryCallBindThis</a></emu-xref>(<var>F</var>, <var>calleeContext</var>, <var>thisArgument</var>).</li><li>Let <var>constructorEnv</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>Let <var>envRec</var> be <var>constructorEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid=\"OrdinaryCallEvaluateBody\"><a href=\"#sec-ordinarycallevaluatebody\">OrdinaryCallEvaluateBody</a></emu-xref>(<var>F</var>, <var>argumentsList</var>).</li><li>Remove <var>calleeContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore <var>callerContext</var> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>result</var>.[[Value]]) is Object, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>result</var>.[[Value]]).</li><li>If <var>kind</var> is <emu-const>base</emu-const>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>thisArgument</var>).</li><li>If <var>result</var>.[[Value]] is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Else, <emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return ? <var>envRec</var>.GetThisBinding().\n      </li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-for-statement-runtime-semantics-labelledevaluation": {"num": "13.7.4.7", "title": "#sec-for-statement-runtime-semantics-labelledevaluation Runtime Semantics: LabelledEvaluation", "html": "<emu-clause id=\"sec-for-statement-runtime-semantics-labelledevaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-for-statement-runtime-semantics-labelledevaluation\">#sec-for-statement-runtime-semantics-labelledevaluation</span> Runtime Semantics: LabelledEvaluation</h1>\n        <p>With parameter <var>labelSet</var>.</p>\n        <emu-see-also-para op=\"LabelledEvaluation\"></emu-see-also-para>\n        <emu-grammar><emu-production name=\"IterationStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-IterationStatement\">IterationStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"fc33bcf0\"><emu-t>for</emu-t><emu-t>(</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>If the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt> is present, then<ol><li>Let <var>exprRef</var> be the result of evaluating the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>.</li><li>Perform ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"ForBodyEvaluation\"><a href=\"#sec-forbodyevaluation\">ForBodyEvaluation</a></emu-xref>(the second <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, the third <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, &#171; &#187;, <var>labelSet</var>).\n        </li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"IterationStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-IterationStatement\">IterationStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"48e766b4\"><emu-t>for</emu-t><emu-t>(</emu-t><emu-t>var</emu-t><emu-nt><a href=\"#prod-VariableDeclarationList\">VariableDeclarationList</a></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>varDcl</var> be the result of evaluating <emu-nt><a href=\"#prod-VariableDeclarationList\">VariableDeclarationList</a></emu-nt>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>varDcl</var>).</li><li>Return ?&#160;<emu-xref aoid=\"ForBodyEvaluation\"><a href=\"#sec-forbodyevaluation\">ForBodyEvaluation</a></emu-xref>(the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, the second <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, &#171; &#187;, <var>labelSet</var>).\n        </li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"IterationStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-IterationStatement\">IterationStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"93c07e45\"><emu-t>for</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>loopEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>Let <var>loopEnvRec</var> be <var>loopEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>isConst</var> be IsConstantDeclaration of <emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt>.</li><li>Let <var>boundNames</var> be the BoundNames of <emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt>.</li><li>For each element <var>dn</var> of <var>boundNames</var>, do<ol><li>If <var>isConst</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>loopEnvRec</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>loopEnvRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>loopEnv</var>.</li><li>Let <var>forDcl</var> be the result of evaluating <emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt>.</li><li>If <var>forDcl</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>forDcl</var>).</li></ol></li><li>If <var>isConst</var> is <emu-val>false</emu-val>, let <var>perIterationLets</var> be <var>boundNames</var>; otherwise let <var>perIterationLets</var> be &#171; &#187;.</li><li>Let <var>bodyResult</var> be <emu-xref aoid=\"ForBodyEvaluation\"><a href=\"#sec-forbodyevaluation\">ForBodyEvaluation</a></emu-xref>(the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, the second <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, <var>perIterationLets</var>, <var>labelSet</var>).</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>bodyResult</var>).\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-ordinarycallbindthis": {"num": "9.2.1.2", "title": "#sec-ordinarycallbindthis OrdinaryCallBindThis ( F, calleeContext, thisArgument )", "html": "<emu-clause id=\"sec-ordinarycallbindthis\" aoid=\"OrdinaryCallBindThis\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ordinarycallbindthis\">#sec-ordinarycallbindthis</span> OrdinaryCallBindThis ( <var>F</var>, <var>calleeContext</var>, <var>thisArgument</var> )</h1>\n        <p>The abstract operation OrdinaryCallBindThis takes arguments <var>F</var> (a <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>), <var>calleeContext</var> (an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>), and <var>thisArgument</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>thisMode</var> be <var>F</var>.[[ThisMode]].</li><li>If <var>thisMode</var> is <emu-const>lexical</emu-const>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Let <var>calleeRealm</var> be <var>F</var>.[[Realm]].</li><li>Let <var>localEnv</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>If <var>thisMode</var> is <emu-const>strict</emu-const>, let <var>thisValue</var> be <var>thisArgument</var>.</li><li>Else,<ol><li>If <var>thisArgument</var> is <emu-val>undefined</emu-val> or <emu-val>null</emu-val>, then<ol><li>Let <var>globalEnv</var> be <var>calleeRealm</var>.[[GlobalEnv]].</li><li>Let <var>globalEnvRec</var> be <var>globalEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>globalEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Let <var>thisValue</var> be <var>globalEnvRec</var>.[[GlobalThisValue]].</li></ol></li><li>Else,<ol><li>Let <var>thisValue</var> be !&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>thisArgument</var>).</li><li>NOTE: <emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref> produces wrapper objects using <var>calleeRealm</var>.</li></ol></li></ol></li><li>Let <var>envRec</var> be <var>localEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>envRec</var> is a <emu-xref href=\"#sec-function-environment-records\"><a href=\"#sec-function-environment-records\">function Environment Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The next step never returns an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> because <var>envRec</var>.[[ThisBindingStatus]] is not <emu-const>initialized</emu-const>.</li><li>Return <var>envRec</var>.BindThisValue(<var>thisValue</var>).\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-web-compat-evaldeclarationinstantiation": {"num": "B.3.3.3", "title": "#sec-web-compat-evaldeclarationinstantiation Changes to EvalDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-evaldeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-evaldeclarationinstantiation\">#sec-web-compat-evaldeclarationinstantiation</span> Changes to EvalDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"EvalDeclarationInstantiation\"><a href=\"#sec-evaldeclarationinstantiation\">EvalDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 9:</p>\n        <emu-alg><ol><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>declaredFunctionOrVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredFunctionNames</var>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredVarNames</var>.</li><li>For each <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> that is directly contained in the <emu-nt><a href=\"#prod-StatementList\">StatementList</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>, <emu-nt><a href=\"#prod-CaseClause\">CaseClause</a></emu-nt>, or <emu-nt><a href=\"#prod-DefaultClause\">DefaultClause</a></emu-nt> Contained within <var>body</var>, do<ol><li>Let <var>F</var> be StringValue of the <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> of <var>f</var>.</li><li>If replacing the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> with a <emu-nt><a href=\"#prod-VariableStatement\">VariableStatement</a></emu-nt> that has <var>F</var> as a <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> would not produce any Early Errors for <var>body</var>, then<ol><li>Let <var>bindingExists</var> be <emu-val>false</emu-val>.</li><li>Let <var>thisLex</var> be <var>lexEnv</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The following loop will terminate.</li><li>Repeat, while <var>thisLex</var> is not the same as <var>varEnv</var>,<ol><li>Let <var>thisEnvRec</var> be <var>thisLex</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>If <var>thisEnvRec</var> is not an object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>If <var>thisEnvRec</var>.HasBinding(<var>F</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>bindingExists</var> be <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Set <var>thisLex</var> to <var>thisLex</var>.[[OuterEnv]].</li></ol></li><li>If <var>bindingExists</var> is <emu-val>false</emu-val> and <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>If <var>varEnvRec</var>.HasLexicalDeclaration(<var>F</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>fnDefinable</var> be ? <var>varEnvRec</var>.CanDeclareGlobalVar(<var>F</var>).</li></ol></li><li>Else,<ol><li>Let <var>fnDefinable</var> be <emu-val>false</emu-val>.</li></ol></li></ol></li><li>Else,<ol><li>Let <var>fnDefinable</var> be <emu-val>true</emu-val>.</li></ol></li><li>If <var>bindingExists</var> is <emu-val>false</emu-val> and <var>fnDefinable</var> is <emu-val>true</emu-val>, then<ol><li>If <var>declaredFunctionOrVarNames</var> does not contain <var>F</var>, then<ol><li>If <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Perform ? <var>varEnvRec</var>.CreateGlobalVarBinding(<var>F</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>bindingExists</var> be <var>varEnvRec</var>.HasBinding(<var>F</var>).</li><li>If <var>bindingExists</var> is <emu-val>false</emu-val>, then<ol><li>Perform ! <var>varEnvRec</var>.CreateMutableBinding(<var>F</var>, <emu-val>true</emu-val>).</li><li>Perform ! <var>varEnvRec</var>.InitializeBinding(<var>F</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li><li>Append <var>F</var> to <var>declaredFunctionOrVarNames</var>.</li></ol></li><li>When the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> is evaluated, perform the following steps in place of the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> Evaluation algorithm provided in <emu-xref href=\"#sec-function-definitions-runtime-semantics-evaluation\"><a href=\"#sec-function-definitions-runtime-semantics-evaluation\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</a></emu-xref>:<ol><li>Let <var>genv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s VariableEnvironment.</li><li>Let <var>genvRec</var> be <var>genv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>benv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>benvRec</var> be <var>benv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>fobj</var> be ! <var>benvRec</var>.GetBindingValue(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform ? <var>genvRec</var>.SetMutableBinding(<var>F</var>, <var>fobj</var>, <emu-val>false</emu-val>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n      </emu-annex>\n      "}, "sec-newmoduleenvironment": {"num": "8.1.2.6", "title": "#sec-newmoduleenvironment NewModuleEnvironment ( E )", "html": "<emu-clause id=\"sec-newmoduleenvironment\" aoid=\"NewModuleEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newmoduleenvironment\">#sec-newmoduleenvironment</span> NewModuleEnvironment ( <var>E</var> )</h1>\n        <p>The abstract operation NewModuleEnvironment takes argument <var>E</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>.</li><li>Let <var>envRec</var> be a new module <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing no bindings.</li><li>Set <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> to <var>envRec</var>.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>E</var>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-web-compat-blockdeclarationinstantiation": {"num": "B.3.3.6", "title": "#sec-web-compat-blockdeclarationinstantiation Changes to BlockDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-blockdeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-blockdeclarationinstantiation\">#sec-web-compat-blockdeclarationinstantiation</span> Changes to BlockDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"BlockDeclarationInstantiation\"><a href=\"#sec-blockdeclarationinstantiation\">BlockDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 4.a.ii.1:</p>\n        <emu-alg><ol><li>If <var>envRec</var>.HasBinding(<var>dn</var>) is <emu-val>false</emu-val>, then<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).\n        </li></ol></li></ol></emu-alg>\n        <p>During <emu-xref aoid=\"BlockDeclarationInstantiation\"><a href=\"#sec-blockdeclarationinstantiation\">BlockDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 4.b.iii:</p>\n        <emu-alg><ol><li>If the binding for <var>fn</var> in <var>envRec</var> is an uninitialized binding, then<ol><li>Perform <var>envRec</var>.InitializeBinding(<var>fn</var>, <var>fo</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>.</li><li>Perform <var>envRec</var>.SetMutableBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).\n        </li></ol></li></ol></emu-alg>\n      </emu-annex>\n    "}, "sec-runtime-semantics-forinofheadevaluation": {"num": "13.7.5.12", "title": "#sec-runtime-semantics-forinofheadevaluation Runtime Semantics: ForIn/OfHeadEvaluation ( uninitializedBoundNames, expr, iterationKind )", "html": "<emu-clause id=\"sec-runtime-semantics-forinofheadevaluation\" oldids=\"sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind\" aoid=\"ForIn/OfHeadEvaluation\">\n        <span id=\"sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-forinofheadevaluation\">#sec-runtime-semantics-forinofheadevaluation</span> Runtime Semantics: ForIn/OfHeadEvaluation ( <var>uninitializedBoundNames</var>, <var>expr</var>, <var>iterationKind</var> )</h1>\n        <p>The abstract operation ForIn/OfHeadEvaluation takes arguments <var>uninitializedBoundNames</var>, <var>expr</var>, and <var>iterationKind</var> (either <emu-const>enumerate</emu-const>, <emu-const>iterate</emu-const>, or <emu-const>async-iterate</emu-const>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>If <var>uninitializedBoundNames</var> is not an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>uninitializedBoundNames</var> has no duplicate entries.</li><li>Let <var>newEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>Let <var>newEnvRec</var> be <var>newEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>For each string <var>name</var> in <var>uninitializedBoundNames</var>, do<ol><li>Perform ! <var>newEnvRec</var>.CreateMutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>newEnv</var>.</li></ol></li><li>Let <var>exprRef</var> be the result of evaluating <var>expr</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Let <var>exprValue</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>If <var>iterationKind</var> is <emu-const>enumerate</emu-const>, then<ol><li>If <var>exprValue</var> is <emu-val>undefined</emu-val> or <emu-val>null</emu-val>, then<ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>break</emu-const>, [[Value]]: <emu-const>empty</emu-const>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>exprValue</var>).</li><li>Return ?&#160;<emu-xref aoid=\"EnumerateObjectProperties\"><a href=\"#sec-enumerate-object-properties\">EnumerateObjectProperties</a></emu-xref>(<var>obj</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iterationKind</var> is <emu-const>iterate</emu-const> or <emu-const>async-iterate</emu-const>.</li><li>If <var>iterationKind</var> is <emu-const>async-iterate</emu-const>, let <var>iteratorHint</var> be <emu-const>async</emu-const>.</li><li>Else, let <var>iteratorHint</var> be <emu-const>sync</emu-const>.</li><li>Return ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>exprValue</var>, <var>iteratorHint</var>).\n        </li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-module-namespace-exotic-objects-get-p-receiver": {"num": "9.4.6.7", "title": "#sec-module-namespace-exotic-objects-get-p-receiver [[Get]] ( P, Receiver )", "html": "<emu-clause id=\"sec-module-namespace-exotic-objects-get-p-receiver\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-module-namespace-exotic-objects-get-p-receiver\">#sec-module-namespace-exotic-objects-get-p-receiver</span> [[Get]] ( <var>P</var>, <var>Receiver</var> )</h1>\n        <p>When the [[Get]] internal method of a <emu-xref href=\"#module-namespace-exotic-object\"><a href=\"#module-namespace-exotic-object\">module namespace exotic object</a></emu-xref> <var>O</var> is called with property key <var>P</var> and <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref> <var>Receiver</var>, the following steps are taken:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsPropertyKey\"><a href=\"#sec-ispropertykey\">IsPropertyKey</a></emu-xref>(<var>P</var>) is <emu-val>true</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>P</var>) is Symbol, then<ol><li>Return ?&#160;<emu-xref aoid=\"OrdinaryGet\"><a href=\"#sec-ordinaryget\">OrdinaryGet</a></emu-xref>(<var>O</var>, <var>P</var>, <var>Receiver</var>).</li></ol></li><li>Let <var>exports</var> be <var>O</var>.[[Exports]].</li><li>If <var>P</var> is not an element of <var>exports</var>, return <emu-val>undefined</emu-val>.</li><li>Let <var>m</var> be <var>O</var>.[[Module]].</li><li>Let <var>binding</var> be ! <var>m</var>.ResolveExport(<var>P</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>binding</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>.</li><li>Let <var>targetModule</var> be <var>binding</var>.[[Module]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>targetModule</var> is not <emu-val>undefined</emu-val>.</li><li>If <var>binding</var>.[[BindingName]] is <emu-val>\"*namespace*\"</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>targetModule</var>).</li></ol></li><li>Let <var>targetEnv</var> be <var>targetModule</var>.[[Environment]].</li><li>If <var>targetEnv</var> is <emu-val>undefined</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Let <var>targetEnvRec</var> be <var>targetEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Return ? <var>targetEnvRec</var>.GetBindingValue(<var>binding</var>.[[BindingName]], <emu-val>true</emu-val>).\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>ResolveExport is side-effect free. Each time this operation is called with a specific <var>exportName</var>, <var>resolveSet</var> pair as arguments it must return the same result. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each <emu-xref href=\"#module-namespace-exotic-object\"><a href=\"#module-namespace-exotic-object\">module namespace exotic object</a></emu-xref>.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-evaldeclarationinstantiation": {"num": "18.2.1.3", "title": "#sec-evaldeclarationinstantiation Runtime Semantics: EvalDeclarationInstantiation ( body, varEnv, lexEnv, strict )", "html": "<emu-clause id=\"sec-evaldeclarationinstantiation\" aoid=\"EvalDeclarationInstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-evaldeclarationinstantiation\">#sec-evaldeclarationinstantiation</span> Runtime Semantics: EvalDeclarationInstantiation ( <var>body</var>, <var>varEnv</var>, <var>lexEnv</var>, <var>strict</var> )</h1>\n        <p>The abstract operation EvalDeclarationInstantiation takes arguments <var>body</var>, <var>varEnv</var>, <var>lexEnv</var>, and <var>strict</var>. It performs the following steps when called:</p>\n        <!--\n          WARNING: If you add, remove, rename, or repurpose any variable names\n                   within this algorithm, you may need to update\n                   #sec-web-compat-evaldeclarationinstantiation and\n                   #sec-variablestatements-in-catch-blocks accordingly.\n        -->\n        <emu-alg><ol><li>Let <var>varNames</var> be the VarDeclaredNames of <var>body</var>.</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>body</var>.</li><li>Let <var>lexEnvRec</var> be <var>lexEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>varEnvRec</var> be <var>varEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>If <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>For each <var>name</var> in <var>varNames</var>, do<ol><li>If <var>varEnvRec</var>.HasLexicalDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>NOTE: <code>eval</code> will not create a global var declaration that would be shadowed by a global lexical declaration.</li></ol></li></ol></li><li>Let <var>thisLex</var> be <var>lexEnv</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The following loop will terminate.</li><li>Repeat, while <var>thisLex</var> is not the same as <var>varEnv</var>,<ol><li>Let <var>thisEnvRec</var> be <var>thisLex</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>If <var>thisEnvRec</var> is not an object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.</li><li>For each <var>name</var> in <var>varNames</var>, do<ol><li>If <var>thisEnvRec</var>.HasBinding(<var>name</var>) is <emu-val>true</emu-val>, then<ol><li>Throw a <emu-val>SyntaxError</emu-val> exception.</li><li>NOTE: Annex <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"><a href=\"#sec-variablestatements-in-catch-blocks\" class=\"excluded-xref\" excluded-id=\"sec-variablestatements-in-catch-blocks\">#sec-variablestatements-in-catch-blocks</a></emu-xref> defines alternate semantics for the above step.</li></ol></li><li>NOTE: A <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> will not hoist var declaration over a like-named lexical declaration.</li></ol></li></ol></li><li>Set <var>thisLex</var> to <var>thisLex</var>.[[OuterEnv]].</li></ol></li></ol></li><li>Let <var>functionsToInitialize</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>declaredFunctionNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, in reverse list order, do<ol><li>If <var>d</var> is neither a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt> nor a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt> nor a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is either a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>.</li><li>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</li><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>If <var>fn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>If <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Let <var>fnDefinable</var> be ? <var>varEnvRec</var>.CanDeclareGlobalFunction(<var>fn</var>).</li><li>If <var>fnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Append <var>fn</var> to <var>declaredFunctionNames</var>.</li><li>Insert <var>d</var> as the first element of <var>functionsToInitialize</var>.</li></ol></li></ol></li></ol></li><li>NOTE: Annex <emu-xref href=\"#sec-web-compat-evaldeclarationinstantiation\"><a href=\"#sec-web-compat-evaldeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-web-compat-evaldeclarationinstantiation\">#sec-web-compat-evaldeclarationinstantiation</a></emu-xref> adds additional steps at this point.</li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, do<ol><li>If <var>d</var> is a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>, or a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li>For each String <var>vn</var> in the BoundNames of <var>d</var>, do<ol><li>If <var>vn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>If <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Let <var>vnDefinable</var> be ? <var>varEnvRec</var>.CanDeclareGlobalVar(<var>vn</var>).</li><li>If <var>vnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>If <var>vn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Append <var>vn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>NOTE: No abnormal terminations occur after this algorithm step unless <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> and the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is a <emu-xref href=\"#proxy-exotic-object\"><a href=\"#proxy-exotic-object\">Proxy exotic object</a></emu-xref>.</li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>body</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>NOTE: Lexically declared names are only instantiated here but not initialized.</li><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ? <var>lexEnvRec</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ? <var>lexEnvRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> <var>f</var> in <var>functionsToInitialize</var>, do<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>f</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>f</var> with argument <var>lexEnv</var>.</li><li>If <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Perform ? <var>varEnvRec</var>.CreateGlobalFunctionBinding(<var>fn</var>, <var>fo</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>bindingExists</var> be <var>varEnvRec</var>.HasBinding(<var>fn</var>).</li><li>If <var>bindingExists</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>status</var> be ! <var>varEnvRec</var>.CreateMutableBinding(<var>fn</var>, <emu-val>true</emu-val>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>status</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> because of validation preceding step 12.</li><li>Perform ! <var>varEnvRec</var>.InitializeBinding(<var>fn</var>, <var>fo</var>).</li></ol></li><li>Else,<ol><li>Perform ! <var>varEnvRec</var>.SetMutableBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each String <var>vn</var> in <var>declaredVarNames</var>, in list order, do<ol><li>If <var>varEnvRec</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Perform ? <var>varEnvRec</var>.CreateGlobalVarBinding(<var>vn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>bindingExists</var> be <var>varEnvRec</var>.HasBinding(<var>vn</var>).</li><li>If <var>bindingExists</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>status</var> be ! <var>varEnvRec</var>.CreateMutableBinding(<var>vn</var>, <emu-val>true</emu-val>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>status</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> because of validation preceding step 12.</li><li>Perform ! <var>varEnvRec</var>.InitializeBinding(<var>vn</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>An alternative version of this algorithm is described in  <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"><a href=\"#sec-variablestatements-in-catch-blocks\" class=\"excluded-xref\" excluded-id=\"sec-variablestatements-in-catch-blocks\">#sec-variablestatements-in-catch-blocks</a></emu-xref>.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-newglobalenvironment": {"num": "8.1.2.5", "title": "#sec-newglobalenvironment NewGlobalEnvironment ( G, thisValue )", "html": "<emu-clause id=\"sec-newglobalenvironment\" aoid=\"NewGlobalEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newglobalenvironment\">#sec-newglobalenvironment</span> NewGlobalEnvironment ( <var>G</var>, <var>thisValue</var> )</h1>\n        <p>The abstract operation NewGlobalEnvironment takes arguments <var>G</var> and <var>thisValue</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>.</li><li>Let <var>objRec</var> be a new object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing <var>G</var> as the binding object.</li><li>Let <var>dclRec</var> be a new declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing no bindings.</li><li>Let <var>globalRec</var> be a new global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Set <var>globalRec</var>.[[ObjectRecord]] to <var>objRec</var>.</li><li>Set <var>globalRec</var>.[[GlobalThisValue]] to <var>thisValue</var>.</li><li>Set <var>globalRec</var>.[[DeclarativeRecord]] to <var>dclRec</var>.</li><li>Set <var>globalRec</var>.[[VarNames]] to a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Set <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> to <var>globalRec</var>.</li><li>Set <var>env</var>.[[OuterEnv]] to <emu-val>null</emu-val>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-functiondeclarationinstantiation": {"num": "9.2.10", "title": "#sec-functiondeclarationinstantiation FunctionDeclarationInstantiation ( func, argumentsList )", "html": "<emu-clause id=\"sec-functiondeclarationinstantiation\" aoid=\"FunctionDeclarationInstantiation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-functiondeclarationinstantiation\">#sec-functiondeclarationinstantiation</span> FunctionDeclarationInstantiation ( <var>func</var>, <var>argumentsList</var> )</h1>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>When an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is established for evaluating an ECMAScript function a new <emu-xref href=\"#sec-function-environment-records\"><a href=\"#sec-function-environment-records\">function Environment Record</a></emu-xref> is created and bindings for each formal parameter are instantiated in that <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> as the parameters. If default value parameter initializers exist, a second <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.</p>\n      </div></emu-note>\n      <p>The abstract operation FunctionDeclarationInstantiation takes arguments <var>func</var> (a <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>) and <var>argumentsList</var>. <var>func</var> is the <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> for which the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is being established. It performs the following steps when called:</p>\n      <!--\n        WARNING: If you add, remove, rename, or repurpose any variable names\n                 within this algorithm, you may need to update\n                 #sec-web-compat-functiondeclarationinstantiation accordingly.\n      -->\n      <emu-alg><ol><li>Let <var>calleeContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>code</var> be <var>func</var>.[[ECMAScriptCode]].</li><li>Let <var>strict</var> be <var>func</var>.[[Strict]].</li><li>Let <var>formals</var> be <var>func</var>.[[FormalParameters]].</li><li>Let <var>parameterNames</var> be the BoundNames of <var>formals</var>.</li><li>If <var>parameterNames</var> has any duplicate entries, let <var>hasDuplicates</var> be <emu-val>true</emu-val>. Otherwise, let <var>hasDuplicates</var> be <emu-val>false</emu-val>.</li><li>Let <var>simpleParameterList</var> be IsSimpleParameterList of <var>formals</var>.</li><li>Let <var>hasParameterExpressions</var> be ContainsExpression of <var>formals</var>.</li><li>Let <var>varNames</var> be the VarDeclaredNames of <var>code</var>.</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>code</var>.</li><li>Let <var>lexicalNames</var> be the LexicallyDeclaredNames of <var>code</var>.</li><li>Let <var>functionNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>functionsToInitialize</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, in reverse list order, do<ol><li>If <var>d</var> is neither a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt> nor a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt> nor a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is either a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>.</li><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>If <var>fn</var> is not an element of <var>functionNames</var>, then<ol><li>Insert <var>fn</var> as the first element of <var>functionNames</var>.</li><li>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</li><li>Insert <var>d</var> as the first element of <var>functionsToInitialize</var>.</li></ol></li></ol></li></ol></li><li>Let <var>argumentsObjectNeeded</var> be <emu-val>true</emu-val>.</li><li>If <var>func</var>.[[ThisMode]] is <emu-const>lexical</emu-const>, then<ol><li>NOTE: Arrow functions never have an arguments objects.</li><li>Set <var>argumentsObjectNeeded</var> to <emu-val>false</emu-val>.</li></ol></li><li>Else if <emu-val>\"arguments\"</emu-val> is an element of <var>parameterNames</var>, then<ol><li>Set <var>argumentsObjectNeeded</var> to <emu-val>false</emu-val>.</li></ol></li><li>Else if <var>hasParameterExpressions</var> is <emu-val>false</emu-val>, then<ol><li>If <emu-val>\"arguments\"</emu-val> is an element of <var>functionNames</var> or if <emu-val>\"arguments\"</emu-val> is an element of <var>lexicalNames</var>, then<ol><li>Set <var>argumentsObjectNeeded</var> to <emu-val>false</emu-val>.</li></ol></li></ol></li><li>If <var>strict</var> is <emu-val>true</emu-val> or if <var>hasParameterExpressions</var> is <emu-val>false</emu-val>, then<ol><li>NOTE: Only a single lexical environment is needed for the parameters and top-level vars.</li><li>Let <var>env</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>Let <var>envRec</var> be <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li></ol></li><li>Else,<ol><li>NOTE: A separate <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is needed to ensure that bindings created by <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> calls in the formal parameter list are outside the environment where parameters are declared.</li><li>Let <var>calleeEnv</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>Let <var>env</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>calleeEnv</var>).</li><li>Let <var>envRec</var> be <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The VariableEnvironment of <var>calleeContext</var> is <var>calleeEnv</var>.</li><li>Set the LexicalEnvironment of <var>calleeContext</var> to <var>env</var>.</li></ol></li><li>For each String <var>paramName</var> in <var>parameterNames</var>, do<ol><li>Let <var>alreadyDeclared</var> be <var>envRec</var>.HasBinding(<var>paramName</var>).</li><li>NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.</li><li>If <var>alreadyDeclared</var> is <emu-val>false</emu-val>, then<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>paramName</var>, <emu-val>false</emu-val>).</li><li>If <var>hasDuplicates</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>envRec</var>.InitializeBinding(<var>paramName</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li></ol></li><li>If <var>argumentsObjectNeeded</var> is <emu-val>true</emu-val>, then<ol><li>If <var>strict</var> is <emu-val>true</emu-val> or if <var>simpleParameterList</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>ao</var> be <emu-xref aoid=\"CreateUnmappedArgumentsObject\"><a href=\"#sec-createunmappedargumentsobject\">CreateUnmappedArgumentsObject</a></emu-xref>(<var>argumentsList</var>).</li></ol></li><li>Else,<ol><li>NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.</li><li>Let <var>ao</var> be <emu-xref aoid=\"CreateMappedArgumentsObject\"><a href=\"#sec-createmappedargumentsobject\">CreateMappedArgumentsObject</a></emu-xref>(<var>func</var>, <var>formals</var>, <var>argumentsList</var>, <var>envRec</var>).</li></ol></li><li>If <var>strict</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<emu-val>\"arguments\"</emu-val>, <emu-val>false</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<emu-val>\"arguments\"</emu-val>, <emu-val>false</emu-val>).</li></ol></li><li>Call <var>envRec</var>.InitializeBinding(<emu-val>\"arguments\"</emu-val>, <var>ao</var>).</li><li>Let <var>parameterBindings</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>parameterNames</var> with <emu-val>\"arguments\"</emu-val> appended.</li></ol></li><li>Else,<ol><li>Let <var>parameterBindings</var> be <var>parameterNames</var>.</li></ol></li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"CreateListIteratorRecord\"><a href=\"#sec-createlistiteratorRecord\">CreateListIteratorRecord</a></emu-xref>(<var>argumentsList</var>).</li><li>If <var>hasDuplicates</var> is <emu-val>true</emu-val>, then<ol><li>Perform ? IteratorBindingInitialization for <var>formals</var> with <var>iteratorRecord</var> and <emu-val>undefined</emu-val> as arguments.</li></ol></li><li>Else,<ol><li>Perform ? IteratorBindingInitialization for <var>formals</var> with <var>iteratorRecord</var> and <var>env</var> as arguments.</li></ol></li><li>If <var>hasParameterExpressions</var> is <emu-val>false</emu-val>, then<ol><li>NOTE: Only a single lexical environment is needed for the parameters and top-level vars.</li><li>Let <var>instantiatedVarNames</var> be a copy of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> <var>parameterBindings</var>.</li><li>For each <var>n</var> in <var>varNames</var>, do<ol><li>If <var>n</var> is not an element of <var>instantiatedVarNames</var>, then<ol><li>Append <var>n</var> to <var>instantiatedVarNames</var>.</li><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>n</var>, <emu-val>false</emu-val>).</li><li>Call <var>envRec</var>.InitializeBinding(<var>n</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li><li>Let <var>varEnv</var> be <var>env</var>.</li><li>Let <var>varEnvRec</var> be <var>envRec</var>.</li></ol></li><li>Else,<ol><li>NOTE: A separate <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.</li><li>Let <var>varEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>env</var>).</li><li>Let <var>varEnvRec</var> be <var>varEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Set the VariableEnvironment of <var>calleeContext</var> to <var>varEnv</var>.</li><li>Let <var>instantiatedVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>n</var> in <var>varNames</var>, do<ol><li>If <var>n</var> is not an element of <var>instantiatedVarNames</var>, then<ol><li>Append <var>n</var> to <var>instantiatedVarNames</var>.</li><li>Perform ! <var>varEnvRec</var>.CreateMutableBinding(<var>n</var>, <emu-val>false</emu-val>).</li><li>If <var>n</var> is not an element of <var>parameterBindings</var> or if <var>n</var> is an element of <var>functionNames</var>, let <var>initialValue</var> be <emu-val>undefined</emu-val>.</li><li>Else,<ol><li>Let <var>initialValue</var> be ! <var>envRec</var>.GetBindingValue(<var>n</var>, <emu-val>false</emu-val>).</li></ol></li><li>Call <var>varEnvRec</var>.InitializeBinding(<var>n</var>, <var>initialValue</var>).</li><li>NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.</li></ol></li></ol></li></ol></li><li>NOTE: Annex <emu-xref href=\"#sec-web-compat-functiondeclarationinstantiation\"><a href=\"#sec-web-compat-functiondeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-web-compat-functiondeclarationinstantiation\">#sec-web-compat-functiondeclarationinstantiation</a></emu-xref> adds additional steps at this point.</li><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>lexEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>varEnv</var>).</li><li>NOTE: Non-strict functions use a separate lexical <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for top-level lexical declarations so that a <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> always places all declarations into a new <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li></ol></li><li>Else, let <var>lexEnv</var> be <var>varEnv</var>.</li><li>Let <var>lexEnvRec</var> be <var>lexEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Set the LexicalEnvironment of <var>calleeContext</var> to <var>lexEnv</var>.</li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.</li><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>lexEnvRec</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>lexEnvRec</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> <var>f</var> in <var>functionsToInitialize</var>, do<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>f</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>f</var> with argument <var>lexEnv</var>.</li><li>Perform ! <var>varEnvRec</var>.SetMutableBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).</li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p><emu-xref href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\"><a href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" class=\"excluded-xref\" excluded-id=\"sec-block-level-function-declarations-web-legacy-compatibility-semantics\">#sec-block-level-function-declarations-web-legacy-compatibility-semantics</a></emu-xref> provides an extension to the above algorithm that is necessary for backwards compatibility with web browser implementations of ECMAScript that predate ECMAScript 2015.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n        <p>Parameter <emu-nt><a href=\"#prod-Initializer\">Initializer</a></emu-nt>s may contain <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> expressions. Any top level declarations of such evals are only visible to the eval code (<emu-xref href=\"#sec-types-of-source-code\"><a href=\"#sec-types-of-source-code\" class=\"excluded-xref\" excluded-id=\"sec-types-of-source-code\">#sec-types-of-source-code</a></emu-xref>). The creation of the environment for such declarations is described in  <emu-xref href=\"#sec-function-definitions-runtime-semantics-iteratorbindinginitialization\"><a href=\"#sec-function-definitions-runtime-semantics-iteratorbindinginitialization\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-iteratorbindinginitialization\">#sec-function-definitions-runtime-semantics-iteratorbindinginitialization</a></emu-xref>.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-newdeclarativeenvironment": {"num": "8.1.2.2", "title": "#sec-newdeclarativeenvironment NewDeclarativeEnvironment ( E )", "html": "<emu-clause id=\"sec-newdeclarativeenvironment\" aoid=\"NewDeclarativeEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newdeclarativeenvironment\">#sec-newdeclarativeenvironment</span> NewDeclarativeEnvironment ( <var>E</var> )</h1>\n        <p>The abstract operation NewDeclarativeEnvironment takes argument <var>E</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>.</li><li>Let <var>envRec</var> be a new declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing no bindings.</li><li>Set <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> to <var>envRec</var>.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>E</var>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-newobjectenvironment": {"num": "8.1.2.3", "title": "#sec-newobjectenvironment NewObjectEnvironment ( O, E )", "html": "<emu-clause id=\"sec-newobjectenvironment\" aoid=\"NewObjectEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newobjectenvironment\">#sec-newobjectenvironment</span> NewObjectEnvironment ( <var>O</var>, <var>E</var> )</h1>\n        <p>The abstract operation NewObjectEnvironment takes arguments <var>O</var> (an Object) and <var>E</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>.</li><li>Let <var>envRec</var> be a new object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing <var>O</var> as the binding object.</li><li>Set <var>env</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref> to <var>envRec</var>.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>E</var>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-generator-function-definitions-runtime-semantics-evaluation": {"num": "14.4.14", "title": "#sec-generator-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">#sec-generator-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"0d271960\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"7dbc99b6\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>envRec</var> be <var>funcEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform <var>envRec</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be <emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-generatorfunction-prototype-object\"><a href=\"#sec-properties-of-the-generatorfunction-prototype-object\">%Generator%</a></emu-xref>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Let <var>prototype</var> be <emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%Generator.prototype%).</li><li>Perform <emu-xref aoid=\"DefinePropertyOrThrow\"><a href=\"#sec-definepropertyorthrow\">DefinePropertyOrThrow</a></emu-xref>(<var>closure</var>, <emu-val>\"prototype\"</emu-val>, PropertyDescriptor { [[Value]]: <var>prototype</var>, [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }).</li><li>Perform <var>envRec</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt> to allow the generator code to call itself recursively. However, unlike in a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d1df3360\"><emu-t>yield</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<emu-val>undefined</emu-val>, <emu-val>false</emu-val>)).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e741ede8\"><emu-t>yield</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<var>value</var>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <emu-val>false</emu-val>)).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"47a33813\"><emu-t>yield</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>, <var>generatorKind</var>).</li><li>Let <var>iterator</var> be <var>iteratorRecord</var>.[[Iterator]].</li><li>Let <var>received</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Repeat,<ol><li>If <var>received</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>iteratorRecord</var>.[[NextMethod]], <var>iteratorRecord</var>.[[Iterator]], &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else if <var>received</var>.[[Type]] is <emu-const>throw</emu-const>, then<ol><li>Let <var>throw</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"throw\"</emu-val>).</li><li>If <var>throw</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>throw</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>NOTE: Exceptions from the inner iterator <code>throw</code> method are propagated. Normal completions from an inner <code>throw</code> method are processed similarly to an inner <code>next</code>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else,<ol><li>NOTE: If <var>iterator</var> does not have a <code>throw</code> method, this throw is going to terminate the <code>yield*</code> loop. But first we need to give <var>iterator</var> a chance to clean up.</li><li>Let <var>closeCompletion</var> be <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>normal</emu-const>, [[Value]]: <emu-const>empty</emu-const>, [[Target]]: <emu-const>empty</emu-const> }.</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, perform ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>Else, perform ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>NOTE: The next step throws a <emu-val>TypeError</emu-val> to indicate that there was a <code>yield*</code> protocol violation: <var>iterator</var> does not have a <code>throw</code> method.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>received</var>.[[Type]] is <emu-const>return</emu-const>.</li><li>Let <var>return</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"return\"</emu-val>).</li><li>If <var>return</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var>.[[Value]] to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>received</var>.[[Value]]).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>received</var>).</li></ol></li><li>Let <var>innerReturnResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>return</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerReturnResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerReturnResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>return</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerReturnResult</var>).\n      </li></ol></li></ol></li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-globalthis": {"num": "18.1.1", "title": "#sec-globalthis globalThis", "html": "<emu-clause id=\"sec-globalthis\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-globalthis\">#sec-globalthis</span> globalThis</h1>\n      <p>The initial value of the <emu-val>\"globalThis\"</emu-val> property of the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> in a <emu-xref href=\"#realm-record\"><a href=\"#realm-record\">Realm Record</a></emu-xref> <var>realm</var> is <var>realm</var>.[[GlobalEnv]]'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>'s [[GlobalThisValue]].</p>\n      <p>This property has the attributes { [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>\n    </emu-clause>\n\n    "}, "sec-getthisenvironment": {"num": "8.3.3", "title": "#sec-getthisenvironment GetThisEnvironment ( )", "html": "<emu-clause id=\"sec-getthisenvironment\" aoid=\"GetThisEnvironment\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getthisenvironment\">#sec-getthisenvironment</span> GetThisEnvironment ( )</h1>\n      <p>The abstract operation GetThisEnvironment takes no arguments. It finds the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> that currently supplies the binding of the <emu-xref href=\"#sec-keywords-and-reserved-words\"><a href=\"#sec-keywords-and-reserved-words\">keyword</a></emu-xref> <code>this</code>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>Let <var>lex</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Repeat,<ol><li>Let <var>envRec</var> be <var>lex</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>exists</var> be <var>envRec</var>.HasThisBinding().</li><li>If <var>exists</var> is <emu-val>true</emu-val>, return <var>envRec</var>.</li><li>Let <var>outer</var> be <var>lex</var>.[[OuterEnv]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>outer</var> is not <emu-val>null</emu-val>.</li><li>Set <var>lex</var> to <var>outer</var>.\n      </li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The loop in step 2 will always terminate because the list of environments always ends with the <emu-xref href=\"#global-environment\"><a href=\"#global-environment\">global environment</a></emu-xref> which has a <code>this</code> binding.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-runtime-semantics-bindinginstantiation": {"num": "13.7.5.10", "title": "#sec-runtime-semantics-bindinginstantiation Runtime Semantics: BindingInstantiation", "html": "<emu-clause id=\"sec-runtime-semantics-bindinginstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-bindinginstantiation\">#sec-runtime-semantics-bindinginstantiation</span> Runtime Semantics: BindingInstantiation</h1>\n        <p>With parameter <var>environment</var>.</p>\n        <emu-grammar><emu-production name=\"ForDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ForDeclaration\">ForDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d32d6fbc\"><emu-nt><a href=\"#prod-LetOrConst\">LetOrConst</a></emu-nt><emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>envRec</var> be <var>environment</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>envRec</var> is a declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>For each element <var>name</var> of the BoundNames of <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>, do<ol><li>If IsConstantDeclaration of <emu-nt><a href=\"#prod-LetOrConst\">LetOrConst</a></emu-nt> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>envRec</var>.CreateImmutableBinding(<var>name</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>envRec</var>.CreateMutableBinding(<var>name</var>, <emu-val>false</emu-val>).\n        </li></ol></li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-module-environment-records-getbindingvalue-n-s": {"num": "8.1.1.5.1", "title": "#sec-module-environment-records-getbindingvalue-n-s GetBindingValue ( N, S )", "html": "<emu-clause id=\"sec-module-environment-records-getbindingvalue-n-s\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-module-environment-records-getbindingvalue-n-s\">#sec-module-environment-records-getbindingvalue-n-s</span> GetBindingValue ( <var>N</var>, <var>S</var> )</h1>\n          <p>The concrete <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> method GetBindingValue for module Environment Records returns the value of its bound identifier whose name is the value of the argument <var>N</var>. However, if the binding is an indirect binding the value of the target binding is returned. If the binding exists but is uninitialized a <emu-val>ReferenceError</emu-val> is thrown.</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>S</var> is <emu-val>true</emu-val>.</li><li>Let <var>envRec</var> be the module <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for which the method was invoked.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>envRec</var> has a binding for <var>N</var>.</li><li>If the binding for <var>N</var> is an indirect binding, then<ol><li>Let <var>M</var> and <var>N2</var> be the indirection values provided when this binding for <var>N</var> was created.</li><li>Let <var>targetEnv</var> be <var>M</var>.[[Environment]].</li><li>If <var>targetEnv</var> is <emu-val>undefined</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Let <var>targetER</var> be <var>targetEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Return ? <var>targetER</var>.GetBindingValue(<var>N2</var>, <emu-val>true</emu-val>).</li></ol></li><li>If the binding for <var>N</var> in <var>envRec</var> is an uninitialized binding, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Return the value currently bound to <var>N</var> in <var>envRec</var>.\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p><var>S</var> will always be <emu-val>true</emu-val> because a <emu-nt><a href=\"#prod-Module\">Module</a></emu-nt> is always <emu-xref href=\"#sec-strict-mode-code\"><a href=\"#sec-strict-mode-code\">strict mode code</a></emu-xref>.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-runtime-semantics-catchclauseevaluation": {"num": "13.15.7", "title": "#sec-runtime-semantics-catchclauseevaluation Runtime Semantics: CatchClauseEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-catchclauseevaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-catchclauseevaluation\">#sec-runtime-semantics-catchclauseevaluation</span> Runtime Semantics: CatchClauseEvaluation</h1>\n      <p>With parameter <var>thrownValue</var>.</p>\n      <emu-grammar><emu-production name=\"Catch\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Catch\">Catch</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"ddc13c36\"><emu-t>catch</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-CatchParameter\">CatchParameter</a></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Block\">Block</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>catchEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>Let <var>catchEnvRec</var> be <var>catchEnv</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>For each element <var>argName</var> of the BoundNames of <emu-nt><a href=\"#prod-CatchParameter\">CatchParameter</a></emu-nt>, do<ol><li>Perform ! <var>catchEnvRec</var>.CreateMutableBinding(<var>argName</var>, <emu-val>false</emu-val>).</li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>catchEnv</var>.</li><li>Let <var>status</var> be BindingInitialization of <emu-nt><a href=\"#prod-CatchParameter\">CatchParameter</a></emu-nt> with arguments <var>thrownValue</var> and <var>catchEnv</var>.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>B</var> be the result of evaluating <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>B</var>).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"Catch\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Catch\">Catch</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"a18a7645\"><emu-t>catch</emu-t><emu-nt><a href=\"#prod-Block\">Block</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of evaluating <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>No matter how control leaves the <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt> the LexicalEnvironment is always restored to its former state.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-getidentifierreference": {"num": "8.1.2.1", "title": "#sec-getidentifierreference GetIdentifierReference ( lex, name, strict )", "html": "<emu-clause id=\"sec-getidentifierreference\" aoid=\"GetIdentifierReference\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getidentifierreference\">#sec-getidentifierreference</span> GetIdentifierReference ( <var>lex</var>, <var>name</var>, <var>strict</var> )</h1>\n        <p>The abstract operation GetIdentifierReference takes arguments <var>lex</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref> or <emu-val>null</emu-val>), <var>name</var> (a String), and <var>strict</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>lex</var> is the value <emu-val>null</emu-val>, then<ol><li>Return a value of type <emu-xref href=\"#sec-reference-specification-type\"><a href=\"#sec-reference-specification-type\">Reference</a></emu-xref> whose base value component is <emu-val>undefined</emu-val>, whose referenced name component is <var>name</var>, and whose strict reference flag is <var>strict</var>.</li></ol></li><li>Let <var>envRec</var> be <var>lex</var>'s <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">EnvironmentRecord</a></emu-xref>.</li><li>Let <var>exists</var> be ? <var>envRec</var>.HasBinding(<var>name</var>).</li><li>If <var>exists</var> is <emu-val>true</emu-val>, then<ol><li>Return a value of type <emu-xref href=\"#sec-reference-specification-type\"><a href=\"#sec-reference-specification-type\">Reference</a></emu-xref> whose base value component is <var>envRec</var>, whose referenced name component is <var>name</var>, and whose strict reference flag is <var>strict</var>.</li></ol></li><li>Else,<ol><li>Let <var>outer</var> be <var>lex</var>.[[OuterEnv]].</li><li>Return ?&#160;<emu-xref aoid=\"GetIdentifierReference\"><a href=\"#sec-getidentifierreference\">GetIdentifierReference</a></emu-xref>(<var>outer</var>, <var>name</var>, <var>strict</var>).\n        </li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-asyncgenerator-definitions-evaluation", "sec-runtime-semantics-classdefinitionevaluation", "sec-createperiterationenvironment", "sec-variablestatements-in-catch-blocks", "sec-initializeboundname", "sec-web-compat-globaldeclarationinstantiation", "sec-source-text-module-record-initialize-environment", "sec-function-definitions-runtime-semantics-evaluation", "sec-globaldeclarationinstantiation", "sec-with-statement-runtime-semantics-evaluation", "sec-newfunctionenvironment", "sec-web-compat-functiondeclarationinstantiation", "sec-async-function-definitions-runtime-semantics-evaluation", "sec-blockdeclarationinstantiation", "sec-ecmascript-function-objects-construct-argumentslist-newtarget", "sec-for-statement-runtime-semantics-labelledevaluation", "sec-ordinarycallbindthis", "sec-web-compat-evaldeclarationinstantiation", "sec-newmoduleenvironment", "sec-web-compat-blockdeclarationinstantiation", "sec-runtime-semantics-forinofheadevaluation", "sec-module-namespace-exotic-objects-get-p-receiver", "sec-evaldeclarationinstantiation", "sec-newglobalenvironment", "sec-functiondeclarationinstantiation", "sec-newdeclarativeenvironment", "sec-newobjectenvironment", "sec-generator-function-definitions-runtime-semantics-evaluation", "sec-globalthis", "sec-getthisenvironment", "sec-runtime-semantics-bindinginstantiation", "sec-module-environment-records-getbindingvalue-n-s", "sec-runtime-semantics-catchclauseevaluation", "sec-getidentifierreference"], "secData": {"sec-asyncgenerator-definitions-evaluation": {"num": "14.5.14", "title": "#sec-asyncgenerator-definitions-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-asyncgenerator-definitions-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgenerator-definitions-evaluation\">#sec-asyncgenerator-definitions-evaluation</span> Runtime Semantics: Evaluation</h1>\n\n      <emu-grammar><emu-production name=\"AsyncGeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"c51514e0\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>*</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncGeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"13d2cc33\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be !&#160;<emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform ! <var>funcEnv</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be !&#160;<emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-asyncgeneratorfunction-prototype\"><a href=\"#sec-asyncgeneratorfunction-prototype\">%AsyncGenerator%</a></emu-xref>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform !&#160;<emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Let <var>prototype</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%AsyncGenerator.prototype%).</li><li>Perform !&#160;<emu-xref aoid=\"DefinePropertyOrThrow\"><a href=\"#sec-definepropertyorthrow\">DefinePropertyOrThrow</a></emu-xref>(<var>closure</var>, <emu-val>\"prototype\"</emu-val>, PropertyDescriptor { [[Value]]: <var>prototype</var>, [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }).</li><li>Perform ! <var>funcEnv</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt>.</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in an <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-AsyncGeneratorBody\">AsyncGeneratorBody</a></emu-nt> to allow the generator code to call itself recursively. However, unlike in an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in an <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-AsyncGeneratorExpression\">AsyncGeneratorExpression</a></emu-nt>.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-runtime-semantics-classdefinitionevaluation": {"num": "14.6.14", "title": "#sec-runtime-semantics-classdefinitionevaluation Runtime Semantics: ClassDefinitionEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-classdefinitionevaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-classdefinitionevaluation\">#sec-runtime-semantics-classdefinitionevaluation</span> Runtime Semantics: ClassDefinitionEvaluation</h1>\n      <p>With parameters <var>classBinding</var> and <var>className</var>.</p>\n      <emu-grammar><emu-production name=\"ClassTail\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassTail\">ClassTail</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b8ea6aa5\"><emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>{</emu-t><emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>lex</var> be the LexicalEnvironment of the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>classScope</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>lex</var>).</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScope</var>.CreateImmutableBinding(<var>classBinding</var>, <emu-val>true</emu-val>).</li></ol></li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, then<ol><li>Let <var>protoParent</var> be %Object.prototype%.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else,<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>Let <var>superclassRef</var> be the result of evaluating <emu-nt><a href=\"#prod-ClassHeritage\">ClassHeritage</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>lex</var>.</li><li>Let <var>superclass</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>superclassRef</var>).</li><li>If <var>superclass</var> is <emu-val>null</emu-val>, then<ol><li>Let <var>protoParent</var> be <emu-val>null</emu-val>.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else if <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>superclass</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Else,<ol><li>Let <var>protoParent</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>superclass</var>, <emu-val>\"prototype\"</emu-val>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>protoParent</var>) is neither Object nor Null, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorParent</var> be <var>superclass</var>.</li></ol></li></ol></li><li>Let <var>proto</var> be <emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<var>protoParent</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>constructor</var> be <emu-const>empty</emu-const>.</li><li>Else, let <var>constructor</var> be ConstructorMethod of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>If <var>constructor</var> is <emu-const>empty</emu-const>, then<ol><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, then<ol><li>Set <var>constructor</var> to the result of parsing the source text\n              <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">constructor</span>(...args) { <span class=\"hljs-keyword\">super</span>(...args); }</code></pre>\n              using the syntactic grammar with the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> <emu-nt params=\"~Yield, ~Await\"><a href=\"#prod-MethodDefinition\">MethodDefinition</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params></emu-mods></emu-nt>.</li></ol></li><li>Else,<ol><li>Set <var>constructor</var> to the result of parsing the source text\n              <pre><code class=\"javascript hljs\"><span class=\"hljs-keyword\">constructor</span>() {}</code></pre>\n              using the syntactic grammar with the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> <emu-nt params=\"~Yield, ~Await\"><a href=\"#prod-MethodDefinition\">MethodDefinition</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params></emu-mods></emu-nt>.</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>Let <var>constructorInfo</var> be ! DefineMethod of <var>constructor</var> with arguments <var>proto</var> and <var>constructorParent</var>.</li><li>Let <var>F</var> be <var>constructorInfo</var>.[[Closure]].</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>F</var>, <var>className</var>).</li><li>Perform <emu-xref aoid=\"MakeConstructor\"><a href=\"#sec-makeconstructor\">MakeConstructor</a></emu-xref>(<var>F</var>, <emu-val>false</emu-val>, <var>proto</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, set <var>F</var>.[[ConstructorKind]] to <emu-const>derived</emu-const>.</li><li>Perform <emu-xref aoid=\"MakeClassConstructor\"><a href=\"#sec-makeclassconstructor\">MakeClassConstructor</a></emu-xref>(<var>F</var>).</li><li>Perform <emu-xref aoid=\"CreateMethodProperty\"><a href=\"#sec-createmethodproperty\">CreateMethodProperty</a></emu-xref>(<var>proto</var>, <emu-val>\"constructor\"</emu-val>, <var>F</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>methods</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Else, let <var>methods</var> be NonConstructorMethodDefinitions of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>For each <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <var>m</var> in order from <var>methods</var>, do<ol><li>If IsStatic of <var>m</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>status</var> be PropertyDefinitionEvaluation of <var>m</var> with arguments <var>proto</var> and <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>Let <var>status</var> be PropertyDefinitionEvaluation of <var>m</var> with arguments <var>F</var> and <emu-val>false</emu-val>.</li></ol></li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>lex</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>lex</var>.</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScope</var>.InitializeBinding(<var>classBinding</var>, <var>F</var>).</li></ol></li><li>Return <var>F</var>.\n      </li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-createperiterationenvironment": {"num": "13.7.4.9", "title": "#sec-createperiterationenvironment Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings )", "html": "<emu-clause id=\"sec-createperiterationenvironment\" aoid=\"CreatePerIterationEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-createperiterationenvironment\">#sec-createperiterationenvironment</span> Runtime Semantics: CreatePerIterationEnvironment ( <var>perIterationBindings</var> )</h1>\n        <p>The abstract operation CreatePerIterationEnvironment takes argument <var>perIterationBindings</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>perIterationBindings</var> has any elements, then<ol><li>Let <var>lastIterationEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>outer</var> be <var>lastIterationEnv</var>.[[OuterEnv]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>outer</var> is not <emu-val>null</emu-val>.</li><li>Let <var>thisIterationEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>outer</var>).</li><li>For each element <var>bn</var> of <var>perIterationBindings</var>, do<ol><li>Perform ! <var>thisIterationEnv</var>.CreateMutableBinding(<var>bn</var>, <emu-val>false</emu-val>).</li><li>Let <var>lastValue</var> be ? <var>lastIterationEnv</var>.GetBindingValue(<var>bn</var>, <emu-val>true</emu-val>).</li><li>Perform <var>thisIterationEnv</var>.InitializeBinding(<var>bn</var>, <var>lastValue</var>).</li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>thisIterationEnv</var>.</li></ol></li><li>Return <emu-val>undefined</emu-val>.\n        </li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-variablestatements-in-catch-blocks": {"num": "B.3.5", "title": "#sec-variablestatements-in-catch-blocks VariableStatements in Catch Blocks", "html": "<emu-annex id=\"sec-variablestatements-in-catch-blocks\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-variablestatements-in-catch-blocks\">#sec-variablestatements-in-catch-blocks</span> VariableStatements in Catch Blocks</h1>\n      <p>The content of subclause  <emu-xref href=\"#sec-try-statement-static-semantics-early-errors\"><a href=\"#sec-try-statement-static-semantics-early-errors\" class=\"excluded-xref\" excluded-id=\"sec-try-statement-static-semantics-early-errors\">#sec-try-statement-static-semantics-early-errors</a></emu-xref> is replaced with the following:</p>\n      <emu-grammar><emu-production name=\"Catch\" collapsed=\"\" id=\"prod-annexB-Catch\">\n    <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"ddc13c36\"><emu-t>catch</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <ul>\n        <li>\n          It is a Syntax Error if BoundNames of <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> contains any duplicate elements.\n        \n        </li>\n        <li>\n          It is a Syntax Error if any element of the BoundNames of <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> also occurs in the LexicallyDeclaredNames of <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>.\n        \n        </li>\n        <li>\n          It is a Syntax Error if any element of the BoundNames of <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> also occurs in the VarDeclaredNames of <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt> unless <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> is  <emu-grammar><emu-production name=\"CatchParameter\" collapsed=\"\" id=\"prod-annexB-CatchParameter\" class=\" inline\">\n    <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"50e97238\"><emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>.\n        \n        </li>\n      </ul>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause may contain <code>var</code> declarations that bind a name that is also bound by the <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt>. At runtime, such bindings are instantiated in the VariableDeclarationEnvironment. They do not shadow the same-named bindings introduced by the <emu-nt><a href=\"#prod-annexB-CatchParameter\">CatchParameter</a></emu-nt> and hence the <emu-nt><a href=\"#prod-Initializer\">Initializer</a></emu-nt> for such <code>var</code> declarations will assign to the corresponding catch parameter rather than the <code>var</code> binding.</p>\n      </div></emu-note>\n      <p>This modified behaviour also applies to <code>var</code> and <code>function</code> declarations introduced by <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> calls contained within the <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause. This change is accomplished by modifying the algorithm of  <emu-xref href=\"#sec-evaldeclarationinstantiation\"><a href=\"#sec-evaldeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-evaldeclarationinstantiation\">#sec-evaldeclarationinstantiation</a></emu-xref> as follows:</p>\n      <p>Step 3.d.i.2.a.i is replaced by:</p>\n      <emu-alg type=\"i\"><ol><li>If <var>thisLex</var> is not the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause, throw a <emu-val>SyntaxError</emu-val> exception.\n      </li></ol></emu-alg>\n      <p>Step 7.d.ii.4.a.i.i is replaced by:</p>\n      <emu-alg type=\"i\"><ol><li>If <var>thisLex</var> is not the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for a <emu-nt><a href=\"#prod-annexB-Catch\">Catch</a></emu-nt> clause, let <var>bindingExists</var> be <emu-val>true</emu-val>.\n      </li></ol></emu-alg>\n    </emu-annex>\n\n    "}, "sec-initializeboundname": {"num": "12.1.5.1", "title": "#sec-initializeboundname Runtime Semantics: InitializeBoundName ( name, value, environment )", "html": "<emu-clause id=\"sec-initializeboundname\" aoid=\"InitializeBoundName\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-initializeboundname\">#sec-initializeboundname</span> Runtime Semantics: InitializeBoundName ( <var>name</var>, <var>value</var>, <var>environment</var> )</h1>\n        <p>The abstract operation InitializeBoundName takes arguments <var>name</var>, <var>value</var>, and <var>environment</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>name</var>) is String.</li><li>If <var>environment</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>environment</var>.InitializeBinding(<var>name</var>, <var>value</var>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>lhs</var> be <emu-xref aoid=\"ResolveBinding\"><a href=\"#sec-resolvebinding\">ResolveBinding</a></emu-xref>(<var>name</var>).</li><li>Return ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhs</var>, <var>value</var>).\n        </li></ol></li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-web-compat-globaldeclarationinstantiation": {"num": "B.3.3.2", "title": "#sec-web-compat-globaldeclarationinstantiation Changes to GlobalDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-globaldeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-globaldeclarationinstantiation\">#sec-web-compat-globaldeclarationinstantiation</span> Changes to GlobalDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"GlobalDeclarationInstantiation\"><a href=\"#sec-globaldeclarationinstantiation\">GlobalDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 13:</p>\n        <emu-alg><ol><li>Let <var>strict</var> be IsStrict of <var>script</var>.</li><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>declaredFunctionOrVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredFunctionNames</var>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredVarNames</var>.</li><li>For each <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> that is directly contained in the <emu-nt><a href=\"#prod-StatementList\">StatementList</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>, <emu-nt><a href=\"#prod-CaseClause\">CaseClause</a></emu-nt>, or <emu-nt><a href=\"#prod-DefaultClause\">DefaultClause</a></emu-nt> Contained within <var>script</var>, do<ol><li>Let <var>F</var> be StringValue of the <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> of <var>f</var>.</li><li>If replacing the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> with a <emu-nt><a href=\"#prod-VariableStatement\">VariableStatement</a></emu-nt> that has <var>F</var> as a <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> would not produce any Early Errors for <var>script</var>, then<ol><li>If <var>env</var>.HasLexicalDeclaration(<var>F</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>fnDefinable</var> be ? <var>env</var>.CanDeclareGlobalVar(<var>F</var>).</li><li>If <var>fnDefinable</var> is <emu-val>true</emu-val>, then<ol><li>NOTE: A var binding for <var>F</var> is only instantiated here if it is neither a VarDeclaredName nor the name of another <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>.</li><li>If <var>declaredFunctionOrVarNames</var> does not contain <var>F</var>, then<ol><li>Perform ? <var>env</var>.CreateGlobalVarBinding(<var>F</var>, <emu-val>false</emu-val>).</li><li>Append <var>F</var> to <var>declaredFunctionOrVarNames</var>.</li></ol></li><li>When the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> is evaluated, perform the following steps in place of the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> Evaluation algorithm provided in <emu-xref href=\"#sec-function-definitions-runtime-semantics-evaluation\"><a href=\"#sec-function-definitions-runtime-semantics-evaluation\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</a></emu-xref>:<ol><li>Let <var>genv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s VariableEnvironment.</li><li>Let <var>benv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>fobj</var> be ! <var>benv</var>.GetBindingValue(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform ? <var>genv</var>.SetMutableBinding(<var>F</var>, <var>fobj</var>, <emu-val>false</emu-val>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n      </emu-annex>\n      "}, "sec-source-text-module-record-initialize-environment": {"num": "15.2.1.17.4", "title": "#sec-source-text-module-record-initialize-environment InitializeEnvironment ( ) Concrete Method", "html": "<emu-clause id=\"sec-source-text-module-record-initialize-environment\" aoid=\"InitializeEnvironment\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-source-text-module-record-initialize-environment\">#sec-source-text-module-record-initialize-environment</span> InitializeEnvironment ( ) Concrete Method</h1>\n          <p>The InitializeEnvironment concrete method of a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> abstract method.</p>\n          <p>This abstract method performs the following steps:</p>\n\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>.</li><li>For each <emu-xref href=\"#exportentry-record\"><a href=\"#exportentry-record\">ExportEntry Record</a></emu-xref> <var>e</var> in <var>module</var>.[[IndirectExportEntries]], do<ol><li>Let <var>resolution</var> be ? <var>module</var>.ResolveExport(<var>e</var>.[[ExportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resolution</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: All named exports from <var>module</var> are resolvable.</li><li>Let <var>realm</var> be <var>module</var>.[[Realm]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>realm</var> is not <emu-val>undefined</emu-val>.</li><li>Let <var>env</var> be <emu-xref aoid=\"NewModuleEnvironment\"><a href=\"#sec-newmoduleenvironment\">NewModuleEnvironment</a></emu-xref>(<var>realm</var>.[[GlobalEnv]]).</li><li>Set <var>module</var>.[[Environment]] to <var>env</var>.</li><li>For each <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Record</a></emu-xref> <var>in</var> in <var>module</var>.[[ImportEntries]], do<ol><li>Let <var>importedModule</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>in</var>.[[ModuleRequest]]).</li><li>NOTE: The above call cannot fail because imported module requests are a subset of <var>module</var>.[[RequestedModules]], and these have been resolved earlier in this algorithm.</li><li>If <var>in</var>.[[ImportName]] is <emu-val>\"*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>importedModule</var>).</li><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Let <var>resolution</var> be ? <var>importedModule</var>.ResolveExport(<var>in</var>.[[ImportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>resolution</var>.[[BindingName]] is <emu-val>\"*namespace*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>resolution</var>.[[Module]]).</li><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Call <var>env</var>.CreateImportBinding(<var>in</var>.[[LocalName]], <var>resolution</var>.[[Module]], <var>resolution</var>.[[BindingName]]).</li></ol></li></ol></li></ol></li><li>Let <var>moduleContext</var> be a new ECMAScript code <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleContext</var> to <emu-val>null</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> of <var>moduleContext</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleContext</var> to <var>module</var>.</li><li>Set the VariableEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set <var>module</var>.[[Context]] to <var>moduleContext</var>.</li><li>Push <var>moduleContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>moduleContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>code</var> be <var>module</var>.[[ECMAScriptCode]].</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>code</var>.</li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each element <var>d</var> in <var>varDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If <var>dn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>dn</var>, <emu-val>undefined</emu-val>).</li><li>Append <var>dn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li><li>If <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, then<ol><li>Let <var>fo</var> be InstantiateFunctionObject of <var>d</var> with argument <var>env</var>.</li><li>Call <var>env</var>.InitializeBinding(<var>dn</var>, <var>fo</var>).</li></ol></li></ol></li></ol></li><li>Remove <var>moduleContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-function-definitions-runtime-semantics-evaluation": {"num": "14.1.25", "title": "#sec-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"FunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"81739a57\"><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>An alternative semantics is provided in  <emu-xref href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\"><a href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" class=\"excluded-xref\" excluded-id=\"sec-block-level-function-declarations-web-legacy-compatibility-semantics\">#sec-block-level-function-declarations-web-legacy-compatibility-semantics</a></emu-xref>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"FunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b26bacea\"><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"FunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b26bacea\"><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"FunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"81739a57\"><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform <var>funcEnv</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be <emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Perform <emu-xref aoid=\"MakeConstructor\"><a href=\"#sec-makeconstructor\">MakeConstructor</a></emu-xref>(<var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>.</li><li>Perform <var>funcEnv</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt> to allow the function to call itself recursively. However, unlike in a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n        <p>A <emu-val>\"prototype\"</emu-val> property is automatically created for every function defined using a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> or <emu-nt><a href=\"#prod-FunctionExpression\">FunctionExpression</a></emu-nt>, to allow for the possibility that the function will be used as a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"FunctionStatementList\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-FunctionStatementList\">FunctionStatementList</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"37b9c04c\"><emu-gann>[empty]</emu-gann></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).\n      </li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-globaldeclarationinstantiation": {"num": "15.1.11", "title": "#sec-globaldeclarationinstantiation Runtime Semantics: GlobalDeclarationInstantiation ( script, env )", "html": "<emu-clause id=\"sec-globaldeclarationinstantiation\" aoid=\"GlobalDeclarationInstantiation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-globaldeclarationinstantiation\">#sec-globaldeclarationinstantiation</span> Runtime Semantics: GlobalDeclarationInstantiation ( <var>script</var>, <var>env</var> )</h1>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>When an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is established for evaluating scripts, declarations are instantiated in the current <emu-xref href=\"#global-environment\"><a href=\"#global-environment\">global environment</a></emu-xref>. Each global binding declared in the code is instantiated.</p>\n      </div></emu-note>\n      <p>The abstract operation GlobalDeclarationInstantiation takes arguments <var>script</var> (a <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> for <emu-nt><a href=\"#prod-ScriptBody\">ScriptBody</a></emu-nt>) and <var>env</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). <var>script</var> is the <emu-nt><a href=\"#prod-ScriptBody\">ScriptBody</a></emu-nt> for which the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is being established. <var>env</var> is the global lexical environment in which bindings are to be created. It performs the following steps when called:</p>\n      <!--\n        WARNING: If you add, remove, rename, or repurpose any variable names\n                 within this algorithm, you may need to update\n                 #sec-web-compat-globaldeclarationinstantiation accordingly.\n      -->\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>env</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Let <var>lexNames</var> be the LexicallyDeclaredNames of <var>script</var>.</li><li>Let <var>varNames</var> be the VarDeclaredNames of <var>script</var>.</li><li>For each <var>name</var> in <var>lexNames</var>, do<ol><li>If <var>env</var>.HasVarDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>env</var>.HasLexicalDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>Let <var>hasRestrictedGlobal</var> be ? <var>env</var>.HasRestrictedGlobalProperty(<var>name</var>).</li><li>If <var>hasRestrictedGlobal</var> is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li></ol></li><li>For each <var>name</var> in <var>varNames</var>, do<ol><li>If <var>env</var>.HasLexicalDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li></ol></li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>script</var>.</li><li>Let <var>functionsToInitialize</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>declaredFunctionNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, in reverse list order, do<ol><li>If <var>d</var> is neither a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt> nor a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt> nor a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is either a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>.</li><li>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</li><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>If <var>fn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>Let <var>fnDefinable</var> be ? <var>env</var>.CanDeclareGlobalFunction(<var>fn</var>).</li><li>If <var>fnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Append <var>fn</var> to <var>declaredFunctionNames</var>.</li><li>Insert <var>d</var> as the first element of <var>functionsToInitialize</var>.</li></ol></li></ol></li></ol></li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, do<ol><li>If <var>d</var> is a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>, or a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li>For each String <var>vn</var> in the BoundNames of <var>d</var>, do<ol><li>If <var>vn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>Let <var>vnDefinable</var> be ? <var>env</var>.CanDeclareGlobalVar(<var>vn</var>).</li><li>If <var>vnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>vn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Append <var>vn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>NOTE: No abnormal terminations occur after this algorithm step if the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is an <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref>. However, if the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is a <emu-xref href=\"#proxy-exotic-object\"><a href=\"#proxy-exotic-object\">Proxy exotic object</a></emu-xref> it may exhibit behaviours that cause abnormal terminations in some of the following steps.</li><li>NOTE: Annex <emu-xref href=\"#sec-web-compat-globaldeclarationinstantiation\"><a href=\"#sec-web-compat-globaldeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-web-compat-globaldeclarationinstantiation\">#sec-web-compat-globaldeclarationinstantiation</a></emu-xref> adds additional steps at this point.</li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>script</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>NOTE: Lexically declared names are only instantiated here but not initialized.</li><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ? <var>env</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ? <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> <var>f</var> in <var>functionsToInitialize</var>, do<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>f</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>f</var> with argument <var>env</var>.</li><li>Perform ? <var>env</var>.CreateGlobalFunctionBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).</li></ol></li><li>For each String <var>vn</var> in <var>declaredVarNames</var>, in list order, do<ol><li>Perform ? <var>env</var>.CreateGlobalVarBinding(<var>vn</var>, <emu-val>false</emu-val>).</li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>Early errors specified in  <emu-xref href=\"#sec-scripts-static-semantics-early-errors\"><a href=\"#sec-scripts-static-semantics-early-errors\" class=\"excluded-xref\" excluded-id=\"sec-scripts-static-semantics-early-errors\">#sec-scripts-static-semantics-early-errors</a></emu-xref> prevent name conflicts between function/var declarations and let/const/class declarations as well as redeclaration of let/const/class bindings for declaration contained within a single <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt>. However, such conflicts and redeclarations that span more than one <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt> are detected as runtime errors during GlobalDeclarationInstantiation. If any such errors are detected, no bindings are instantiated for the script. However, if the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is defined using Proxy exotic objects then the runtime tests for conflicting declarations may be unreliable resulting in an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> and some global declarations not being instantiated. If this occurs, the code for the <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt> is not evaluated.</p>\n        <p>Unlike explicit var or function declarations, properties that are directly created on the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> result in global bindings that may be shadowed by let/const/class declarations.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-with-statement-runtime-semantics-evaluation": {"num": "13.11.7", "title": "#sec-with-statement-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-with-statement-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-with-statement-runtime-semantics-evaluation\">#sec-with-statement-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"WithStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-WithStatement\">WithStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"23bd2456\"><emu-t>with</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>val</var> be the result of evaluating <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>val</var>)).</li><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>newEnv</var> be <emu-xref aoid=\"NewObjectEnvironment\"><a href=\"#sec-newobjectenvironment\">NewObjectEnvironment</a></emu-xref>(<var>obj</var>, <var>oldEnv</var>).</li><li>Set the <var>withEnvironment</var> flag of <var>newEnv</var> to <emu-val>true</emu-val>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>newEnv</var>.</li><li>Let <var>C</var> be the result of evaluating <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<emu-xref aoid=\"UpdateEmpty\"><a href=\"#sec-updateempty\">UpdateEmpty</a></emu-xref>(<var>C</var>, <emu-val>undefined</emu-val>)).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>No matter how control leaves the embedded <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, whether normally or by some form of <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> or exception, the LexicalEnvironment is always restored to its former state.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-newfunctionenvironment": {"num": "8.1.2.4", "title": "#sec-newfunctionenvironment NewFunctionEnvironment ( F, newTarget )", "html": "<emu-clause id=\"sec-newfunctionenvironment\" aoid=\"NewFunctionEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newfunctionenvironment\">#sec-newfunctionenvironment</span> NewFunctionEnvironment ( <var>F</var>, <var>newTarget</var> )</h1>\n        <p>The abstract operation NewFunctionEnvironment takes arguments <var>F</var> and <var>newTarget</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>F</var> is an ECMAScript function.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>newTarget</var>) is Undefined or Object.</li><li>Let <var>env</var> be a new <emu-xref href=\"#sec-function-environment-records\"><a href=\"#sec-function-environment-records\">function Environment Record</a></emu-xref> containing no bindings.</li><li>Set <var>env</var>.[[FunctionObject]] to <var>F</var>.</li><li>If <var>F</var>.[[ThisMode]] is <emu-const>lexical</emu-const>, set <var>env</var>.[[ThisBindingStatus]] to <emu-const>lexical</emu-const>.</li><li>Else, set <var>env</var>.[[ThisBindingStatus]] to <emu-const>uninitialized</emu-const>.</li><li>Let <var>home</var> be <var>F</var>.[[HomeObject]].</li><li>Set <var>env</var>.[[HomeObject]] to <var>home</var>.</li><li>Set <var>env</var>.[[NewTarget]] to <var>newTarget</var>.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>F</var>.[[Environment]].</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-web-compat-functiondeclarationinstantiation": {"num": "B.3.3.1", "title": "#sec-web-compat-functiondeclarationinstantiation Changes to FunctionDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-functiondeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-functiondeclarationinstantiation\">#sec-web-compat-functiondeclarationinstantiation</span> Changes to FunctionDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"FunctionDeclarationInstantiation\"><a href=\"#sec-functiondeclarationinstantiation\">FunctionDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 29:</p>\n        <emu-alg><ol><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>For each <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> that is directly contained in the <emu-nt><a href=\"#prod-StatementList\">StatementList</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>, <emu-nt><a href=\"#prod-CaseClause\">CaseClause</a></emu-nt>, or <emu-nt><a href=\"#prod-DefaultClause\">DefaultClause</a></emu-nt>, do<ol><li>Let <var>F</var> be StringValue of the <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> of <var>f</var>.</li><li>If replacing the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> with a <emu-nt><a href=\"#prod-VariableStatement\">VariableStatement</a></emu-nt> that has <var>F</var> as a <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> would not produce any Early Errors for <var>func</var> and <var>F</var> is not an element of <var>parameterNames</var>, then<ol><li>NOTE: A var binding for <var>F</var> is only instantiated here if it is neither a VarDeclaredName, the name of a formal parameter, or another <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>.</li><li>If <var>initializedBindings</var> does not contain <var>F</var> and <var>F</var> is not <emu-val>\"arguments\"</emu-val>, then<ol><li>Perform ! <var>varEnv</var>.CreateMutableBinding(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform <var>varEnv</var>.InitializeBinding(<var>F</var>, <emu-val>undefined</emu-val>).</li><li>Append <var>F</var> to <var>instantiatedVarNames</var>.</li></ol></li><li>When the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> is evaluated, perform the following steps in place of the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> Evaluation algorithm provided in <emu-xref href=\"#sec-function-definitions-runtime-semantics-evaluation\"><a href=\"#sec-function-definitions-runtime-semantics-evaluation\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</a></emu-xref>:<ol><li>Let <var>fenv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s VariableEnvironment.</li><li>Let <var>benv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>fobj</var> be ! <var>benv</var>.GetBindingValue(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform ! <var>fenv</var>.SetMutableBinding(<var>F</var>, <var>fobj</var>, <emu-val>false</emu-val>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n      </emu-annex>\n      "}, "sec-async-function-definitions-runtime-semantics-evaluation": {"num": "14.7.14", "title": "#sec-async-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-async-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-function-definitions-runtime-semantics-evaluation\">#sec-async-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"AsyncFunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e2632ddf\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncFunctionDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"6a076671\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncFunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"6a076671\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AsyncFunctionExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e2632ddf\"><emu-t>async</emu-t><emu-t>function</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the LexicalEnvironment of the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>funcEnv</var> be !&#160;<emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform ! <var>funcEnv</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be !&#160;<emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(%AsyncFunction.prototype%, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-AsyncFunctionBody\">AsyncFunctionBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform !&#160;<emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Perform ! <var>funcEnv</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-AsyncFunctionExpression\">AsyncFunctionExpression</a></emu-nt>.</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"AwaitExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AwaitExpression\">AwaitExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"ef22da1b\"><emu-t>await</emu-t><emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).\n      </li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-blockdeclarationinstantiation": {"num": "13.2.14", "title": "#sec-blockdeclarationinstantiation Runtime Semantics: BlockDeclarationInstantiation ( code, env )", "html": "<emu-clause id=\"sec-blockdeclarationinstantiation\" aoid=\"BlockDeclarationInstantiation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-blockdeclarationinstantiation\">#sec-blockdeclarationinstantiation</span> Runtime Semantics: BlockDeclarationInstantiation ( <var>code</var>, <var>env</var> )</h1>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>When a <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt> or <emu-nt><a href=\"#prod-CaseBlock\">CaseBlock</a></emu-nt> is evaluated a new declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is created and bindings for each block scoped variable, constant, function, or class declared in the block are instantiated in the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</p>\n      </div></emu-note>\n      <p>The abstract operation BlockDeclarationInstantiation takes arguments <var>code</var> (a <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref>) and <var>env</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). <var>code</var> is the <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> corresponding to the body of the block. <var>env</var> is the <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref> in which bindings are to be created. It performs the following steps when called:</p>\n      <!--\n        WARNING: If you add, remove, rename, or repurpose any variable names\n                 within this algorithm, you may need to update\n                 #sec-web-compat-blockdeclarationinstantiation accordingly.\n      -->\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>env</var> is a declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Let <var>declarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>declarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li><li>If <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, then<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>d</var> with argument <var>env</var>.</li><li>Perform <var>env</var>.InitializeBinding(<var>fn</var>, <var>fo</var>).\n      </li></ol></li></ol></li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-ecmascript-function-objects-construct-argumentslist-newtarget": {"num": "9.2.2", "title": "#sec-ecmascript-function-objects-construct-argumentslist-newtarget [[Construct]] ( argumentsList, newTarget )", "html": "<emu-clause id=\"sec-ecmascript-function-objects-construct-argumentslist-newtarget\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-function-objects-construct-argumentslist-newtarget\">#sec-ecmascript-function-objects-construct-argumentslist-newtarget</span> [[Construct]] ( <var>argumentsList</var>, <var>newTarget</var> )</h1>\n      <p>The [[Construct]] internal method for an ECMAScript <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> <var>F</var> is called with parameters <var>argumentsList</var> and <var>newTarget</var>. <var>argumentsList</var> is a possibly empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of ECMAScript language values. The following steps are taken:</p>\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>F</var> is an ECMAScript <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>newTarget</var>) is Object.</li><li>Let <var>callerContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>kind</var> be <var>F</var>.[[ConstructorKind]].</li><li>If <var>kind</var> is <emu-const>base</emu-const>, then<ol><li>Let <var>thisArgument</var> be ?&#160;<emu-xref aoid=\"OrdinaryCreateFromConstructor\"><a href=\"#sec-ordinarycreatefromconstructor\">OrdinaryCreateFromConstructor</a></emu-xref>(<var>newTarget</var>, <emu-val>\"%Object.prototype%\"</emu-val>).</li></ol></li><li>Let <var>calleeContext</var> be <emu-xref aoid=\"PrepareForOrdinaryCall\"><a href=\"#sec-prepareforordinarycall\">PrepareForOrdinaryCall</a></emu-xref>(<var>F</var>, <var>newTarget</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>calleeContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>kind</var> is <emu-const>base</emu-const>, perform <emu-xref aoid=\"OrdinaryCallBindThis\"><a href=\"#sec-ordinarycallbindthis\">OrdinaryCallBindThis</a></emu-xref>(<var>F</var>, <var>calleeContext</var>, <var>thisArgument</var>).</li><li>Let <var>constructorEnv</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>Let <var>result</var> be <emu-xref aoid=\"OrdinaryCallEvaluateBody\"><a href=\"#sec-ordinarycallevaluatebody\">OrdinaryCallEvaluateBody</a></emu-xref>(<var>F</var>, <var>argumentsList</var>).</li><li>Remove <var>calleeContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore <var>callerContext</var> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>result</var>.[[Value]]) is Object, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>result</var>.[[Value]]).</li><li>If <var>kind</var> is <emu-const>base</emu-const>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>thisArgument</var>).</li><li>If <var>result</var>.[[Value]] is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Else, <emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li><li>Return ? <var>constructorEnv</var>.GetThisBinding().\n      </li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-for-statement-runtime-semantics-labelledevaluation": {"num": "13.7.4.7", "title": "#sec-for-statement-runtime-semantics-labelledevaluation Runtime Semantics: LabelledEvaluation", "html": "<emu-clause id=\"sec-for-statement-runtime-semantics-labelledevaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-for-statement-runtime-semantics-labelledevaluation\">#sec-for-statement-runtime-semantics-labelledevaluation</span> Runtime Semantics: LabelledEvaluation</h1>\n        <p>With parameter <var>labelSet</var>.</p>\n        <emu-see-also-para op=\"LabelledEvaluation\"></emu-see-also-para>\n        <emu-grammar><emu-production name=\"IterationStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-IterationStatement\">IterationStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"fc33bcf0\"><emu-t>for</emu-t><emu-t>(</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>If the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt> is present, then<ol><li>Let <var>exprRef</var> be the result of evaluating the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>.</li><li>Perform ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"ForBodyEvaluation\"><a href=\"#sec-forbodyevaluation\">ForBodyEvaluation</a></emu-xref>(the second <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, the third <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, &#171; &#187;, <var>labelSet</var>).\n        </li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"IterationStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-IterationStatement\">IterationStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"48e766b4\"><emu-t>for</emu-t><emu-t>(</emu-t><emu-t>var</emu-t><emu-nt><a href=\"#prod-VariableDeclarationList\">VariableDeclarationList</a></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>varDcl</var> be the result of evaluating <emu-nt><a href=\"#prod-VariableDeclarationList\">VariableDeclarationList</a></emu-nt>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>varDcl</var>).</li><li>Return ?&#160;<emu-xref aoid=\"ForBodyEvaluation\"><a href=\"#sec-forbodyevaluation\">ForBodyEvaluation</a></emu-xref>(the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, the second <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, &#171; &#187;, <var>labelSet</var>).\n        </li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"IterationStatement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-IterationStatement\">IterationStatement</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"93c07e45\"><emu-t>for</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>;</emu-t><emu-nt optional=\"\"><a href=\"#prod-Expression\">Expression</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>loopEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>Let <var>isConst</var> be IsConstantDeclaration of <emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt>.</li><li>Let <var>boundNames</var> be the BoundNames of <emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt>.</li><li>For each element <var>dn</var> of <var>boundNames</var>, do<ol><li>If <var>isConst</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>loopEnv</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>loopEnv</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>loopEnv</var>.</li><li>Let <var>forDcl</var> be the result of evaluating <emu-nt><a href=\"#prod-LexicalDeclaration\">LexicalDeclaration</a></emu-nt>.</li><li>If <var>forDcl</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>forDcl</var>).</li></ol></li><li>If <var>isConst</var> is <emu-val>false</emu-val>, let <var>perIterationLets</var> be <var>boundNames</var>; otherwise let <var>perIterationLets</var> be &#171; &#187;.</li><li>Let <var>bodyResult</var> be <emu-xref aoid=\"ForBodyEvaluation\"><a href=\"#sec-forbodyevaluation\">ForBodyEvaluation</a></emu-xref>(the first <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, the second <emu-nt><a href=\"#prod-Expression\">Expression</a></emu-nt>, <emu-nt><a href=\"#prod-Statement\">Statement</a></emu-nt>, <var>perIterationLets</var>, <var>labelSet</var>).</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>bodyResult</var>).\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-ordinarycallbindthis": {"num": "9.2.1.2", "title": "#sec-ordinarycallbindthis OrdinaryCallBindThis ( F, calleeContext, thisArgument )", "html": "<emu-clause id=\"sec-ordinarycallbindthis\" aoid=\"OrdinaryCallBindThis\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ordinarycallbindthis\">#sec-ordinarycallbindthis</span> OrdinaryCallBindThis ( <var>F</var>, <var>calleeContext</var>, <var>thisArgument</var> )</h1>\n        <p>The abstract operation OrdinaryCallBindThis takes arguments <var>F</var> (a <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>), <var>calleeContext</var> (an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>), and <var>thisArgument</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>thisMode</var> be <var>F</var>.[[ThisMode]].</li><li>If <var>thisMode</var> is <emu-const>lexical</emu-const>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Let <var>calleeRealm</var> be <var>F</var>.[[Realm]].</li><li>Let <var>localEnv</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>If <var>thisMode</var> is <emu-const>strict</emu-const>, let <var>thisValue</var> be <var>thisArgument</var>.</li><li>Else,<ol><li>If <var>thisArgument</var> is <emu-val>undefined</emu-val> or <emu-val>null</emu-val>, then<ol><li>Let <var>globalEnv</var> be <var>calleeRealm</var>.[[GlobalEnv]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>globalEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Let <var>thisValue</var> be <var>globalEnv</var>.[[GlobalThisValue]].</li></ol></li><li>Else,<ol><li>Let <var>thisValue</var> be !&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>thisArgument</var>).</li><li>NOTE: <emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref> produces wrapper objects using <var>calleeRealm</var>.</li></ol></li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>localEnv</var> is a <emu-xref href=\"#sec-function-environment-records\"><a href=\"#sec-function-environment-records\">function Environment Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The next step never returns an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> because <var>localEnv</var>.[[ThisBindingStatus]] is not <emu-const>initialized</emu-const>.</li><li>Return <var>localEnv</var>.BindThisValue(<var>thisValue</var>).\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-web-compat-evaldeclarationinstantiation": {"num": "B.3.3.3", "title": "#sec-web-compat-evaldeclarationinstantiation Changes to EvalDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-evaldeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-evaldeclarationinstantiation\">#sec-web-compat-evaldeclarationinstantiation</span> Changes to EvalDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"EvalDeclarationInstantiation\"><a href=\"#sec-evaldeclarationinstantiation\">EvalDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 7:</p>\n        <emu-alg><ol><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>declaredFunctionOrVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredFunctionNames</var>.</li><li>Append to <var>declaredFunctionOrVarNames</var> the elements of <var>declaredVarNames</var>.</li><li>For each <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> that is directly contained in the <emu-nt><a href=\"#prod-StatementList\">StatementList</a></emu-nt> of a <emu-nt><a href=\"#prod-annexB-Block\">Block</a></emu-nt>, <emu-nt><a href=\"#prod-CaseClause\">CaseClause</a></emu-nt>, or <emu-nt><a href=\"#prod-DefaultClause\">DefaultClause</a></emu-nt> Contained within <var>body</var>, do<ol><li>Let <var>F</var> be StringValue of the <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> of <var>f</var>.</li><li>If replacing the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> with a <emu-nt><a href=\"#prod-VariableStatement\">VariableStatement</a></emu-nt> that has <var>F</var> as a <emu-nt><a href=\"#prod-annexB-BindingIdentifier\">BindingIdentifier</a></emu-nt> would not produce any Early Errors for <var>body</var>, then<ol><li>Let <var>bindingExists</var> be <emu-val>false</emu-val>.</li><li>Let <var>thisLex</var> be <var>lexEnv</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The following loop will terminate.</li><li>Repeat, while <var>thisLex</var> is not the same as <var>varEnv</var>,<ol><li>If <var>thisLex</var> is not an object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>If <var>thisLex</var>.HasBinding(<var>F</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>bindingExists</var> be <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Set <var>thisLex</var> to <var>thisLex</var>.[[OuterEnv]].</li></ol></li><li>If <var>bindingExists</var> is <emu-val>false</emu-val> and <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>If <var>varEnv</var>.HasLexicalDeclaration(<var>F</var>) is <emu-val>false</emu-val>, then<ol><li>Let <var>fnDefinable</var> be ? <var>varEnv</var>.CanDeclareGlobalVar(<var>F</var>).</li></ol></li><li>Else,<ol><li>Let <var>fnDefinable</var> be <emu-val>false</emu-val>.</li></ol></li></ol></li><li>Else,<ol><li>Let <var>fnDefinable</var> be <emu-val>true</emu-val>.</li></ol></li><li>If <var>bindingExists</var> is <emu-val>false</emu-val> and <var>fnDefinable</var> is <emu-val>true</emu-val>, then<ol><li>If <var>declaredFunctionOrVarNames</var> does not contain <var>F</var>, then<ol><li>If <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Perform ? <var>varEnv</var>.CreateGlobalVarBinding(<var>F</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>bindingExists</var> be <var>varEnv</var>.HasBinding(<var>F</var>).</li><li>If <var>bindingExists</var> is <emu-val>false</emu-val>, then<ol><li>Perform ! <var>varEnv</var>.CreateMutableBinding(<var>F</var>, <emu-val>true</emu-val>).</li><li>Perform ! <var>varEnv</var>.InitializeBinding(<var>F</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li><li>Append <var>F</var> to <var>declaredFunctionOrVarNames</var>.</li></ol></li><li>When the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> <var>f</var> is evaluated, perform the following steps in place of the <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt> Evaluation algorithm provided in <emu-xref href=\"#sec-function-definitions-runtime-semantics-evaluation\"><a href=\"#sec-function-definitions-runtime-semantics-evaluation\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-evaluation\">#sec-function-definitions-runtime-semantics-evaluation</a></emu-xref>:<ol><li>Let <var>genv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s VariableEnvironment.</li><li>Let <var>benv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>fobj</var> be ! <var>benv</var>.GetBindingValue(<var>F</var>, <emu-val>false</emu-val>).</li><li>Perform ? <var>genv</var>.SetMutableBinding(<var>F</var>, <var>fobj</var>, <emu-val>false</emu-val>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n      </emu-annex>\n      "}, "sec-newmoduleenvironment": {"num": "8.1.2.6", "title": "#sec-newmoduleenvironment NewModuleEnvironment ( E )", "html": "<emu-clause id=\"sec-newmoduleenvironment\" aoid=\"NewModuleEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newmoduleenvironment\">#sec-newmoduleenvironment</span> NewModuleEnvironment ( <var>E</var> )</h1>\n        <p>The abstract operation NewModuleEnvironment takes argument <var>E</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new module <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing no bindings.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>E</var>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-web-compat-blockdeclarationinstantiation": {"num": "B.3.3.6", "title": "#sec-web-compat-blockdeclarationinstantiation Changes to BlockDeclarationInstantiation", "html": "<emu-annex id=\"sec-web-compat-blockdeclarationinstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-web-compat-blockdeclarationinstantiation\">#sec-web-compat-blockdeclarationinstantiation</span> Changes to BlockDeclarationInstantiation</h1>\n        <p>During <emu-xref aoid=\"BlockDeclarationInstantiation\"><a href=\"#sec-blockdeclarationinstantiation\">BlockDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 3.a.ii.1:</p>\n        <emu-alg><ol><li>If <var>env</var>.HasBinding(<var>dn</var>) is <emu-val>false</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).\n        </li></ol></li></ol></emu-alg>\n        <p>During <emu-xref aoid=\"BlockDeclarationInstantiation\"><a href=\"#sec-blockdeclarationinstantiation\">BlockDeclarationInstantiation</a></emu-xref> the following steps are performed in place of step 3.b.iii:</p>\n        <emu-alg><ol><li>If the binding for <var>fn</var> in <var>env</var> is an uninitialized binding, then<ol><li>Perform <var>env</var>.InitializeBinding(<var>fn</var>, <var>fo</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>.</li><li>Perform <var>env</var>.SetMutableBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).\n        </li></ol></li></ol></emu-alg>\n      </emu-annex>\n    "}, "sec-runtime-semantics-forinofheadevaluation": {"num": "13.7.5.12", "title": "#sec-runtime-semantics-forinofheadevaluation Runtime Semantics: ForIn/OfHeadEvaluation ( uninitializedBoundNames, expr, iterationKind )", "html": "<emu-clause id=\"sec-runtime-semantics-forinofheadevaluation\" oldids=\"sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind\" aoid=\"ForIn/OfHeadEvaluation\">\n        <span id=\"sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-forinofheadevaluation\">#sec-runtime-semantics-forinofheadevaluation</span> Runtime Semantics: ForIn/OfHeadEvaluation ( <var>uninitializedBoundNames</var>, <var>expr</var>, <var>iterationKind</var> )</h1>\n        <p>The abstract operation ForIn/OfHeadEvaluation takes arguments <var>uninitializedBoundNames</var>, <var>expr</var>, and <var>iterationKind</var> (either <emu-const>enumerate</emu-const>, <emu-const>iterate</emu-const>, or <emu-const>async-iterate</emu-const>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>If <var>uninitializedBoundNames</var> is not an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>uninitializedBoundNames</var> has no duplicate entries.</li><li>Let <var>newEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>For each string <var>name</var> in <var>uninitializedBoundNames</var>, do<ol><li>Perform ! <var>newEnv</var>.CreateMutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>newEnv</var>.</li></ol></li><li>Let <var>exprRef</var> be the result of evaluating <var>expr</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Let <var>exprValue</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>If <var>iterationKind</var> is <emu-const>enumerate</emu-const>, then<ol><li>If <var>exprValue</var> is <emu-val>undefined</emu-val> or <emu-val>null</emu-val>, then<ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>break</emu-const>, [[Value]]: <emu-const>empty</emu-const>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>exprValue</var>).</li><li>Return ?&#160;<emu-xref aoid=\"EnumerateObjectProperties\"><a href=\"#sec-enumerate-object-properties\">EnumerateObjectProperties</a></emu-xref>(<var>obj</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iterationKind</var> is <emu-const>iterate</emu-const> or <emu-const>async-iterate</emu-const>.</li><li>If <var>iterationKind</var> is <emu-const>async-iterate</emu-const>, let <var>iteratorHint</var> be <emu-const>async</emu-const>.</li><li>Else, let <var>iteratorHint</var> be <emu-const>sync</emu-const>.</li><li>Return ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>exprValue</var>, <var>iteratorHint</var>).\n        </li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-module-namespace-exotic-objects-get-p-receiver": {"num": "9.4.6.7", "title": "#sec-module-namespace-exotic-objects-get-p-receiver [[Get]] ( P, Receiver )", "html": "<emu-clause id=\"sec-module-namespace-exotic-objects-get-p-receiver\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-module-namespace-exotic-objects-get-p-receiver\">#sec-module-namespace-exotic-objects-get-p-receiver</span> [[Get]] ( <var>P</var>, <var>Receiver</var> )</h1>\n        <p>When the [[Get]] internal method of a <emu-xref href=\"#module-namespace-exotic-object\"><a href=\"#module-namespace-exotic-object\">module namespace exotic object</a></emu-xref> <var>O</var> is called with property key <var>P</var> and <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref> <var>Receiver</var>, the following steps are taken:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsPropertyKey\"><a href=\"#sec-ispropertykey\">IsPropertyKey</a></emu-xref>(<var>P</var>) is <emu-val>true</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>P</var>) is Symbol, then<ol><li>Return ?&#160;<emu-xref aoid=\"OrdinaryGet\"><a href=\"#sec-ordinaryget\">OrdinaryGet</a></emu-xref>(<var>O</var>, <var>P</var>, <var>Receiver</var>).</li></ol></li><li>Let <var>exports</var> be <var>O</var>.[[Exports]].</li><li>If <var>P</var> is not an element of <var>exports</var>, return <emu-val>undefined</emu-val>.</li><li>Let <var>m</var> be <var>O</var>.[[Module]].</li><li>Let <var>binding</var> be ! <var>m</var>.ResolveExport(<var>P</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>binding</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>.</li><li>Let <var>targetModule</var> be <var>binding</var>.[[Module]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>targetModule</var> is not <emu-val>undefined</emu-val>.</li><li>If <var>binding</var>.[[BindingName]] is <emu-val>\"*namespace*\"</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>targetModule</var>).</li></ol></li><li>Let <var>targetEnv</var> be <var>targetModule</var>.[[Environment]].</li><li>If <var>targetEnv</var> is <emu-val>undefined</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Return ? <var>targetEnv</var>.GetBindingValue(<var>binding</var>.[[BindingName]], <emu-val>true</emu-val>).\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>ResolveExport is side-effect free. Each time this operation is called with a specific <var>exportName</var>, <var>resolveSet</var> pair as arguments it must return the same result. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each <emu-xref href=\"#module-namespace-exotic-object\"><a href=\"#module-namespace-exotic-object\">module namespace exotic object</a></emu-xref>.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-evaldeclarationinstantiation": {"num": "18.2.1.3", "title": "#sec-evaldeclarationinstantiation Runtime Semantics: EvalDeclarationInstantiation ( body, varEnv, lexEnv, strict )", "html": "<emu-clause id=\"sec-evaldeclarationinstantiation\" aoid=\"EvalDeclarationInstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-evaldeclarationinstantiation\">#sec-evaldeclarationinstantiation</span> Runtime Semantics: EvalDeclarationInstantiation ( <var>body</var>, <var>varEnv</var>, <var>lexEnv</var>, <var>strict</var> )</h1>\n        <p>The abstract operation EvalDeclarationInstantiation takes arguments <var>body</var>, <var>varEnv</var>, <var>lexEnv</var>, and <var>strict</var>. It performs the following steps when called:</p>\n        <!--\n          WARNING: If you add, remove, rename, or repurpose any variable names\n                   within this algorithm, you may need to update\n                   #sec-web-compat-evaldeclarationinstantiation and\n                   #sec-variablestatements-in-catch-blocks accordingly.\n        -->\n        <emu-alg><ol><li>Let <var>varNames</var> be the VarDeclaredNames of <var>body</var>.</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>body</var>.</li><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>If <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>For each <var>name</var> in <var>varNames</var>, do<ol><li>If <var>varEnv</var>.HasLexicalDeclaration(<var>name</var>) is <emu-val>true</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>NOTE: <code>eval</code> will not create a global var declaration that would be shadowed by a global lexical declaration.</li></ol></li></ol></li><li>Let <var>thisLex</var> be <var>lexEnv</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The following loop will terminate.</li><li>Repeat, while <var>thisLex</var> is not the same as <var>varEnv</var>,<ol><li>If <var>thisLex</var> is not an object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.</li><li>For each <var>name</var> in <var>varNames</var>, do<ol><li>If <var>thisLex</var>.HasBinding(<var>name</var>) is <emu-val>true</emu-val>, then<ol><li>Throw a <emu-val>SyntaxError</emu-val> exception.</li><li>NOTE: Annex <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"><a href=\"#sec-variablestatements-in-catch-blocks\" class=\"excluded-xref\" excluded-id=\"sec-variablestatements-in-catch-blocks\">#sec-variablestatements-in-catch-blocks</a></emu-xref> defines alternate semantics for the above step.</li></ol></li><li>NOTE: A <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> will not hoist var declaration over a like-named lexical declaration.</li></ol></li></ol></li><li>Set <var>thisLex</var> to <var>thisLex</var>.[[OuterEnv]].</li></ol></li></ol></li><li>Let <var>functionsToInitialize</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>declaredFunctionNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, in reverse list order, do<ol><li>If <var>d</var> is neither a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt> nor a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt> nor a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is either a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>.</li><li>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</li><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>If <var>fn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>If <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Let <var>fnDefinable</var> be ? <var>varEnv</var>.CanDeclareGlobalFunction(<var>fn</var>).</li><li>If <var>fnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Append <var>fn</var> to <var>declaredFunctionNames</var>.</li><li>Insert <var>d</var> as the first element of <var>functionsToInitialize</var>.</li></ol></li></ol></li></ol></li><li>NOTE: Annex <emu-xref href=\"#sec-web-compat-evaldeclarationinstantiation\"><a href=\"#sec-web-compat-evaldeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-web-compat-evaldeclarationinstantiation\">#sec-web-compat-evaldeclarationinstantiation</a></emu-xref> adds additional steps at this point.</li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, do<ol><li>If <var>d</var> is a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>, or a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li>For each String <var>vn</var> in the BoundNames of <var>d</var>, do<ol><li>If <var>vn</var> is not an element of <var>declaredFunctionNames</var>, then<ol><li>If <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Let <var>vnDefinable</var> be ? <var>varEnv</var>.CanDeclareGlobalVar(<var>vn</var>).</li><li>If <var>vnDefinable</var> is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>If <var>vn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Append <var>vn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li></ol></li></ol></li><li>NOTE: No abnormal terminations occur after this algorithm step unless <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> and the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> is a <emu-xref href=\"#proxy-exotic-object\"><a href=\"#proxy-exotic-object\">Proxy exotic object</a></emu-xref>.</li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>body</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>NOTE: Lexically declared names are only instantiated here but not initialized.</li><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ? <var>lexEnv</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ? <var>lexEnv</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> <var>f</var> in <var>functionsToInitialize</var>, do<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>f</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>f</var> with argument <var>lexEnv</var>.</li><li>If <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Perform ? <var>varEnv</var>.CreateGlobalFunctionBinding(<var>fn</var>, <var>fo</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>bindingExists</var> be <var>varEnv</var>.HasBinding(<var>fn</var>).</li><li>If <var>bindingExists</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>status</var> be ! <var>varEnv</var>.CreateMutableBinding(<var>fn</var>, <emu-val>true</emu-val>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>status</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> because of validation preceding step 10.</li><li>Perform ! <var>varEnv</var>.InitializeBinding(<var>fn</var>, <var>fo</var>).</li></ol></li><li>Else,<ol><li>Perform ! <var>varEnv</var>.SetMutableBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each String <var>vn</var> in <var>declaredVarNames</var>, in list order, do<ol><li>If <var>varEnv</var> is a global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, then<ol><li>Perform ? <var>varEnv</var>.CreateGlobalVarBinding(<var>vn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>bindingExists</var> be <var>varEnv</var>.HasBinding(<var>vn</var>).</li><li>If <var>bindingExists</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>status</var> be ! <var>varEnv</var>.CreateMutableBinding(<var>vn</var>, <emu-val>true</emu-val>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>status</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> because of validation preceding step 10.</li><li>Perform ! <var>varEnv</var>.InitializeBinding(<var>vn</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>An alternative version of this algorithm is described in  <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"><a href=\"#sec-variablestatements-in-catch-blocks\" class=\"excluded-xref\" excluded-id=\"sec-variablestatements-in-catch-blocks\">#sec-variablestatements-in-catch-blocks</a></emu-xref>.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-newglobalenvironment": {"num": "8.1.2.5", "title": "#sec-newglobalenvironment NewGlobalEnvironment ( G, thisValue )", "html": "<emu-clause id=\"sec-newglobalenvironment\" aoid=\"NewGlobalEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newglobalenvironment\">#sec-newglobalenvironment</span> NewGlobalEnvironment ( <var>G</var>, <var>thisValue</var> )</h1>\n        <p>The abstract operation NewGlobalEnvironment takes arguments <var>G</var> and <var>thisValue</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>objRec</var> be a new object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing <var>G</var> as the binding object.</li><li>Let <var>dclRec</var> be a new declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing no bindings.</li><li>Let <var>env</var> be a new global <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Set <var>env</var>.[[ObjectRecord]] to <var>objRec</var>.</li><li>Set <var>env</var>.[[GlobalThisValue]] to <var>thisValue</var>.</li><li>Set <var>env</var>.[[DeclarativeRecord]] to <var>dclRec</var>.</li><li>Set <var>env</var>.[[VarNames]] to a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Set <var>env</var>.[[OuterEnv]] to <emu-val>null</emu-val>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-functiondeclarationinstantiation": {"num": "9.2.10", "title": "#sec-functiondeclarationinstantiation FunctionDeclarationInstantiation ( func, argumentsList )", "html": "<emu-clause id=\"sec-functiondeclarationinstantiation\" aoid=\"FunctionDeclarationInstantiation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-functiondeclarationinstantiation\">#sec-functiondeclarationinstantiation</span> FunctionDeclarationInstantiation ( <var>func</var>, <var>argumentsList</var> )</h1>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>When an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is established for evaluating an ECMAScript function a new <emu-xref href=\"#sec-function-environment-records\"><a href=\"#sec-function-environment-records\">function Environment Record</a></emu-xref> is created and bindings for each formal parameter are instantiated in that <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>. Each declaration in the function body is also instantiated. If the function's formal parameters do not include any default value initializers then the body declarations are instantiated in the same <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> as the parameters. If default value parameter initializers exist, a second <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is created for the body declarations. Formal parameters and functions are initialized as part of FunctionDeclarationInstantiation. All other bindings are initialized during evaluation of the function body.</p>\n      </div></emu-note>\n      <p>The abstract operation FunctionDeclarationInstantiation takes arguments <var>func</var> (a <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>) and <var>argumentsList</var>. <var>func</var> is the <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> for which the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> is being established. It performs the following steps when called:</p>\n      <!--\n        WARNING: If you add, remove, rename, or repurpose any variable names\n                 within this algorithm, you may need to update\n                 #sec-web-compat-functiondeclarationinstantiation accordingly.\n      -->\n      <emu-alg><ol><li>Let <var>calleeContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>code</var> be <var>func</var>.[[ECMAScriptCode]].</li><li>Let <var>strict</var> be <var>func</var>.[[Strict]].</li><li>Let <var>formals</var> be <var>func</var>.[[FormalParameters]].</li><li>Let <var>parameterNames</var> be the BoundNames of <var>formals</var>.</li><li>If <var>parameterNames</var> has any duplicate entries, let <var>hasDuplicates</var> be <emu-val>true</emu-val>. Otherwise, let <var>hasDuplicates</var> be <emu-val>false</emu-val>.</li><li>Let <var>simpleParameterList</var> be IsSimpleParameterList of <var>formals</var>.</li><li>Let <var>hasParameterExpressions</var> be ContainsExpression of <var>formals</var>.</li><li>Let <var>varNames</var> be the VarDeclaredNames of <var>code</var>.</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>code</var>.</li><li>Let <var>lexicalNames</var> be the LexicallyDeclaredNames of <var>code</var>.</li><li>Let <var>functionNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>functionsToInitialize</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>d</var> in <var>varDeclarations</var>, in reverse list order, do<ol><li>If <var>d</var> is neither a <emu-nt><a href=\"#prod-VariableDeclaration\">VariableDeclaration</a></emu-nt> nor a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt> nor a <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>d</var> is either a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>.</li><li>Let <var>fn</var> be the sole element of the BoundNames of <var>d</var>.</li><li>If <var>fn</var> is not an element of <var>functionNames</var>, then<ol><li>Insert <var>fn</var> as the first element of <var>functionNames</var>.</li><li>NOTE: If there are multiple function declarations for the same name, the last declaration is used.</li><li>Insert <var>d</var> as the first element of <var>functionsToInitialize</var>.</li></ol></li></ol></li></ol></li><li>Let <var>argumentsObjectNeeded</var> be <emu-val>true</emu-val>.</li><li>If <var>func</var>.[[ThisMode]] is <emu-const>lexical</emu-const>, then<ol><li>NOTE: Arrow functions never have an arguments objects.</li><li>Set <var>argumentsObjectNeeded</var> to <emu-val>false</emu-val>.</li></ol></li><li>Else if <emu-val>\"arguments\"</emu-val> is an element of <var>parameterNames</var>, then<ol><li>Set <var>argumentsObjectNeeded</var> to <emu-val>false</emu-val>.</li></ol></li><li>Else if <var>hasParameterExpressions</var> is <emu-val>false</emu-val>, then<ol><li>If <emu-val>\"arguments\"</emu-val> is an element of <var>functionNames</var> or if <emu-val>\"arguments\"</emu-val> is an element of <var>lexicalNames</var>, then<ol><li>Set <var>argumentsObjectNeeded</var> to <emu-val>false</emu-val>.</li></ol></li></ol></li><li>If <var>strict</var> is <emu-val>true</emu-val> or if <var>hasParameterExpressions</var> is <emu-val>false</emu-val>, then<ol><li>NOTE: Only a single lexical environment is needed for the parameters and top-level vars.</li><li>Let <var>env</var> be the LexicalEnvironment of <var>calleeContext</var>.</li></ol></li><li>Else,<ol><li>NOTE: A separate <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is needed to ensure that bindings created by <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> calls in the formal parameter list are outside the environment where parameters are declared.</li><li>Let <var>calleeEnv</var> be the LexicalEnvironment of <var>calleeContext</var>.</li><li>Let <var>env</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>calleeEnv</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The VariableEnvironment of <var>calleeContext</var> is <var>calleeEnv</var>.</li><li>Set the LexicalEnvironment of <var>calleeContext</var> to <var>env</var>.</li></ol></li><li>For each String <var>paramName</var> in <var>parameterNames</var>, do<ol><li>Let <var>alreadyDeclared</var> be <var>env</var>.HasBinding(<var>paramName</var>).</li><li>NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.</li><li>If <var>alreadyDeclared</var> is <emu-val>false</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>paramName</var>, <emu-val>false</emu-val>).</li><li>If <var>hasDuplicates</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>env</var>.InitializeBinding(<var>paramName</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li></ol></li><li>If <var>argumentsObjectNeeded</var> is <emu-val>true</emu-val>, then<ol><li>If <var>strict</var> is <emu-val>true</emu-val> or if <var>simpleParameterList</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>ao</var> be <emu-xref aoid=\"CreateUnmappedArgumentsObject\"><a href=\"#sec-createunmappedargumentsobject\">CreateUnmappedArgumentsObject</a></emu-xref>(<var>argumentsList</var>).</li></ol></li><li>Else,<ol><li>NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.</li><li>Let <var>ao</var> be <emu-xref aoid=\"CreateMappedArgumentsObject\"><a href=\"#sec-createmappedargumentsobject\">CreateMappedArgumentsObject</a></emu-xref>(<var>func</var>, <var>formals</var>, <var>argumentsList</var>, <var>env</var>).</li></ol></li><li>If <var>strict</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateImmutableBinding(<emu-val>\"arguments\"</emu-val>, <emu-val>false</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<emu-val>\"arguments\"</emu-val>, <emu-val>false</emu-val>).</li></ol></li><li>Call <var>env</var>.InitializeBinding(<emu-val>\"arguments\"</emu-val>, <var>ao</var>).</li><li>Let <var>parameterBindings</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>parameterNames</var> with <emu-val>\"arguments\"</emu-val> appended.</li></ol></li><li>Else,<ol><li>Let <var>parameterBindings</var> be <var>parameterNames</var>.</li></ol></li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"CreateListIteratorRecord\"><a href=\"#sec-createlistiteratorRecord\">CreateListIteratorRecord</a></emu-xref>(<var>argumentsList</var>).</li><li>If <var>hasDuplicates</var> is <emu-val>true</emu-val>, then<ol><li>Perform ? IteratorBindingInitialization for <var>formals</var> with <var>iteratorRecord</var> and <emu-val>undefined</emu-val> as arguments.</li></ol></li><li>Else,<ol><li>Perform ? IteratorBindingInitialization for <var>formals</var> with <var>iteratorRecord</var> and <var>env</var> as arguments.</li></ol></li><li>If <var>hasParameterExpressions</var> is <emu-val>false</emu-val>, then<ol><li>NOTE: Only a single lexical environment is needed for the parameters and top-level vars.</li><li>Let <var>instantiatedVarNames</var> be a copy of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> <var>parameterBindings</var>.</li><li>For each <var>n</var> in <var>varNames</var>, do<ol><li>If <var>n</var> is not an element of <var>instantiatedVarNames</var>, then<ol><li>Append <var>n</var> to <var>instantiatedVarNames</var>.</li><li>Perform ! <var>env</var>.CreateMutableBinding(<var>n</var>, <emu-val>false</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>n</var>, <emu-val>undefined</emu-val>).</li></ol></li></ol></li><li>Let <var>varEnv</var> be <var>env</var>.</li></ol></li><li>Else,<ol><li>NOTE: A separate <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.</li><li>Let <var>varEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>env</var>).</li><li>Set the VariableEnvironment of <var>calleeContext</var> to <var>varEnv</var>.</li><li>Let <var>instantiatedVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>n</var> in <var>varNames</var>, do<ol><li>If <var>n</var> is not an element of <var>instantiatedVarNames</var>, then<ol><li>Append <var>n</var> to <var>instantiatedVarNames</var>.</li><li>Perform ! <var>varEnv</var>.CreateMutableBinding(<var>n</var>, <emu-val>false</emu-val>).</li><li>If <var>n</var> is not an element of <var>parameterBindings</var> or if <var>n</var> is an element of <var>functionNames</var>, let <var>initialValue</var> be <emu-val>undefined</emu-val>.</li><li>Else,<ol><li>Let <var>initialValue</var> be ! <var>env</var>.GetBindingValue(<var>n</var>, <emu-val>false</emu-val>).</li></ol></li><li>Call <var>varEnv</var>.InitializeBinding(<var>n</var>, <var>initialValue</var>).</li><li>NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.</li></ol></li></ol></li></ol></li><li>NOTE: Annex <emu-xref href=\"#sec-web-compat-functiondeclarationinstantiation\"><a href=\"#sec-web-compat-functiondeclarationinstantiation\" class=\"excluded-xref\" excluded-id=\"sec-web-compat-functiondeclarationinstantiation\">#sec-web-compat-functiondeclarationinstantiation</a></emu-xref> adds additional steps at this point.</li><li>If <var>strict</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>lexEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>varEnv</var>).</li><li>NOTE: Non-strict functions use a separate lexical <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for top-level lexical declarations so that a <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> always places all declarations into a new <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li></ol></li><li>Else, let <var>lexEnv</var> be <var>varEnv</var>.</li><li>Set the LexicalEnvironment of <var>calleeContext</var> to <var>lexEnv</var>.</li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.</li><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>lexEnv</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>lexEnv</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li></ol></li></ol></li><li>For each <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref> <var>f</var> in <var>functionsToInitialize</var>, do<ol><li>Let <var>fn</var> be the sole element of the BoundNames of <var>f</var>.</li><li>Let <var>fo</var> be InstantiateFunctionObject of <var>f</var> with argument <var>lexEnv</var>.</li><li>Perform ! <var>varEnv</var>.SetMutableBinding(<var>fn</var>, <var>fo</var>, <emu-val>false</emu-val>).</li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p><emu-xref href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\"><a href=\"#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" class=\"excluded-xref\" excluded-id=\"sec-block-level-function-declarations-web-legacy-compatibility-semantics\">#sec-block-level-function-declarations-web-legacy-compatibility-semantics</a></emu-xref> provides an extension to the above algorithm that is necessary for backwards compatibility with web browser implementations of ECMAScript that predate ECMAScript 2015.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n        <p>Parameter <emu-nt><a href=\"#prod-Initializer\">Initializer</a></emu-nt>s may contain <emu-xref href=\"#sec-function-calls-runtime-semantics-evaluation\"><a href=\"#sec-function-calls-runtime-semantics-evaluation\">direct eval</a></emu-xref> expressions. Any top level declarations of such evals are only visible to the eval code (<emu-xref href=\"#sec-types-of-source-code\"><a href=\"#sec-types-of-source-code\" class=\"excluded-xref\" excluded-id=\"sec-types-of-source-code\">#sec-types-of-source-code</a></emu-xref>). The creation of the environment for such declarations is described in  <emu-xref href=\"#sec-function-definitions-runtime-semantics-iteratorbindinginitialization\"><a href=\"#sec-function-definitions-runtime-semantics-iteratorbindinginitialization\" class=\"excluded-xref\" excluded-id=\"sec-function-definitions-runtime-semantics-iteratorbindinginitialization\">#sec-function-definitions-runtime-semantics-iteratorbindinginitialization</a></emu-xref>.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-newdeclarativeenvironment": {"num": "8.1.2.2", "title": "#sec-newdeclarativeenvironment NewDeclarativeEnvironment ( E )", "html": "<emu-clause id=\"sec-newdeclarativeenvironment\" aoid=\"NewDeclarativeEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newdeclarativeenvironment\">#sec-newdeclarativeenvironment</span> NewDeclarativeEnvironment ( <var>E</var> )</h1>\n        <p>The abstract operation NewDeclarativeEnvironment takes argument <var>E</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing no bindings.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>E</var>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-newobjectenvironment": {"num": "8.1.2.3", "title": "#sec-newobjectenvironment NewObjectEnvironment ( O, E )", "html": "<emu-clause id=\"sec-newobjectenvironment\" aoid=\"NewObjectEnvironment\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newobjectenvironment\">#sec-newobjectenvironment</span> NewObjectEnvironment ( <var>O</var>, <var>E</var> )</h1>\n        <p>The abstract operation NewObjectEnvironment takes arguments <var>O</var> (an Object) and <var>E</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>env</var> be a new object <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> containing <var>O</var> as the binding object.</li><li>Set <var>env</var>.[[OuterEnv]] to <var>E</var>.</li><li>Return <var>env</var>.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-generator-function-definitions-runtime-semantics-evaluation": {"num": "14.4.14", "title": "#sec-generator-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">#sec-generator-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"0d271960\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"7dbc99b6\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform <var>funcEnv</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>closure</var> be <emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-generatorfunction-prototype-object\"><a href=\"#sec-properties-of-the-generatorfunction-prototype-object\">%Generator%</a></emu-xref>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Let <var>prototype</var> be <emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%Generator.prototype%).</li><li>Perform <emu-xref aoid=\"DefinePropertyOrThrow\"><a href=\"#sec-definepropertyorthrow\">DefinePropertyOrThrow</a></emu-xref>(<var>closure</var>, <emu-val>\"prototype\"</emu-val>, PropertyDescriptor { [[Value]]: <var>prototype</var>, [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }).</li><li>Perform <var>funcEnv</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Set <var>closure</var>.[[SourceText]] to the <emu-xref href=\"#sec-algorithm-conventions-syntax-directed-operations\"><a href=\"#sec-algorithm-conventions-syntax-directed-operations\">source text matched by</a></emu-xref> <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</li><li>Return <var>closure</var>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt> to allow the generator code to call itself recursively. However, unlike in a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d1df3360\"><emu-t>yield</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<emu-val>undefined</emu-val>, <emu-val>false</emu-val>)).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e741ede8\"><emu-t>yield</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<var>value</var>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <emu-val>false</emu-val>)).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"47a33813\"><emu-t>yield</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>, <var>generatorKind</var>).</li><li>Let <var>iterator</var> be <var>iteratorRecord</var>.[[Iterator]].</li><li>Let <var>received</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Repeat,<ol><li>If <var>received</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>iteratorRecord</var>.[[NextMethod]], <var>iteratorRecord</var>.[[Iterator]], &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else if <var>received</var>.[[Type]] is <emu-const>throw</emu-const>, then<ol><li>Let <var>throw</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"throw\"</emu-val>).</li><li>If <var>throw</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>throw</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>NOTE: Exceptions from the inner iterator <code>throw</code> method are propagated. Normal completions from an inner <code>throw</code> method are processed similarly to an inner <code>next</code>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else,<ol><li>NOTE: If <var>iterator</var> does not have a <code>throw</code> method, this throw is going to terminate the <code>yield*</code> loop. But first we need to give <var>iterator</var> a chance to clean up.</li><li>Let <var>closeCompletion</var> be <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>normal</emu-const>, [[Value]]: <emu-const>empty</emu-const>, [[Target]]: <emu-const>empty</emu-const> }.</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, perform ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>Else, perform ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>NOTE: The next step throws a <emu-val>TypeError</emu-val> to indicate that there was a <code>yield*</code> protocol violation: <var>iterator</var> does not have a <code>throw</code> method.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>received</var>.[[Type]] is <emu-const>return</emu-const>.</li><li>Let <var>return</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"return\"</emu-val>).</li><li>If <var>return</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var>.[[Value]] to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>received</var>.[[Value]]).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>received</var>).</li></ol></li><li>Let <var>innerReturnResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>return</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerReturnResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerReturnResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>return</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerReturnResult</var>).\n      </li></ol></li></ol></li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-globalthis": {"num": "18.1.1", "title": "#sec-globalthis globalThis", "html": "<emu-clause id=\"sec-globalthis\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-globalthis\">#sec-globalthis</span> globalThis</h1>\n      <p>The initial value of the <emu-val>\"globalThis\"</emu-val> property of the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> in a <emu-xref href=\"#realm-record\"><a href=\"#realm-record\">Realm Record</a></emu-xref> <var>realm</var> is <var>realm</var>.[[GlobalEnv]].[[GlobalThisValue]].</p>\n      <p>This property has the attributes { [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>\n    </emu-clause>\n\n    "}, "sec-getthisenvironment": {"num": "8.3.3", "title": "#sec-getthisenvironment GetThisEnvironment ( )", "html": "<emu-clause id=\"sec-getthisenvironment\" aoid=\"GetThisEnvironment\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getthisenvironment\">#sec-getthisenvironment</span> GetThisEnvironment ( )</h1>\n      <p>The abstract operation GetThisEnvironment takes no arguments. It finds the <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> that currently supplies the binding of the <emu-xref href=\"#sec-keywords-and-reserved-words\"><a href=\"#sec-keywords-and-reserved-words\">keyword</a></emu-xref> <code>this</code>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>Let <var>lex</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Repeat,<ol><li>Let <var>exists</var> be <var>lex</var>.HasThisBinding().</li><li>If <var>exists</var> is <emu-val>true</emu-val>, return <var>lex</var>.</li><li>Let <var>outer</var> be <var>lex</var>.[[OuterEnv]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>outer</var> is not <emu-val>null</emu-val>.</li><li>Set <var>lex</var> to <var>outer</var>.\n      </li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The loop in step 2 will always terminate because the list of environments always ends with the <emu-xref href=\"#global-environment\"><a href=\"#global-environment\">global environment</a></emu-xref> which has a <code>this</code> binding.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-runtime-semantics-bindinginstantiation": {"num": "13.7.5.10", "title": "#sec-runtime-semantics-bindinginstantiation Runtime Semantics: BindingInstantiation", "html": "<emu-clause id=\"sec-runtime-semantics-bindinginstantiation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-bindinginstantiation\">#sec-runtime-semantics-bindinginstantiation</span> Runtime Semantics: BindingInstantiation</h1>\n        <p>With parameter <var>environment</var>.</p>\n        <emu-grammar><emu-production name=\"ForDeclaration\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ForDeclaration\">ForDeclaration</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d32d6fbc\"><emu-nt><a href=\"#prod-LetOrConst\">LetOrConst</a></emu-nt><emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>environment</var> is a declarative <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>For each element <var>name</var> of the BoundNames of <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>, do<ol><li>If IsConstantDeclaration of <emu-nt><a href=\"#prod-LetOrConst\">LetOrConst</a></emu-nt> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>environment</var>.CreateImmutableBinding(<var>name</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>environment</var>.CreateMutableBinding(<var>name</var>, <emu-val>false</emu-val>).\n        </li></ol></li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-module-environment-records-getbindingvalue-n-s": {"num": "8.1.1.5.1", "title": "#sec-module-environment-records-getbindingvalue-n-s GetBindingValue ( N, S )", "html": "<emu-clause id=\"sec-module-environment-records-getbindingvalue-n-s\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-module-environment-records-getbindingvalue-n-s\">#sec-module-environment-records-getbindingvalue-n-s</span> GetBindingValue ( <var>N</var>, <var>S</var> )</h1>\n          <p>The concrete <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> method GetBindingValue for module Environment Records returns the value of its bound identifier whose name is the value of the argument <var>N</var>. However, if the binding is an indirect binding the value of the target binding is returned. If the binding exists but is uninitialized a <emu-val>ReferenceError</emu-val> is thrown.</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>S</var> is <emu-val>true</emu-val>.</li><li>Let <var>envRec</var> be the module <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref> for which the method was invoked.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>envRec</var> has a binding for <var>N</var>.</li><li>If the binding for <var>N</var> is an indirect binding, then<ol><li>Let <var>M</var> and <var>N2</var> be the indirection values provided when this binding for <var>N</var> was created.</li><li>Let <var>targetEnv</var> be <var>M</var>.[[Environment]].</li><li>If <var>targetEnv</var> is <emu-val>undefined</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Return ? <var>targetEnv</var>.GetBindingValue(<var>N2</var>, <emu-val>true</emu-val>).</li></ol></li><li>If the binding for <var>N</var> in <var>envRec</var> is an uninitialized binding, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Return the value currently bound to <var>N</var> in <var>envRec</var>.\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p><var>S</var> will always be <emu-val>true</emu-val> because a <emu-nt><a href=\"#prod-Module\">Module</a></emu-nt> is always <emu-xref href=\"#sec-strict-mode-code\"><a href=\"#sec-strict-mode-code\">strict mode code</a></emu-xref>.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-runtime-semantics-catchclauseevaluation": {"num": "13.15.7", "title": "#sec-runtime-semantics-catchclauseevaluation Runtime Semantics: CatchClauseEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-catchclauseevaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-catchclauseevaluation\">#sec-runtime-semantics-catchclauseevaluation</span> Runtime Semantics: CatchClauseEvaluation</h1>\n      <p>With parameter <var>thrownValue</var>.</p>\n      <emu-grammar><emu-production name=\"Catch\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Catch\">Catch</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"ddc13c36\"><emu-t>catch</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-CatchParameter\">CatchParameter</a></emu-nt><emu-t>)</emu-t><emu-nt><a href=\"#prod-Block\">Block</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>catchEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>For each element <var>argName</var> of the BoundNames of <emu-nt><a href=\"#prod-CatchParameter\">CatchParameter</a></emu-nt>, do<ol><li>Perform ! <var>catchEnv</var>.CreateMutableBinding(<var>argName</var>, <emu-val>false</emu-val>).</li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>catchEnv</var>.</li><li>Let <var>status</var> be BindingInitialization of <emu-nt><a href=\"#prod-CatchParameter\">CatchParameter</a></emu-nt> with arguments <var>thrownValue</var> and <var>catchEnv</var>.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>B</var> be the result of evaluating <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>B</var>).\n      </li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"Catch\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Catch\">Catch</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"a18a7645\"><emu-t>catch</emu-t><emu-nt><a href=\"#prod-Block\">Block</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of evaluating <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt>.\n      </li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>No matter how control leaves the <emu-nt><a href=\"#prod-Block\">Block</a></emu-nt> the LexicalEnvironment is always restored to its former state.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-getidentifierreference": {"num": "8.1.2.1", "title": "#sec-getidentifierreference GetIdentifierReference ( lex, name, strict )", "html": "<emu-clause id=\"sec-getidentifierreference\" aoid=\"GetIdentifierReference\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getidentifierreference\">#sec-getidentifierreference</span> GetIdentifierReference ( <var>lex</var>, <var>name</var>, <var>strict</var> )</h1>\n        <p>The abstract operation GetIdentifierReference takes arguments <var>lex</var> (a <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref> or <emu-val>null</emu-val>), <var>name</var> (a String), and <var>strict</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>lex</var> is the value <emu-val>null</emu-val>, then<ol><li>Return a value of type <emu-xref href=\"#sec-reference-specification-type\"><a href=\"#sec-reference-specification-type\">Reference</a></emu-xref> whose base value component is <emu-val>undefined</emu-val>, whose referenced name component is <var>name</var>, and whose strict reference flag is <var>strict</var>.</li></ol></li><li>Let <var>exists</var> be ? <var>lex</var>.HasBinding(<var>name</var>).</li><li>If <var>exists</var> is <emu-val>true</emu-val>, then<ol><li>Return a value of type <emu-xref href=\"#sec-reference-specification-type\"><a href=\"#sec-reference-specification-type\">Reference</a></emu-xref> whose base value component is <var>lex</var>, whose referenced name component is <var>name</var>, and whose strict reference flag is <var>strict</var>.</li></ol></li><li>Else,<ol><li>Let <var>outer</var> be <var>lex</var>.[[OuterEnv]].</li><li>Return ?&#160;<emu-xref aoid=\"GetIdentifierReference\"><a href=\"#sec-getidentifierreference\">GetIdentifierReference</a></emu-xref>(<var>outer</var>, <var>name</var>, <var>strict</var>).\n        </li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {}}}