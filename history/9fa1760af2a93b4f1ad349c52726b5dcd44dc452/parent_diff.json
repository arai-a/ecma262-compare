{"from": {"secList": ["sec-numeric-types-bigint-bitwiseXOR", "sec-abstract-operations-for-atomics", "sec-numeric-types-bigint-bitwiseOR", "sec-bytelistbitwiseop", "sec-numberbitwiseop", "sec-numeric-types-bigint-bitwiseAND", "sec-bigintbitwiseop"], "secData": {"sec-numeric-types-bigint-bitwiseXOR": {"num": "6.1.6.2.21", "title": "#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseXOR\">#sec-numeric-types-bigint-bitwiseXOR</span> BigInt::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseXOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"^\"</emu-val>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-abstract-operations-for-atomics": {"num": "24.4.1", "title": "#sec-abstract-operations-for-atomics Abstract Operations for Atomics", "html": "<emu-clause id=\"sec-abstract-operations-for-atomics\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-abstract-operations-for-atomics\">#sec-abstract-operations-for-atomics</span> Abstract Operations for Atomics</h1>\n\n      <div id=\"excluded-sec-validatesharedintegertypedarray\"><h1><span class=\"secnum\">24.4.1.1</span>#sec-validatesharedintegertypedarray ValidateSharedIntegerTypedArray ( typedArray [ , waitable ] )</h1>...</div><div id=\"excluded-sec-validateatomicaccess\"><h1><span class=\"secnum\">24.4.1.2</span>#sec-validateatomicaccess ValidateAtomicAccess ( typedArray, requestIndex )</h1>...</div><div id=\"excluded-sec-getwaiterlist\"><h1><span class=\"secnum\">24.4.1.3</span>#sec-getwaiterlist GetWaiterList ( block, i )</h1>...</div><div id=\"excluded-sec-entercriticalsection\"><h1><span class=\"secnum\">24.4.1.4</span>#sec-entercriticalsection EnterCriticalSection ( WL )</h1>...</div><div id=\"excluded-sec-leavecriticalsection\"><h1><span class=\"secnum\">24.4.1.5</span>#sec-leavecriticalsection LeaveCriticalSection ( WL )</h1>...</div><div id=\"excluded-sec-addwaiter\"><h1><span class=\"secnum\">24.4.1.6</span>#sec-addwaiter AddWaiter ( WL, W )</h1>...</div><div id=\"excluded-sec-removewaiter\"><h1><span class=\"secnum\">24.4.1.7</span>#sec-removewaiter RemoveWaiter ( WL, W )</h1>...</div><div id=\"excluded-sec-removewaiters\"><h1><span class=\"secnum\">24.4.1.8</span>#sec-removewaiters RemoveWaiters ( WL, c )</h1>...</div><div id=\"excluded-sec-suspend\"><h1><span class=\"secnum\">24.4.1.9</span>#sec-suspend Suspend ( WL, W, timeout )</h1>...</div><div id=\"excluded-sec-notifywaiter\"><h1><span class=\"secnum\">24.4.1.10</span>#sec-notifywaiter NotifyWaiter ( WL, W )</h1>...</div><div id=\"excluded-sec-atomicreadmodifywrite\"><h1><span class=\"secnum\">24.4.1.11</span>#sec-atomicreadmodifywrite AtomicReadModifyWrite ( typedArray, index, value, op )</h1>...</div><div id=\"excluded-sec-atomicload\"><h1><span class=\"secnum\">24.4.1.12</span>#sec-atomicload AtomicLoad ( typedArray, index )</h1>...</div><div id=\"excluded-sec-bytelistbitwiseop\"><h1><span class=\"secnum\">24.4.1.13</span>#sec-bytelistbitwiseop ByteListBitwiseOp( op, xBytes, yBytes )</h1>...</div><div id=\"excluded-sec-bytelistequal\"><h1><span class=\"secnum\">24.4.1.14</span>#sec-bytelistequal ByteListEqual( xBytes, yBytes )</h1>...</div></emu-clause>\n\n    "}, "sec-numeric-types-bigint-bitwiseOR": {"num": "6.1.6.2.22", "title": "#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseOR\">#sec-numeric-types-bigint-bitwiseOR</span> BigInt::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"|\"</emu-val>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-bytelistbitwiseop": {"num": "24.4.1.13", "title": "#sec-bytelistbitwiseop ByteListBitwiseOp( op, xBytes, yBytes )", "html": "<emu-clause id=\"sec-bytelistbitwiseop\" aoid=\"ByteListBitwiseOp\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bytelistbitwiseop\">#sec-bytelistbitwiseop</span> ByteListBitwiseOp( <var>op</var>, <var>xBytes</var>, <var>yBytes</var> )</h1>\n        <p>The abstract operation ByteListBitwiseOp takes arguments <var>op</var> (a <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref>), <var>xBytes</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of byte values), and <var>yBytes</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of byte values). The operation atomically performs a bitwise operation on all byte values of the arguments and returns a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of byte values. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xBytes</var> and <var>yBytes</var> have the same number of elements.</li><li>Let <var>result</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>i</var> be 0.</li><li>For each element <var>xByte</var> of <var>xBytes</var>, do<ol><li>Let <var>yByte</var> be <var>yBytes</var>[<var>i</var>].</li><li>Let <var>resultByte</var> be the result of applying the bitwise operator <var>op</var> to <var>xByte</var> and <var>yByte</var>.</li><li>Set <var>i</var> to <var>i</var> + 1.</li><li>Append <var>resultByte</var> to the end of <var>result</var>.</li></ol></li><li>Return <var>result</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numberbitwiseop": {"num": "6.1.6.1.16", "title": "#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-numberbitwiseop\" aoid=\"NumberBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numberbitwiseop\">#sec-numberbitwiseop</span> NumberBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation NumberBitwiseOp takes arguments <var>op</var>, <var>x</var>, and <var>y</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>y</var>).</li><li>Return the result of applying the bitwise operator <var>op</var> to <var>lnum</var> and <var>rnum</var>. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseAND": {"num": "6.1.6.2.20", "title": "#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseAND\">#sec-numeric-types-bigint-bitwiseAND</span> BigInt::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseAND takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"&amp;\"</emu-val>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-bigintbitwiseop": {"num": "6.1.6.2.19", "title": "#sec-bigintbitwiseop BigIntBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-bigintbitwiseop\" aoid=\"BigIntBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bigintbitwiseop\">#sec-bigintbitwiseop</span> BigIntBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigIntBitwiseOp takes arguments <var>op</var>, <var>x</var>, and <var>y</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <emu-val>\"&amp;\"</emu-val>, <emu-val>\"|\"</emu-val>, or <emu-val>\"^\"</emu-val>.</li><li>Let <var>result</var> be <emu-val>0n</emu-val>.</li><li>Let <var>shift</var> be 0.</li><li>Repeat, until (<var>x</var> = 0 or <var>x</var> = -1) and (<var>y</var> = 0 or <var>y</var> = -1),<ol><li>Let <var>xDigit</var> be <var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>Let <var>yDigit</var> be <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>If <var>op</var> is <emu-val>\"&amp;\"</emu-val>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else if <var>op</var> is <emu-val>\"|\"</emu-val>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <emu-val>\"^\"</emu-val>.</li><li>Set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li></ol></li><li>Set <var>shift</var> to <var>shift</var> + 1.</li><li>Set <var>x</var> to (<var>x</var> - <var>xDigit</var>) / 2.</li><li>Set <var>y</var> to (<var>y</var> - <var>yDigit</var>) / 2.</li></ol></li><li>If <var>op</var> is <emu-val>\"&amp;\"</emu-val>, let <var>tmp</var> be <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else if <var>op</var> is <emu-val>\"|\"</emu-val>, let <var>tmp</var> be <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <emu-val>\"^\"</emu-val>.</li><li>Let <var>tmp</var> be <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li></ol></li><li>If <var>tmp</var> &#8800; 0, then<ol><li>Set <var>result</var> to <var>result</var> - 2<sup><var>shift</var></sup>.</li><li>NOTE: This extends the sign.</li></ol></li><li>Return <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}, "to": {"secList": ["sec-numeric-types-bigint-bitwiseXOR", "sec-abstract-operations-for-atomics", "sec-numeric-types-bigint-bitwiseOR", "sec-bytelistbitwiseop", "sec-numberbitwiseop", "sec-numeric-types-bigint-bitwiseAND", "sec-bigintbitwiseop"], "secData": {"sec-numeric-types-bigint-bitwiseXOR": {"num": "6.1.6.2.21", "title": "#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseXOR\">#sec-numeric-types-bigint-bitwiseXOR</span> BigInt::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseXOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-abstract-operations-for-atomics": {"num": "24.4.1", "title": "#sec-abstract-operations-for-atomics Abstract Operations for Atomics", "html": "<emu-clause id=\"sec-abstract-operations-for-atomics\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-abstract-operations-for-atomics\">#sec-abstract-operations-for-atomics</span> Abstract Operations for Atomics</h1>\n\n      <div id=\"excluded-sec-validatesharedintegertypedarray\"><h1><span class=\"secnum\">24.4.1.1</span>#sec-validatesharedintegertypedarray ValidateSharedIntegerTypedArray ( typedArray [ , waitable ] )</h1>...</div><div id=\"excluded-sec-validateatomicaccess\"><h1><span class=\"secnum\">24.4.1.2</span>#sec-validateatomicaccess ValidateAtomicAccess ( typedArray, requestIndex )</h1>...</div><div id=\"excluded-sec-getwaiterlist\"><h1><span class=\"secnum\">24.4.1.3</span>#sec-getwaiterlist GetWaiterList ( block, i )</h1>...</div><div id=\"excluded-sec-entercriticalsection\"><h1><span class=\"secnum\">24.4.1.4</span>#sec-entercriticalsection EnterCriticalSection ( WL )</h1>...</div><div id=\"excluded-sec-leavecriticalsection\"><h1><span class=\"secnum\">24.4.1.5</span>#sec-leavecriticalsection LeaveCriticalSection ( WL )</h1>...</div><div id=\"excluded-sec-addwaiter\"><h1><span class=\"secnum\">24.4.1.6</span>#sec-addwaiter AddWaiter ( WL, W )</h1>...</div><div id=\"excluded-sec-removewaiter\"><h1><span class=\"secnum\">24.4.1.7</span>#sec-removewaiter RemoveWaiter ( WL, W )</h1>...</div><div id=\"excluded-sec-removewaiters\"><h1><span class=\"secnum\">24.4.1.8</span>#sec-removewaiters RemoveWaiters ( WL, c )</h1>...</div><div id=\"excluded-sec-suspend\"><h1><span class=\"secnum\">24.4.1.9</span>#sec-suspend Suspend ( WL, W, timeout )</h1>...</div><div id=\"excluded-sec-notifywaiter\"><h1><span class=\"secnum\">24.4.1.10</span>#sec-notifywaiter NotifyWaiter ( WL, W )</h1>...</div><div id=\"excluded-sec-atomicreadmodifywrite\"><h1><span class=\"secnum\">24.4.1.11</span>#sec-atomicreadmodifywrite AtomicReadModifyWrite ( typedArray, index, value, op )</h1>...</div><div id=\"excluded-sec-atomicload\"><h1><span class=\"secnum\">24.4.1.12</span>#sec-atomicload AtomicLoad ( typedArray, index )</h1>...</div><div id=\"excluded-sec-bytelistbitwiseop\"><h1><span class=\"secnum\">24.4.1.13</span>#sec-bytelistbitwiseop ByteListBitwiseOp ( op, xBytes, yBytes )</h1>...</div><div id=\"excluded-sec-bytelistequal\"><h1><span class=\"secnum\">24.4.1.14</span>#sec-bytelistequal ByteListEqual( xBytes, yBytes )</h1>...</div></emu-clause>\n\n    "}, "sec-numeric-types-bigint-bitwiseOR": {"num": "6.1.6.2.22", "title": "#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseOR\">#sec-numeric-types-bigint-bitwiseOR</span> BigInt::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-bytelistbitwiseop": {"num": "24.4.1.13", "title": "#sec-bytelistbitwiseop ByteListBitwiseOp ( op, xBytes, yBytes )", "html": "<emu-clause id=\"sec-bytelistbitwiseop\" aoid=\"ByteListBitwiseOp\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bytelistbitwiseop\">#sec-bytelistbitwiseop</span> ByteListBitwiseOp ( <var>op</var>, <var>xBytes</var>, <var>yBytes</var> )</h1>\n        <p>The abstract operation ByteListBitwiseOp takes arguments <var>op</var> (a sequence of Unicode code points), <var>xBytes</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of byte values), and <var>yBytes</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of byte values). The operation atomically performs a bitwise operation on all byte values of the arguments and returns a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of byte values. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>&amp;</code>, <code>^</code>, or <code>|</code>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xBytes</var> and <var>yBytes</var> have the same number of elements.</li><li>Let <var>result</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>i</var> be 0.</li><li>For each element <var>xByte</var> of <var>xBytes</var>, do<ol><li>Let <var>yByte</var> be <var>yBytes</var>[<var>i</var>].</li><li>Let <var>resultByte</var> be the result of applying the bitwise operator <var>op</var> to <var>xByte</var> and <var>yByte</var>.</li><li>Set <var>i</var> to <var>i</var> + 1.</li><li>Append <var>resultByte</var> to the end of <var>result</var>.</li></ol></li><li>Return <var>result</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numberbitwiseop": {"num": "6.1.6.1.16", "title": "#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-numberbitwiseop\" aoid=\"NumberBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numberbitwiseop\">#sec-numberbitwiseop</span> NumberBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation NumberBitwiseOp takes arguments <var>op</var> (a sequence of Unicode code points), <var>x</var>, and <var>y</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>&amp;</code>, <code>^</code>, or <code>|</code>.</li><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>y</var>).</li><li>Return the result of applying the bitwise operator <var>op</var> to <var>lnum</var> and <var>rnum</var>. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseAND": {"num": "6.1.6.2.20", "title": "#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseAND\">#sec-numeric-types-bigint-bitwiseAND</span> BigInt::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseAND takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-bigintbitwiseop": {"num": "6.1.6.2.19", "title": "#sec-bigintbitwiseop BigIntBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-bigintbitwiseop\" aoid=\"BigIntBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bigintbitwiseop\">#sec-bigintbitwiseop</span> BigIntBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigIntBitwiseOp takes arguments <var>op</var> (a sequence of Unicode code points), <var>x</var>, and <var>y</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>&amp;</code>, <code>^</code>, or <code>|</code>.</li><li>Let <var>result</var> be <emu-val>0n</emu-val>.</li><li>Let <var>shift</var> be 0.</li><li>Repeat, until (<var>x</var> = 0 or <var>x</var> = -1) and (<var>y</var> = 0 or <var>y</var> = -1),<ol><li>Let <var>xDigit</var> be <var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>Let <var>yDigit</var> be <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>If <var>op</var> is <code>&amp;</code>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else if <var>op</var> is <code>|</code>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>^</code>.</li><li>Set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li></ol></li><li>Set <var>shift</var> to <var>shift</var> + 1.</li><li>Set <var>x</var> to (<var>x</var> - <var>xDigit</var>) / 2.</li><li>Set <var>y</var> to (<var>y</var> - <var>yDigit</var>) / 2.</li></ol></li><li>If <var>op</var> is <code>&amp;</code>, let <var>tmp</var> be <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else if <var>op</var> is <code>|</code>, let <var>tmp</var> be <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>^</code>.</li><li>Let <var>tmp</var> be <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li></ol></li><li>If <var>tmp</var> &#8800; 0, then<ol><li>Set <var>result</var> to <var>result</var> - 2<sup><var>shift</var></sup>.</li><li>NOTE: This extends the sign.</li></ol></li><li>Return <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}}