{"from": {"secList": ["sec-assertion"], "secData": {"sec-assertion": {"num": "21.2.2.6", "title": "#sec-assertion Assertion", "html": "<emu-clause id=\"sec-assertion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-assertion\">#sec-assertion</span> Assertion</h1>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e5878811\"><emu-t>^</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is zero, call <var>c</var>(<var>x</var>) and return its result.</li><li>If <var>Multiline</var> is <emu-val>false</emu-val>, return <emu-const>failure</emu-const>.</li><li>If the character <var>Input</var>[<var>e</var> - 1] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, call <var>c</var>(<var>x</var>) and return its result.</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Even when the <code>y</code> flag is used with a pattern, <code>^</code> always matches only at the beginning of <var>Input</var>, or (if <var>Multiline</var> is <emu-val>true</emu-val>) at the beginning of a line.</p>\n        </div></emu-note>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1262cc92\"><emu-t>$</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is equal to <var>InputLength</var>, call <var>c</var>(<var>x</var>) and return its result.</li><li>If <var>Multiline</var> is <emu-val>false</emu-val>, return <emu-const>failure</emu-const>.</li><li>If the character <var>Input</var>[<var>e</var>] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, call <var>c</var>(<var>x</var>) and return its result.</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1e228da5\"><emu-t>\\</emu-t><emu-t>b</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, call <var>c</var>(<var>x</var>) and return its result.</li><li>If <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, call <var>c</var>(<var>x</var>) and return its result.</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"a5dc97fa\"><emu-t>\\</emu-t><emu-t>B</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, return <emu-const>failure</emu-const>.</li><li>If <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"cfb94f94\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"ba98f6e2\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"8db9fbbe\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1b07b2c0\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-wordcharacters-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.1</span>#sec-runtime-semantics-wordcharacters-abstract-operation Runtime Semantics: WordCharacters ( )</h1>...</div><div id=\"excluded-sec-runtime-semantics-iswordchar-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.2</span>#sec-runtime-semantics-iswordchar-abstract-operation Runtime Semantics: IsWordChar ( e )</h1>...</div></emu-clause>\n      "}}, "figData": {}}, "to": {"secList": ["sec-assertion"], "secData": {"sec-assertion": {"num": "21.2.2.6", "title": "#sec-assertion Assertion", "html": "<emu-clause id=\"sec-assertion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-assertion\">#sec-assertion</span> Assertion</h1>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e5878811\"><emu-t>^</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is zero, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var> - 1] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Even when the <code>y</code> flag is used with a pattern, <code>^</code> always matches only at the beginning of <var>Input</var>, or (if <var>Multiline</var> is <emu-val>true</emu-val>) at the beginning of a line.</p>\n        </div></emu-note>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1262cc92\"><emu-t>$</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is equal to <var>InputLength</var>, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var>] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1e228da5\"><emu-t>\\</emu-t><emu-t>b</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"a5dc97fa\"><emu-t>\\</emu-t><emu-t>B</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>true</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"cfb94f94\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"ba98f6e2\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"8db9fbbe\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1b07b2c0\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-wordcharacters-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.1</span>#sec-runtime-semantics-wordcharacters-abstract-operation Runtime Semantics: WordCharacters ( )</h1>...</div><div id=\"excluded-sec-runtime-semantics-iswordchar-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.2</span>#sec-runtime-semantics-iswordchar-abstract-operation Runtime Semantics: IsWordChar ( e )</h1>...</div></emu-clause>\n      "}}, "figData": {}}}