{"from": {"secList": ["sec-numeric-types-number-bitwiseNOT", "sec-numeric-types-number-signedRightShift", "sec-numberbitwiseop", "sec-numeric-types-number-leftShift", "sec-ecmascript-language-types-number-type", "sec-numeric-types-number-unsignedRightShift"], "secData": {"sec-numeric-types-number-bitwiseNOT": {"num": "6.1.6.1.2", "title": "#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseNOT\" aoid=\"Number::bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseNOT\">#sec-numeric-types-number-bitwiseNOT</span> Number::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation Number::bitwiseNOT takes argument <var>x</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>oldValue</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Return the result of applying bitwise complement to <var>oldValue</var>. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-signedRightShift": {"num": "6.1.6.1.10", "title": "#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-signedRightShift\" aoid=\"Number::signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-signedRightShift\">#sec-numeric-types-number-signedRightShift</span> Number::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::signedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of performing a sign-extending right shift of <var>lnum</var> by <var>shiftCount</var> bits. The most significant bit is propagated. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numberbitwiseop": {"num": "6.1.6.1.16", "title": "#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-numberbitwiseop\" aoid=\"NumberBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numberbitwiseop\">#sec-numberbitwiseop</span> NumberBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation NumberBitwiseOp takes arguments <var>op</var> (<code>&amp;</code>, <code>^</code>, or <code>|</code>), <var>x</var> (a Number), and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>y</var>).</li><li>Let <var>lbits</var> be the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>lnum</var>).</li><li>Let <var>rbits</var> be the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>).</li><li>If <var>op</var> is <code>&amp;</code>, let <var>result</var> be the result of applying the bitwise AND operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else if <var>op</var> is <code>^</code>, let <var>result</var> be the result of applying the bitwise exclusive OR (XOR) operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else, <var>op</var> is <code>|</code>. Let <var>result</var> be the result of applying the bitwise inclusive OR operation to <var>lbits</var> and <var>rbits</var>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> represented by the 32-bit two's complement bit string <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-leftShift": {"num": "6.1.6.1.9", "title": "#sec-numeric-types-number-leftShift Number::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-leftShift\" aoid=\"Number::leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-leftShift\">#sec-numeric-types-number-leftShift</span> Number::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::leftShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of left shifting <var>lnum</var> by <var>shiftCount</var> bits. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-ecmascript-language-types-number-type": {"num": "6.1.6.1", "title": "#sec-ecmascript-language-types-number-type The Number Type", "html": "<emu-clause id=\"sec-ecmascript-language-types-number-type\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-language-types-number-type\">#sec-ecmascript-language-types-number-type</span> The Number Type</h1>\n        <p>The Number type has exactly 18,437,736,874,454,810,627 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>) values, representing the double-precision 64-bit format <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) distinct &#8220;Not-a-Number&#8221; values of the IEEE Standard are represented in ECMAScript as a single special <emu-val>NaN</emu-val> value. (Note that the <emu-val>NaN</emu-val> value is produced by the program expression <code>NaN</code>.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>; to ECMAScript code, all <emu-val>NaN</emu-val> values are indistinguishable from each other.</p>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The bit pattern that might be observed in an ArrayBuffer (see <emu-xref href=\"#sec-arraybuffer-objects\"><a href=\"#sec-arraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-arraybuffer-objects\">#sec-arraybuffer-objects</a></emu-xref>) or a SharedArrayBuffer (see <emu-xref href=\"#sec-sharedarraybuffer-objects\"><a href=\"#sec-sharedarraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-sharedarraybuffer-objects\">#sec-sharedarraybuffer-objects</a></emu-xref>) after a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> has been stored into it is not necessarily the same as the internal representation of that <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> used by the ECMAScript implementation.</p>\n        </div></emu-note>\n        <p>There are two other special values, called <emu-val>positive Infinity</emu-val> and <emu-val>negative Infinity</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> and <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, respectively. (Note that these two infinite Number values are produced by the program expressions <code>+Infinity</code> (or simply <code>Infinity</code>) and <code>-Infinity</code>.)</p>\n        <p>The other 18,437,736,874,454,810,624 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup></emu-eqn>) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> there is a corresponding negative value having the same magnitude.</p>\n        <p>Note that there is both a <emu-val>positive zero</emu-val> and a <emu-val>negative zero</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>, respectively. (Note that these two different zero Number values are produced by the program expressions <code>+0</code> (or simply <code>0</code>) and <code>-0</code>.)</p>\n        <p>The 18,437,736,874,454,810,622 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>) finite non-zero values are of two kinds:</p>\n        <p>18,428,729,675,200,069,632 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>54</sup></emu-eqn>) of them are normalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 2<sup>52</sup> &#8804; <var>m</var> &lt; 2<sup>53</sup>, and <var>e</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that -1074 &#8804; <var>e</var> &#8804; 971.</p>\n        <p>The remaining 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) values are denormalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 0 &lt; <var>m</var> &lt; 2<sup>52</sup>, and <var>e</var> is -1074.</p>\n        <p>Note that all the positive and negative <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type. The <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> 0 has two representations in the Number type: <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n        <p>A finite number has an <em>odd significand</em> if it is non-zero and the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>m</var> used to express it (in one of the two forms shown above) is odd. Otherwise, it has an <em>even significand</em>.</p>\n        <p>In this specification, the phrase &#8220;the <dfn id=\"number-value\">Number value</dfn> for <var>x</var>&#8221; where <var>x</var> represents an exact real mathematical quantity (which might even be an irrational number such as &#960;) means a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> chosen in the following manner. Consider the set of all finite values of the Number type, with <emu-val>-0</emu-val><sub>&#120125;</sub> removed and with two additional values added to it that are not representable in the Number type, namely 2<sup>1024</sup> (which is <emu-eqn class=\"inline\">+1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>) and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> (which is <emu-eqn class=\"inline\">-1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>). Choose the member of this set that is closest in value to <var>x</var>. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2<sup>1024</sup> and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> are considered to have even significands. Finally, if 2<sup>1024</sup> was chosen, replace it with <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>; if <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> was chosen, replace it with <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>; if <emu-val>+0</emu-val><sub>&#120125;</sub> was chosen, replace it with <emu-val>-0</emu-val><sub>&#120125;</sub> if and only if <var>x</var> &lt; 0; any other chosen value is used unchanged. The result is the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for <var>x</var>. (This procedure corresponds exactly to the behaviour of the <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode.)</p>\n        <p>The <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for +&#8734; is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, and the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for -&#8734; is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>.</p>\n        <p>Some ECMAScript operators deal only with <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> in specific ranges such as <emu-eqn class=\"inline\">-2<sup>31</sup></emu-eqn> through <emu-eqn class=\"inline\">2<sup>31</sup> - 1</emu-eqn>, inclusive, or in the range 0 through <emu-eqn class=\"inline\">2<sup>16</sup> - 1</emu-eqn>, inclusive. These operators accept any value of the Number type but first convert each such value to an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value in the expected range. See the descriptions of the numeric conversion operations in <emu-xref href=\"#sec-type-conversion\"><a href=\"#sec-type-conversion\" class=\"excluded-xref\" excluded-id=\"sec-type-conversion\">#sec-type-conversion</a></emu-xref>.</p>\n\n        <p>The Number::unit value is <emu-val>1</emu-val><sub>&#120125;</sub>.</p>\n\n        <div id=\"excluded-sec-numeric-types-number-unaryMinus\"><h1><span class=\"secnum\">6.1.6.1.1</span>#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseNOT\"><h1><span class=\"secnum\">6.1.6.1.2</span>#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-exponentiate\"><h1><span class=\"secnum\">6.1.6.1.3</span>#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )</h1>...</div><div id=\"excluded-sec-numeric-types-number-multiply\"><h1><span class=\"secnum\">6.1.6.1.4</span>#sec-numeric-types-number-multiply Number::multiply ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-divide\"><h1><span class=\"secnum\">6.1.6.1.5</span>#sec-numeric-types-number-divide Number::divide ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-remainder\"><h1><span class=\"secnum\">6.1.6.1.6</span>#sec-numeric-types-number-remainder Number::remainder ( n, d )</h1>...</div><div id=\"excluded-sec-numeric-types-number-add\"><h1><span class=\"secnum\">6.1.6.1.7</span>#sec-numeric-types-number-add Number::add ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-subtract\"><h1><span class=\"secnum\">6.1.6.1.8</span>#sec-numeric-types-number-subtract Number::subtract ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-leftShift\"><h1><span class=\"secnum\">6.1.6.1.9</span>#sec-numeric-types-number-leftShift Number::leftShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-signedRightShift\"><h1><span class=\"secnum\">6.1.6.1.10</span>#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-unsignedRightShift\"><h1><span class=\"secnum\">6.1.6.1.11</span>#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-lessThan\"><h1><span class=\"secnum\">6.1.6.1.12</span>#sec-numeric-types-number-lessThan Number::lessThan ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-equal\"><h1><span class=\"secnum\">6.1.6.1.13</span>#sec-numeric-types-number-equal Number::equal ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValue\"><h1><span class=\"secnum\">6.1.6.1.14</span>#sec-numeric-types-number-sameValue Number::sameValue ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValueZero\"><h1><span class=\"secnum\">6.1.6.1.15</span>#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )</h1>...</div><div id=\"excluded-sec-numberbitwiseop\"><h1><span class=\"secnum\">6.1.6.1.16</span>#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseAND\"><h1><span class=\"secnum\">6.1.6.1.17</span>#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseXOR\"><h1><span class=\"secnum\">6.1.6.1.18</span>#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseOR\"><h1><span class=\"secnum\">6.1.6.1.19</span>#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-tostring\"><h1><span class=\"secnum\">6.1.6.1.20</span>#sec-numeric-types-number-tostring Number::toString ( x )</h1>...</div></emu-clause>\n\n      "}, "sec-numeric-types-number-unsignedRightShift": {"num": "6.1.6.1.11", "title": "#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-unsignedRightShift\" aoid=\"Number::unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unsignedRightShift\">#sec-numeric-types-number-unsignedRightShift</span> Number::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::unsignedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of performing a zero-filling right shift of <var>lnum</var> by <var>shiftCount</var> bits. Vacated bits are filled with zero. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit unsigned bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}, "to": {"secList": ["sec-numeric-types-number-bitwiseNOT", "sec-numeric-types-number-signedRightShift", "sec-numberbitwiseop", "sec-int32bitstonumber", "sec-numbertouint32bits", "sec-numeric-types-number-leftShift", "sec-uint32bitstonumber", "sec-ecmascript-language-types-number-type", "sec-numeric-types-number-unsignedRightShift", "sec-numbertoint32bits"], "secData": {"sec-numeric-types-number-bitwiseNOT": {"num": "6.1.6.1.2", "title": "#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseNOT\" aoid=\"Number::bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseNOT\">#sec-numeric-types-number-bitwiseNOT</span> Number::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation Number::bitwiseNOT takes argument <var>x</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>xbits</var> be !&#160;<emu-xref aoid=\"NumberToInt32Bits\"><a href=\"#sec-numbertoint32bits\">NumberToInt32Bits</a></emu-xref>(<var>x</var>).</li><li>Let <var>cbits</var> be the result of applying bitwise complement to <var>xbits</var>.</li><li>Return !&#160;<emu-xref aoid=\"Int32BitsToNumber\"><a href=\"#sec-int32bitstonumber\">Int32BitsToNumber</a></emu-xref>(<var>cbits</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-signedRightShift": {"num": "6.1.6.1.10", "title": "#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-signedRightShift\" aoid=\"Number::signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-signedRightShift\">#sec-numeric-types-number-signedRightShift</span> Number::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::signedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lbits</var> be !&#160;<emu-xref aoid=\"NumberToInt32Bits\"><a href=\"#sec-numbertoint32bits\">NumberToInt32Bits</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Let <var>shifted</var> be the result of performing a sign-extending right shift of <var>lbits</var> by <var>shiftCount</var> bits. The most significant bit is propagated.</li><li>Return !&#160;<emu-xref aoid=\"Int32BitsToNumber\"><a href=\"#sec-int32bitstonumber\">Int32BitsToNumber</a></emu-xref>(<var>shifted</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numberbitwiseop": {"num": "6.1.6.1.16", "title": "#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-numberbitwiseop\" aoid=\"NumberBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numberbitwiseop\">#sec-numberbitwiseop</span> NumberBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation NumberBitwiseOp takes arguments <var>op</var> (<code>&amp;</code>, <code>^</code>, or <code>|</code>), <var>x</var> (a Number), and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lbits</var> be !&#160;<emu-xref aoid=\"NumberToInt32Bits\"><a href=\"#sec-numbertoint32bits\">NumberToInt32Bits</a></emu-xref>(<var>x</var>).</li><li>Let <var>rbits</var> be !&#160;<emu-xref aoid=\"NumberToInt32Bits\"><a href=\"#sec-numbertoint32bits\">NumberToInt32Bits</a></emu-xref>(<var>y</var>).</li><li>If <var>op</var> is <code>&amp;</code>, let <var>result</var> be the result of applying the bitwise AND operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else if <var>op</var> is <code>^</code>, let <var>result</var> be the result of applying the bitwise exclusive OR (XOR) operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else, <var>op</var> is <code>|</code>. Let <var>result</var> be the result of applying the bitwise inclusive OR operation to <var>lbits</var> and <var>rbits</var>.</li><li>Return !&#160;<emu-xref aoid=\"Int32BitsToNumber\"><a href=\"#sec-int32bitstonumber\">Int32BitsToNumber</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-int32bitstonumber": {"num": "6.1.6.1.18", "title": "#sec-int32bitstonumber Int32BitsToNumber ( bits )", "html": "<emu-clause id=\"sec-int32bitstonumber\" aoid=\"Int32BitsToNumber\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-int32bitstonumber\">#sec-int32bitstonumber</span> Int32BitsToNumber ( <var>bits</var> )</h1>\n          <p>The abstract operation Int32BitsToNumber takes argument <var>bits</var> (a 32-bit bit string). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>i</var> be the result of interpreting <var>bits</var> as a 32-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.</li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>i</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numbertouint32bits": {"num": "6.1.6.1.19", "title": "#sec-numbertouint32bits NumberToUint32Bits ( number )", "html": "<emu-clause id=\"sec-numbertouint32bits\" aoid=\"NumberToUint32Bits\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numbertouint32bits\">#sec-numbertouint32bits</span> NumberToUint32Bits ( <var>number</var> )</h1>\n          <p>The abstract operation NumberToUint32Bits takes argument <var>number</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>n</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>number</var>).</li><li>Return the 32-bit unsigned bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>n</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-leftShift": {"num": "6.1.6.1.9", "title": "#sec-numeric-types-number-leftShift Number::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-leftShift\" aoid=\"Number::leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-leftShift\">#sec-numeric-types-number-leftShift</span> Number::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::leftShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lbits</var> be !&#160;<emu-xref aoid=\"NumberToInt32Bits\"><a href=\"#sec-numbertoint32bits\">NumberToInt32Bits</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Let <var>shifted</var> be the result of left shifting <var>lbits</var> by <var>shiftCount</var> bits.</li><li>Return !&#160;<emu-xref aoid=\"Int32BitsToNumber\"><a href=\"#sec-int32bitstonumber\">Int32BitsToNumber</a></emu-xref>(<var>shifted</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-uint32bitstonumber": {"num": "6.1.6.1.20", "title": "#sec-uint32bitstonumber Uint32BitsToNumber ( bits )", "html": "<emu-clause id=\"sec-uint32bitstonumber\" aoid=\"Uint32BitsToNumber\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-uint32bitstonumber\">#sec-uint32bitstonumber</span> Uint32BitsToNumber ( <var>bits</var> )</h1>\n          <p>The abstract operation Uint32BitsToNumber takes argument <var>bits</var> (a 32-bit bit string). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>i</var> be the result of interpreting <var>bits</var> as a 32-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.</li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>i</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-ecmascript-language-types-number-type": {"num": "6.1.6.1", "title": "#sec-ecmascript-language-types-number-type The Number Type", "html": "<emu-clause id=\"sec-ecmascript-language-types-number-type\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-language-types-number-type\">#sec-ecmascript-language-types-number-type</span> The Number Type</h1>\n        <p>The Number type has exactly 18,437,736,874,454,810,627 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>) values, representing the double-precision 64-bit format <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) distinct &#8220;Not-a-Number&#8221; values of the IEEE Standard are represented in ECMAScript as a single special <emu-val>NaN</emu-val> value. (Note that the <emu-val>NaN</emu-val> value is produced by the program expression <code>NaN</code>.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>; to ECMAScript code, all <emu-val>NaN</emu-val> values are indistinguishable from each other.</p>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The bit pattern that might be observed in an ArrayBuffer (see <emu-xref href=\"#sec-arraybuffer-objects\"><a href=\"#sec-arraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-arraybuffer-objects\">#sec-arraybuffer-objects</a></emu-xref>) or a SharedArrayBuffer (see <emu-xref href=\"#sec-sharedarraybuffer-objects\"><a href=\"#sec-sharedarraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-sharedarraybuffer-objects\">#sec-sharedarraybuffer-objects</a></emu-xref>) after a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> has been stored into it is not necessarily the same as the internal representation of that <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> used by the ECMAScript implementation.</p>\n        </div></emu-note>\n        <p>There are two other special values, called <emu-val>positive Infinity</emu-val> and <emu-val>negative Infinity</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> and <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, respectively. (Note that these two infinite Number values are produced by the program expressions <code>+Infinity</code> (or simply <code>Infinity</code>) and <code>-Infinity</code>.)</p>\n        <p>The other 18,437,736,874,454,810,624 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup></emu-eqn>) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> there is a corresponding negative value having the same magnitude.</p>\n        <p>Note that there is both a <emu-val>positive zero</emu-val> and a <emu-val>negative zero</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>, respectively. (Note that these two different zero Number values are produced by the program expressions <code>+0</code> (or simply <code>0</code>) and <code>-0</code>.)</p>\n        <p>The 18,437,736,874,454,810,622 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>) finite non-zero values are of two kinds:</p>\n        <p>18,428,729,675,200,069,632 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>54</sup></emu-eqn>) of them are normalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 2<sup>52</sup> &#8804; <var>m</var> &lt; 2<sup>53</sup>, and <var>e</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that -1074 &#8804; <var>e</var> &#8804; 971.</p>\n        <p>The remaining 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) values are denormalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 0 &lt; <var>m</var> &lt; 2<sup>52</sup>, and <var>e</var> is -1074.</p>\n        <p>Note that all the positive and negative <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type. The <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> 0 has two representations in the Number type: <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n        <p>A finite number has an <em>odd significand</em> if it is non-zero and the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>m</var> used to express it (in one of the two forms shown above) is odd. Otherwise, it has an <em>even significand</em>.</p>\n        <p>In this specification, the phrase &#8220;the <dfn id=\"number-value\">Number value</dfn> for <var>x</var>&#8221; where <var>x</var> represents an exact real mathematical quantity (which might even be an irrational number such as &#960;) means a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> chosen in the following manner. Consider the set of all finite values of the Number type, with <emu-val>-0</emu-val><sub>&#120125;</sub> removed and with two additional values added to it that are not representable in the Number type, namely 2<sup>1024</sup> (which is <emu-eqn class=\"inline\">+1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>) and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> (which is <emu-eqn class=\"inline\">-1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>). Choose the member of this set that is closest in value to <var>x</var>. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2<sup>1024</sup> and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> are considered to have even significands. Finally, if 2<sup>1024</sup> was chosen, replace it with <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>; if <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> was chosen, replace it with <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>; if <emu-val>+0</emu-val><sub>&#120125;</sub> was chosen, replace it with <emu-val>-0</emu-val><sub>&#120125;</sub> if and only if <var>x</var> &lt; 0; any other chosen value is used unchanged. The result is the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for <var>x</var>. (This procedure corresponds exactly to the behaviour of the <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode.)</p>\n        <p>The <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for +&#8734; is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, and the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for -&#8734; is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>.</p>\n        <p>Some ECMAScript operators deal only with <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> in specific ranges such as <emu-eqn class=\"inline\">-2<sup>31</sup></emu-eqn> through <emu-eqn class=\"inline\">2<sup>31</sup> - 1</emu-eqn>, inclusive, or in the range 0 through <emu-eqn class=\"inline\">2<sup>16</sup> - 1</emu-eqn>, inclusive. These operators accept any value of the Number type but first convert each such value to an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value in the expected range. See the descriptions of the numeric conversion operations in <emu-xref href=\"#sec-type-conversion\"><a href=\"#sec-type-conversion\" class=\"excluded-xref\" excluded-id=\"sec-type-conversion\">#sec-type-conversion</a></emu-xref>.</p>\n\n        <p>The Number::unit value is <emu-val>1</emu-val><sub>&#120125;</sub>.</p>\n\n        <div id=\"excluded-sec-numeric-types-number-unaryMinus\"><h1><span class=\"secnum\">6.1.6.1.1</span>#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseNOT\"><h1><span class=\"secnum\">6.1.6.1.2</span>#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-exponentiate\"><h1><span class=\"secnum\">6.1.6.1.3</span>#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )</h1>...</div><div id=\"excluded-sec-numeric-types-number-multiply\"><h1><span class=\"secnum\">6.1.6.1.4</span>#sec-numeric-types-number-multiply Number::multiply ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-divide\"><h1><span class=\"secnum\">6.1.6.1.5</span>#sec-numeric-types-number-divide Number::divide ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-remainder\"><h1><span class=\"secnum\">6.1.6.1.6</span>#sec-numeric-types-number-remainder Number::remainder ( n, d )</h1>...</div><div id=\"excluded-sec-numeric-types-number-add\"><h1><span class=\"secnum\">6.1.6.1.7</span>#sec-numeric-types-number-add Number::add ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-subtract\"><h1><span class=\"secnum\">6.1.6.1.8</span>#sec-numeric-types-number-subtract Number::subtract ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-leftShift\"><h1><span class=\"secnum\">6.1.6.1.9</span>#sec-numeric-types-number-leftShift Number::leftShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-signedRightShift\"><h1><span class=\"secnum\">6.1.6.1.10</span>#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-unsignedRightShift\"><h1><span class=\"secnum\">6.1.6.1.11</span>#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-lessThan\"><h1><span class=\"secnum\">6.1.6.1.12</span>#sec-numeric-types-number-lessThan Number::lessThan ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-equal\"><h1><span class=\"secnum\">6.1.6.1.13</span>#sec-numeric-types-number-equal Number::equal ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValue\"><h1><span class=\"secnum\">6.1.6.1.14</span>#sec-numeric-types-number-sameValue Number::sameValue ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValueZero\"><h1><span class=\"secnum\">6.1.6.1.15</span>#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )</h1>...</div><div id=\"excluded-sec-numberbitwiseop\"><h1><span class=\"secnum\">6.1.6.1.16</span>#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )</h1>...</div><div id=\"excluded-sec-numbertoint32bits\"><h1><span class=\"secnum\">6.1.6.1.17</span>#sec-numbertoint32bits NumberToInt32Bits ( number )</h1>...</div><div id=\"excluded-sec-int32bitstonumber\"><h1><span class=\"secnum\">6.1.6.1.18</span>#sec-int32bitstonumber Int32BitsToNumber ( bits )</h1>...</div><div id=\"excluded-sec-numbertouint32bits\"><h1><span class=\"secnum\">6.1.6.1.19</span>#sec-numbertouint32bits NumberToUint32Bits ( number )</h1>...</div><div id=\"excluded-sec-uint32bitstonumber\"><h1><span class=\"secnum\">6.1.6.1.20</span>#sec-uint32bitstonumber Uint32BitsToNumber ( bits )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseAND\"><h1><span class=\"secnum\">6.1.6.1.21</span>#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseXOR\"><h1><span class=\"secnum\">6.1.6.1.22</span>#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseOR\"><h1><span class=\"secnum\">6.1.6.1.23</span>#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-tostring\"><h1><span class=\"secnum\">6.1.6.1.24</span>#sec-numeric-types-number-tostring Number::toString ( x )</h1>...</div></emu-clause>\n\n      "}, "sec-numeric-types-number-unsignedRightShift": {"num": "6.1.6.1.11", "title": "#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-unsignedRightShift\" aoid=\"Number::unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unsignedRightShift\">#sec-numeric-types-number-unsignedRightShift</span> Number::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::unsignedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lbits</var> be !&#160;<emu-xref aoid=\"NumberToUint32Bits\"><a href=\"#sec-numbertouint32bits\">NumberToUint32Bits</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Let <var>shifted</var> be the result of performing a zero-filling right shift of <var>lbits</var> by <var>shiftCount</var> bits. Vacated bits are filled with zero.</li><li>Return !&#160;<emu-xref aoid=\"Uint32BitsToNumber\"><a href=\"#sec-uint32bitstonumber\">Uint32BitsToNumber</a></emu-xref>(<var>shifted</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numbertoint32bits": {"num": "6.1.6.1.17", "title": "#sec-numbertoint32bits NumberToInt32Bits ( number )", "html": "<emu-clause id=\"sec-numbertoint32bits\" aoid=\"NumberToInt32Bits\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numbertoint32bits\">#sec-numbertoint32bits</span> NumberToInt32Bits ( <var>number</var> )</h1>\n          <p>The abstract operation NumberToInt32Bits takes argument <var>number</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>n</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>number</var>).</li><li>Return the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>n</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}}