{"from": {"secList": ["sec-regexpbuiltinexec", "sec-atom", "sec-backreference-matcher", "sec-runtime-semantics-repeatmatcher-abstract-operation", "sec-notation"], "secData": {"sec-regexpbuiltinexec": {"num": "21.2.5.2.2", "title": "#sec-regexpbuiltinexec Runtime Semantics: RegExpBuiltinExec ( R, S )", "html": "<emu-clause id=\"sec-regexpbuiltinexec\" aoid=\"RegExpBuiltinExec\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-regexpbuiltinexec\">#sec-regexpbuiltinexec</span> Runtime Semantics: RegExpBuiltinExec ( <var>R</var>, <var>S</var> )</h1>\n          <p>The abstract operation RegExpBuiltinExec takes arguments <var>R</var> and <var>S</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>R</var> is an initialized RegExp instance.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>S</var>) is String.</li><li>Let <var>length</var> be the number of code units in <var>S</var>.</li><li>Let <var>lastIndex</var> be ?&#160;<emu-xref aoid=\"ToLength\"><a href=\"#sec-tolength\">ToLength</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>)).</li><li>Let <var>flags</var> be <var>R</var>.[[OriginalFlags]].</li><li>If <var>flags</var> contains <emu-val>\"g\"</emu-val>, let <var>global</var> be <emu-val>true</emu-val>; else let <var>global</var> be <emu-val>false</emu-val>.</li><li>If <var>flags</var> contains <emu-val>\"y\"</emu-val>, let <var>sticky</var> be <emu-val>true</emu-val>; else let <var>sticky</var> be <emu-val>false</emu-val>.</li><li>If <var>global</var> is <emu-val>false</emu-val> and <var>sticky</var> is <emu-val>false</emu-val>, set <var>lastIndex</var> to 0.</li><li>Let <var>matcher</var> be <var>R</var>.[[RegExpMatcher]].</li><li>If <var>flags</var> contains <emu-val>\"u\"</emu-val>, let <var>fullUnicode</var> be <emu-val>true</emu-val>; else let <var>fullUnicode</var> be <emu-val>false</emu-val>.</li><li>Let <var>matchSucceeded</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>matchSucceeded</var> is <emu-val>false</emu-val>,<ol><li>If <var>lastIndex</var> &gt; <var>length</var>, then<ol><li>If <var>global</var> is <emu-val>true</emu-val> or <var>sticky</var> is <emu-val>true</emu-val>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>, 0, <emu-val>true</emu-val>).</li></ol></li><li>Return <emu-val>null</emu-val>.</li></ol></li><li>Let <var>r</var> be <var>matcher</var>(<var>S</var>, <var>lastIndex</var>).</li><li>If <var>r</var> is <emu-const>failure</emu-const>, then<ol><li>If <var>sticky</var> is <emu-val>true</emu-val>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>, 0, <emu-val>true</emu-val>).</li><li>Return <emu-val>null</emu-val>.</li></ol></li><li>Set <var>lastIndex</var> to <emu-xref aoid=\"AdvanceStringIndex\"><a href=\"#sec-advancestringindex\">AdvanceStringIndex</a></emu-xref>(<var>S</var>, <var>lastIndex</var>, <var>fullUnicode</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>r</var> is a State.</li><li>Set <var>matchSucceeded</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Let <var>e</var> be <var>r</var>'s <var>endIndex</var> value.</li><li>If <var>fullUnicode</var> is <emu-val>true</emu-val>, then<ol><li><var>e</var> is an index into the <var>Input</var> character list, derived from <var>S</var>, matched by <var>matcher</var>. Let <var>eUTF</var> be the smallest index into <var>S</var> that corresponds to the character at element <var>e</var> of <var>Input</var>. If <var>e</var> is greater than or equal to the number of elements in <var>Input</var>, then <var>eUTF</var> is the number of code units in <var>S</var>.</li><li>Set <var>e</var> to <var>eUTF</var>.</li></ol></li><li>If <var>global</var> is <emu-val>true</emu-val> or <var>sticky</var> is <emu-val>true</emu-val>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>, <var>e</var>, <emu-val>true</emu-val>).</li></ol></li><li>Let <var>n</var> be the number of elements in <var>r</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>. (This is the same value as <emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>'s <var>NcapturingParens</var>.)</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> &lt; 2<sup>32</sup> - 1.</li><li>Let <var>A</var> be !&#160;<emu-xref aoid=\"ArrayCreate\"><a href=\"#sec-arraycreate\">ArrayCreate</a></emu-xref>(<var>n</var> + 1).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The value of <var>A</var>'s <emu-val>\"length\"</emu-val> property is <var>n</var> + 1.</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"index\"</emu-val>, <var>lastIndex</var>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"input\"</emu-val>, <var>S</var>).</li><li>Let <var>matchedSubstr</var> be the <emu-xref href=\"#substring\"><a href=\"#substring\">substring</a></emu-xref> of <var>S</var> from <var>lastIndex</var> to <var>e</var>.</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"0\"</emu-val>, <var>matchedSubstr</var>).</li><li>If <var>R</var> contains any <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>, then<ol><li>Let <var>groups</var> be <emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<emu-val>null</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>groups</var> be <emu-val>undefined</emu-val>.</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"groups\"</emu-val>, <var>groups</var>).</li><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> such that <var>i</var> &gt; 0 and <var>i</var> &#8804; <var>n</var>, do<ol><li>Let <var>captureI</var> be <var>i</var><sup>th</sup> element of <var>r</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>If <var>captureI</var> is <emu-val>undefined</emu-val>, let <var>capturedValue</var> be <emu-val>undefined</emu-val>.</li><li>Else if <var>fullUnicode</var> is <emu-val>true</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>captureI</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of code points.</li><li>Let <var>capturedValue</var> be !&#160;<emu-xref aoid=\"CodePointsToString\"><a href=\"#sec-codepointstostring\">CodePointsToString</a></emu-xref>(<var>captureI</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>fullUnicode</var> is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>captureI</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of code units.</li><li>Let <var>capturedValue</var> be the String value consisting of the code units of <var>captureI</var>.</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>i</var>), <var>capturedValue</var>).</li><li>If the <var>i</var><sup>th</sup> capture of <var>R</var> was defined with a <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>, then<ol><li>Let <var>s</var> be the StringValue of the corresponding <emu-nt><a href=\"#prod-RegExpIdentifierName\">RegExpIdentifierName</a></emu-nt>.</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>groups</var>, <var>s</var>, <var>capturedValue</var>).</li></ol></li></ol></li><li>Return <var>A</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-atom": {"num": "21.2.2.8", "title": "#sec-atom Atom", "html": "<emu-clause id=\"sec-atom\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atom\">#sec-atom</span> Atom</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"beff52c4\"><emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Let <var>ch</var> be the character matched by <emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9658e473\"><emu-t>.</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>If <var>DotAll</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>A</var> be the set of all characters.</li></ol></li><li>Otherwise, let <var>A</var> be the set of all characters except <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9ce67ea4\"><emu-t>\\</emu-t><emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"66aaa8b9\"><emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt> to obtain a CharSet <var>A</var> and a Boolean <var>invert</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <var>invert</var>, <var>direction</var>) and return its Matcher result.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes prior to or enclosing this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>direction</var>, <var>m</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>x</var>, <var>c</var>, <var>direction</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Let <var>cap</var> be a copy of <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>ye</var> be <var>y</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> is equal to +1, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xe</var> &#8804; <var>ye</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>xe</var> (inclusive) through <var>ye</var> (exclusive).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is equal to -1.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ye</var> &#8804; <var>xe</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>ye</var> (inclusive) through <var>xe</var> (exclusive).</li></ol></li><li>Set <var>cap</var>[<var>parenIndex</var> + 1] to <var>s</var>.</li><li>Let <var>z</var> be the State (<var>ye</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"d76db7c5\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>:</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-charactersetmatcher-abstract-operation\"><h1><span class=\"secnum\">21.2.2.8.1</span>#sec-runtime-semantics-charactersetmatcher-abstract-operation Runtime Semantics: CharacterSetMatcher ( A, invert, direction )</h1>...</div><div id=\"excluded-sec-runtime-semantics-canonicalize-ch\"><h1><span class=\"secnum\">21.2.2.8.2</span>#sec-runtime-semantics-canonicalize-ch Runtime Semantics: Canonicalize ( ch )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchproperty-p\"><h1><span class=\"secnum\">21.2.2.8.3</span>#sec-runtime-semantics-unicodematchproperty-p Runtime Semantics: UnicodeMatchProperty ( p )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchpropertyvalue-p-v\"><h1><span class=\"secnum\">21.2.2.8.4</span>#sec-runtime-semantics-unicodematchpropertyvalue-p-v Runtime Semantics: UnicodeMatchPropertyValue ( p, v )</h1>...</div></emu-clause>\n\n      "}, "sec-backreference-matcher": {"num": "21.2.2.9.1", "title": "#sec-backreference-matcher Runtime Semantics: BackreferenceMatcher ( n, direction )", "html": "<emu-clause id=\"sec-backreference-matcher\" aoid=\"BackreferenceMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-backreference-matcher\">#sec-backreference-matcher</span> Runtime Semantics: BackreferenceMatcher ( <var>n</var>, <var>direction</var> )</h1>\n          <p>The abstract operation BackreferenceMatcher takes arguments <var>n</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and <var>direction</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>n</var> and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>s</var> be <var>cap</var>[<var>n</var>].</li><li>If <var>s</var> is <emu-val>undefined</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>len</var> be the number of elements in <var>s</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var> &#215; <var>len</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>g</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>If there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> between 0 (inclusive) and <var>len</var> (exclusive) such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>s</var>[<var>i</var>]) is not the same character value as <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>Input</var>[<var>g</var> + <var>i</var>]), return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>y</var>) and return its result.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-runtime-semantics-repeatmatcher-abstract-operation": {"num": "21.2.2.5.1", "title": "#sec-runtime-semantics-repeatmatcher-abstract-operation Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )", "html": "<emu-clause id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\" aoid=\"RepeatMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\">#sec-runtime-semantics-repeatmatcher-abstract-operation</span> Runtime Semantics: RepeatMatcher ( <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var> )</h1>\n          <p>The abstract operation RepeatMatcher takes arguments <var>m</var> (a Matcher), <var>min</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>max</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> or &#8734;), <var>greedy</var> (a Boolean), <var>x</var> (a State), <var>c</var> (a Continuation), <var>parenIndex</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), and <var>parenCount</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>max</var> is zero, return <var>c</var>(<var>x</var>).</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, and <var>parenCount</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li id=\"step-repeatmatcher-done\">If <var>min</var> is zero and <var>y</var>'s <var>endIndex</var> is equal to <var>x</var>'s <var>endIndex</var>, return <emu-const>failure</emu-const>.</li><li>If <var>min</var> is zero, let <var>min2</var> be zero; otherwise let <var>min2</var> be <var>min</var> - 1.</li><li>If <var>max</var> is &#8734;, let <var>max2</var> be &#8734;; otherwise let <var>max2</var> be <var>max</var> - 1.</li><li>Call <emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>min2</var>, <var>max2</var>, <var>greedy</var>, <var>y</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>) and return its result.</li></ol></li><li>Let <var>cap</var> be a copy of <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li id=\"step-repeatmatcher-clear-captures\">For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>k</var> that satisfies <var>parenIndex</var> &lt; <var>k</var> and <var>k</var> &#8804; <var>parenIndex</var> + <var>parenCount</var>, set <var>cap</var>[<var>k</var>] to <emu-val>undefined</emu-val>.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>xr</var> be the State (<var>e</var>, <var>cap</var>).</li><li>If <var>min</var> is not zero, return <var>m</var>(<var>xr</var>, <var>d</var>).</li><li>If <var>greedy</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>An <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> followed by a <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> is repeated the number of times specified by the <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>. A <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> can be non-greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as many times as possible while still matching the sequel. The <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated rather than the input character sequence that it matches, so different repetitions of the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> can match different input substrings.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>If the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and the sequel of the regular expression all have choice points, the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. All choices in the last (n<sup>th</sup>) repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>; at which point it may turn out that more or fewer repetitions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and so on.</p>\n            <p>Compare</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}/.exec(<span class=\"hljs-string\">\"abcdefghi\"</span>)</code></pre>\n            <p>which returns <emu-val>\"abcde\"</emu-val> with</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}?<span class=\"hljs-regexp\">/.exec(\"abcdefghi\")</span></code></pre>\n            <p>which returns <emu-val>\"abc\"</emu-val>.</p>\n            <p>Consider also</p>\n            <pre><code class=\"javascript hljs\">/(aa|aabaac|ba|b|c)*<span class=\"hljs-regexp\">/.exec(\"aabaac\")</span></code></pre>\n            <p>which, by the choice point ordering above, returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aaba\"</span>, <span class=\"hljs-string\">\"ba\"</span>]</code></pre>\n            <p>and not any of:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"aabaac\"</span>]\n[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>\n            <pre><code class=\"javascript hljs\"><span class=\"hljs-string\">\"aaaaaaaaaa,aaaaaaaaaaaaaaa\"</span>.replace(<span class=\"hljs-regexp\">/^(a+)\\1*,\\1+$/</span>, <span class=\"hljs-string\">\"$1\"</span>)</code></pre>\n            <p>which returns the gcd in unary notation <emu-val>\"aaaaa\"</emu-val>.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>Step <emu-xref href=\"#step-repeatmatcher-clear-captures\"><a href=\"#step-repeatmatcher-clear-captures\" class=\"excluded-xref\" excluded-id=\"step-repeatmatcher-clear-captures\">#step-repeatmatcher-clear-captures</a></emu-xref> of the RepeatMatcher clears <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>'s captures each time <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is repeated. We can see its behaviour in the regular expression</p>\n            <pre><code class=\"javascript hljs\">/(z)((a+)?(b+)?(c))*<span class=\"hljs-regexp\">/.exec(\"zaacbbbcac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>and not</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"bbb\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>because each iteration of the outermost <code>*</code> clears all captured Strings contained in the quantified <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n            <p>Step <emu-xref href=\"#step-repeatmatcher-done\"><a href=\"#step-repeatmatcher-done\">2.b</a></emu-xref> of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>\n            <pre><code class=\"javascript hljs\">/(a*)*<span class=\"hljs-regexp\">/.exec(\"b\")</span></code></pre>\n            <p>or the slightly more complicated:</p>\n            <pre><code class=\"javascript hljs\">/(a*)b\\<span class=\"hljs-number\">1</span>+<span class=\"hljs-regexp\">/.exec(\"baaaac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"\"</span>]</code></pre>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-notation": {"num": "21.2.2.1", "title": "#sec-notation Notation", "html": "<emu-clause id=\"sec-notation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-notation\">#sec-notation</span> Notation</h1>\n        <p>The descriptions below use the following aliases:</p>\n        <ul>\n          <li>\n            <var>Input</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of all of the characters, in order, of the String being matched by the regular expression pattern. Each character is either a code unit or a code point, depending upon the kind of pattern involved. The notation <var>Input</var>[<var>n</var>] means the <var>n</var><sup>th</sup> character of <var>Input</var>, where <var>n</var> can range between 0 (inclusive) and <var>InputLength</var> (exclusive).\n          </li>\n          <li>\n            <var>InputLength</var> is the number of characters in <var>Input</var>.\n          </li>\n          <li>\n            <var>NcapturingParens</var> is the total number of left-capturing parentheses (i.e. the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes) in the pattern. A left-capturing parenthesis is any <code>(</code> pattern character that is matched by the <code>(</code> terminal of the <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> production.\n          </li>\n          <li>\n            <var>DotAll</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"s\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            <var>IgnoreCase</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"i\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            <var>Multiline</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"m\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            <var>Unicode</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"u\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n        </ul>\n        <p>Furthermore, the descriptions below use the following internal data structures:</p>\n        <ul>\n          <li>\n            A <em>CharSet</em> is a mathematical set of characters, either code units or code points depending up the state of the <var>Unicode</var> flag. &#8220;All characters&#8221; means either all code unit values or all code point values also depending upon the state of <var>Unicode</var>.\n          </li>\n          <li>\n            A <em>State</em> is an ordered pair (<var>endIndex</var>, <var>captures</var>) where <var>endIndex</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> and <var>captures</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> values. States are used to represent partial match states in the regular expression matching algorithms. The <var>endIndex</var> is one plus the index of the last input character matched so far by the pattern, while <var>captures</var> holds the results of capturing parentheses. The <var>n</var><sup>th</sup> element of <var>captures</var> is either a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that represents the value obtained by the <var>n</var><sup>th</sup> set of capturing parentheses or <emu-val>undefined</emu-val> if the <var>n</var><sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many States may be in use at any time during the matching process.\n          </li>\n          <li>\n            A <em>MatchResult</em> is either a State or the special token <emu-const>failure</emu-const> that indicates that the match failed.\n          </li>\n          <li>\n            A <em>Continuation</em> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that takes one State argument and returns a MatchResult result. The Continuation attempts to match the remaining portion (specified by the closure's captured values) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. If the match succeeds, the Continuation returns the final State that it reached; if the match fails, the Continuation returns <emu-const>failure</emu-const>.\n          </li>\n          <li>\n            A <em>Matcher</em> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that takes two arguments&#8212;a State and a Continuation&#8212;and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure's captured values) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. The Continuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State, the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as well. If it can, the Matcher returns the State returned by Continuation; if not, the Matcher may try different choices at its choice points, repeatedly calling Continuation until it either succeeds or all possibilities have been exhausted.\n          </li>\n        </ul>\n      </emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-regexpbuiltinexec", "sec-atom", "sec-backreference-matcher", "sec-runtime-semantics-repeatmatcher-abstract-operation", "sec-notation"], "secData": {"sec-regexpbuiltinexec": {"num": "21.2.5.2.2", "title": "#sec-regexpbuiltinexec Runtime Semantics: RegExpBuiltinExec ( R, S )", "html": "<emu-clause id=\"sec-regexpbuiltinexec\" aoid=\"RegExpBuiltinExec\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-regexpbuiltinexec\">#sec-regexpbuiltinexec</span> Runtime Semantics: RegExpBuiltinExec ( <var>R</var>, <var>S</var> )</h1>\n          <p>The abstract operation RegExpBuiltinExec takes arguments <var>R</var> and <var>S</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>R</var> is an initialized RegExp instance.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>S</var>) is String.</li><li>Let <var>length</var> be the number of code units in <var>S</var>.</li><li>Let <var>lastIndex</var> be ?&#160;<emu-xref aoid=\"ToLength\"><a href=\"#sec-tolength\">ToLength</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>)).</li><li>Let <var>flags</var> be <var>R</var>.[[OriginalFlags]].</li><li>If <var>flags</var> contains <emu-val>\"g\"</emu-val>, let <var>global</var> be <emu-val>true</emu-val>; else let <var>global</var> be <emu-val>false</emu-val>.</li><li>If <var>flags</var> contains <emu-val>\"y\"</emu-val>, let <var>sticky</var> be <emu-val>true</emu-val>; else let <var>sticky</var> be <emu-val>false</emu-val>.</li><li>If <var>global</var> is <emu-val>false</emu-val> and <var>sticky</var> is <emu-val>false</emu-val>, set <var>lastIndex</var> to 0.</li><li>Let <var>matcher</var> be <var>R</var>.[[RegExpMatcher]].</li><li>If <var>flags</var> contains <emu-val>\"u\"</emu-val>, let <var>fullUnicode</var> be <emu-val>true</emu-val>; else let <var>fullUnicode</var> be <emu-val>false</emu-val>.</li><li>Let <var>matchSucceeded</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>matchSucceeded</var> is <emu-val>false</emu-val>,<ol><li>If <var>lastIndex</var> &gt; <var>length</var>, then<ol><li>If <var>global</var> is <emu-val>true</emu-val> or <var>sticky</var> is <emu-val>true</emu-val>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>, 0, <emu-val>true</emu-val>).</li></ol></li><li>Return <emu-val>null</emu-val>.</li></ol></li><li>Let <var>r</var> be <var>matcher</var>(<var>S</var>, <var>lastIndex</var>).</li><li>If <var>r</var> is <emu-const>failure</emu-const>, then<ol><li>If <var>sticky</var> is <emu-val>true</emu-val>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>, 0, <emu-val>true</emu-val>).</li><li>Return <emu-val>null</emu-val>.</li></ol></li><li>Set <var>lastIndex</var> to <emu-xref aoid=\"AdvanceStringIndex\"><a href=\"#sec-advancestringindex\">AdvanceStringIndex</a></emu-xref>(<var>S</var>, <var>lastIndex</var>, <var>fullUnicode</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>r</var> is a State.</li><li>Set <var>matchSucceeded</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Let <var>e</var> be <var>r</var>'s <var>endIndex</var> value.</li><li>If <var>fullUnicode</var> is <emu-val>true</emu-val>, then<ol><li><var>e</var> is an index into the <var>Input</var> character list, derived from <var>S</var>, matched by <var>matcher</var>. Let <var>eUTF</var> be the smallest index into <var>S</var> that corresponds to the character at element <var>e</var> of <var>Input</var>. If <var>e</var> is greater than or equal to the number of elements in <var>Input</var>, then <var>eUTF</var> is the number of code units in <var>S</var>.</li><li>Set <var>e</var> to <var>eUTF</var>.</li></ol></li><li>If <var>global</var> is <emu-val>true</emu-val> or <var>sticky</var> is <emu-val>true</emu-val>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>R</var>, <emu-val>\"lastIndex\"</emu-val>, <var>e</var>, <emu-val>true</emu-val>).</li></ol></li><li>Let <var>cap</var> be <var>r</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>NOTE: <var>cap</var> is indexed from 1 (<emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>).</li><li>Let <var>n</var> be the number of elements in <var>cap</var>. (This is the same value as <emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>'s <var>NcapturingParens</var>.)</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> &lt; 2<sup>32</sup> - 1.</li><li>Let <var>A</var> be !&#160;<emu-xref aoid=\"ArrayCreate\"><a href=\"#sec-arraycreate\">ArrayCreate</a></emu-xref>(<var>n</var> + 1).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The value of <var>A</var>'s <emu-val>\"length\"</emu-val> property is <var>n</var> + 1.</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"index\"</emu-val>, <var>lastIndex</var>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"input\"</emu-val>, <var>S</var>).</li><li>Let <var>matchedSubstr</var> be the <emu-xref href=\"#substring\"><a href=\"#substring\">substring</a></emu-xref> of <var>S</var> from <var>lastIndex</var> to <var>e</var>.</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"0\"</emu-val>, <var>matchedSubstr</var>).</li><li>If <var>R</var> contains any <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>, then<ol><li>Let <var>groups</var> be <emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<emu-val>null</emu-val>).</li></ol></li><li>Else,<ol><li>Let <var>groups</var> be <emu-val>undefined</emu-val>.</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, <emu-val>\"groups\"</emu-val>, <var>groups</var>).</li><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> such that <var>i</var> &gt; 0 and <var>i</var> &#8804; <var>n</var>, do<ol><li>Let <var>captureI</var> be <var>cap</var>[<var>i</var>].</li><li>If <var>captureI</var> is <emu-val>undefined</emu-val>, let <var>capturedValue</var> be <emu-val>undefined</emu-val>.</li><li>Else if <var>fullUnicode</var> is <emu-val>true</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>captureI</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of code points.</li><li>Let <var>capturedValue</var> be !&#160;<emu-xref aoid=\"CodePointsToString\"><a href=\"#sec-codepointstostring\">CodePointsToString</a></emu-xref>(<var>captureI</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>fullUnicode</var> is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>captureI</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of code units.</li><li>Let <var>capturedValue</var> be the String value consisting of the code units of <var>captureI</var>.</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>A</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>i</var>), <var>capturedValue</var>).</li><li>If the <var>i</var><sup>th</sup> capture of <var>R</var> was defined with a <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>, then<ol><li>Let <var>s</var> be the StringValue of the corresponding <emu-nt><a href=\"#prod-RegExpIdentifierName\">RegExpIdentifierName</a></emu-nt>.</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>groups</var>, <var>s</var>, <var>capturedValue</var>).</li></ol></li></ol></li><li>Return <var>A</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-atom": {"num": "21.2.2.8", "title": "#sec-atom Atom", "html": "<emu-clause id=\"sec-atom\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atom\">#sec-atom</span> Atom</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"beff52c4\"><emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Let <var>ch</var> be the character matched by <emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9658e473\"><emu-t>.</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>If <var>DotAll</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>A</var> be the set of all characters.</li></ol></li><li>Otherwise, let <var>A</var> be the set of all characters except <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9ce67ea4\"><emu-t>\\</emu-t><emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"66aaa8b9\"><emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt> to obtain a CharSet <var>A</var> and a Boolean <var>invert</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <var>invert</var>, <var>direction</var>) and return its Matcher result.</li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes prior to or enclosing this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>direction</var>, <var>m</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>x</var>, <var>c</var>, <var>direction</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Let <var>cap</var> be a copy of <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>NOTE: <var>cap</var> is indexed from 1 (<emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>).</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>ye</var> be <var>y</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> is equal to +1, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xe</var> &#8804; <var>ye</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>xe</var> (inclusive) through <var>ye</var> (exclusive).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is equal to -1.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ye</var> &#8804; <var>xe</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>ye</var> (inclusive) through <var>xe</var> (exclusive).</li></ol></li><li>Set <var>cap</var>[<var>parenIndex</var> + 1] to <var>s</var>.</li><li>Let <var>z</var> be the State (<var>ye</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and return its result.</li></ol></li></ol></emu-alg>\n        <p>The production <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"d76db7c5\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>:</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-charactersetmatcher-abstract-operation\"><h1><span class=\"secnum\">21.2.2.8.1</span>#sec-runtime-semantics-charactersetmatcher-abstract-operation Runtime Semantics: CharacterSetMatcher ( A, invert, direction )</h1>...</div><div id=\"excluded-sec-runtime-semantics-canonicalize-ch\"><h1><span class=\"secnum\">21.2.2.8.2</span>#sec-runtime-semantics-canonicalize-ch Runtime Semantics: Canonicalize ( ch )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchproperty-p\"><h1><span class=\"secnum\">21.2.2.8.3</span>#sec-runtime-semantics-unicodematchproperty-p Runtime Semantics: UnicodeMatchProperty ( p )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchpropertyvalue-p-v\"><h1><span class=\"secnum\">21.2.2.8.4</span>#sec-runtime-semantics-unicodematchpropertyvalue-p-v Runtime Semantics: UnicodeMatchPropertyValue ( p, v )</h1>...</div></emu-clause>\n\n      "}, "sec-backreference-matcher": {"num": "21.2.2.9.1", "title": "#sec-backreference-matcher Runtime Semantics: BackreferenceMatcher ( n, direction )", "html": "<emu-clause id=\"sec-backreference-matcher\" aoid=\"BackreferenceMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-backreference-matcher\">#sec-backreference-matcher</span> Runtime Semantics: BackreferenceMatcher ( <var>n</var>, <var>direction</var> )</h1>\n          <p>The abstract operation BackreferenceMatcher takes arguments <var>n</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and <var>direction</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>n</var> and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>NOTE: <var>cap</var> is indexed from 1 (<emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>).</li><li>Let <var>s</var> be <var>cap</var>[<var>n</var>].</li><li>If <var>s</var> is <emu-val>undefined</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>len</var> be the number of elements in <var>s</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var> &#215; <var>len</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>g</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>If there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> between 0 (inclusive) and <var>len</var> (exclusive) such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>s</var>[<var>i</var>]) is not the same character value as <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>Input</var>[<var>g</var> + <var>i</var>]), return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>y</var>) and return its result.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-runtime-semantics-repeatmatcher-abstract-operation": {"num": "21.2.2.5.1", "title": "#sec-runtime-semantics-repeatmatcher-abstract-operation Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )", "html": "<emu-clause id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\" aoid=\"RepeatMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\">#sec-runtime-semantics-repeatmatcher-abstract-operation</span> Runtime Semantics: RepeatMatcher ( <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var> )</h1>\n          <p>The abstract operation RepeatMatcher takes arguments <var>m</var> (a Matcher), <var>min</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>max</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> or &#8734;), <var>greedy</var> (a Boolean), <var>x</var> (a State), <var>c</var> (a Continuation), <var>parenIndex</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), and <var>parenCount</var> (an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>max</var> is zero, return <var>c</var>(<var>x</var>).</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, and <var>parenCount</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li id=\"step-repeatmatcher-done\">If <var>min</var> is zero and <var>y</var>'s <var>endIndex</var> is equal to <var>x</var>'s <var>endIndex</var>, return <emu-const>failure</emu-const>.</li><li>If <var>min</var> is zero, let <var>min2</var> be zero; otherwise let <var>min2</var> be <var>min</var> - 1.</li><li>If <var>max</var> is &#8734;, let <var>max2</var> be &#8734;; otherwise let <var>max2</var> be <var>max</var> - 1.</li><li>Call <emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>min2</var>, <var>max2</var>, <var>greedy</var>, <var>y</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>) and return its result.</li></ol></li><li>Let <var>cap</var> be a copy of <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>NOTE: <var>cap</var> is indexed from 1 (<emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>).</li><li id=\"step-repeatmatcher-clear-captures\">For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>k</var> that satisfies <var>parenIndex</var> &lt; <var>k</var> and <var>k</var> &#8804; <var>parenIndex</var> + <var>parenCount</var>, set <var>cap</var>[<var>k</var>] to <emu-val>undefined</emu-val>.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>xr</var> be the State (<var>e</var>, <var>cap</var>).</li><li>If <var>min</var> is not zero, return <var>m</var>(<var>xr</var>, <var>d</var>).</li><li>If <var>greedy</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>An <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> followed by a <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> is repeated the number of times specified by the <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>. A <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> can be non-greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as many times as possible while still matching the sequel. The <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated rather than the input character sequence that it matches, so different repetitions of the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> can match different input substrings.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>If the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and the sequel of the regular expression all have choice points, the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. All choices in the last (n<sup>th</sup>) repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>; at which point it may turn out that more or fewer repetitions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and so on.</p>\n            <p>Compare</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}/.exec(<span class=\"hljs-string\">\"abcdefghi\"</span>)</code></pre>\n            <p>which returns <emu-val>\"abcde\"</emu-val> with</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}?<span class=\"hljs-regexp\">/.exec(\"abcdefghi\")</span></code></pre>\n            <p>which returns <emu-val>\"abc\"</emu-val>.</p>\n            <p>Consider also</p>\n            <pre><code class=\"javascript hljs\">/(aa|aabaac|ba|b|c)*<span class=\"hljs-regexp\">/.exec(\"aabaac\")</span></code></pre>\n            <p>which, by the choice point ordering above, returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aaba\"</span>, <span class=\"hljs-string\">\"ba\"</span>]</code></pre>\n            <p>and not any of:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"aabaac\"</span>]\n[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>\n            <pre><code class=\"javascript hljs\"><span class=\"hljs-string\">\"aaaaaaaaaa,aaaaaaaaaaaaaaa\"</span>.replace(<span class=\"hljs-regexp\">/^(a+)\\1*,\\1+$/</span>, <span class=\"hljs-string\">\"$1\"</span>)</code></pre>\n            <p>which returns the gcd in unary notation <emu-val>\"aaaaa\"</emu-val>.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>Step <emu-xref href=\"#step-repeatmatcher-clear-captures\"><a href=\"#step-repeatmatcher-clear-captures\" class=\"excluded-xref\" excluded-id=\"step-repeatmatcher-clear-captures\">#step-repeatmatcher-clear-captures</a></emu-xref> of the RepeatMatcher clears <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>'s captures each time <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is repeated. We can see its behaviour in the regular expression</p>\n            <pre><code class=\"javascript hljs\">/(z)((a+)?(b+)?(c))*<span class=\"hljs-regexp\">/.exec(\"zaacbbbcac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>and not</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"bbb\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>because each iteration of the outermost <code>*</code> clears all captured Strings contained in the quantified <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n            <p>Step <emu-xref href=\"#step-repeatmatcher-done\"><a href=\"#step-repeatmatcher-done\">2.b</a></emu-xref> of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>\n            <pre><code class=\"javascript hljs\">/(a*)*<span class=\"hljs-regexp\">/.exec(\"b\")</span></code></pre>\n            <p>or the slightly more complicated:</p>\n            <pre><code class=\"javascript hljs\">/(a*)b\\<span class=\"hljs-number\">1</span>+<span class=\"hljs-regexp\">/.exec(\"baaaac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"\"</span>]</code></pre>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-notation": {"num": "21.2.2.1", "title": "#sec-notation Notation", "html": "<emu-clause id=\"sec-notation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-notation\">#sec-notation</span> Notation</h1>\n        <p>The descriptions below use the following aliases:</p>\n        <ul>\n          <li>\n            <var>Input</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of all of the characters, in order, of the String being matched by the regular expression pattern. Each character is either a code unit or a code point, depending upon the kind of pattern involved. The notation <var>Input</var>[<var>n</var>] means the <var>n</var><sup>th</sup> character of <var>Input</var>, where <var>n</var> can range between 0 (inclusive) and <var>InputLength</var> (exclusive).\n          </li>\n          <li>\n            <var>InputLength</var> is the number of characters in <var>Input</var>.\n          </li>\n          <li>\n            <var>NcapturingParens</var> is the total number of left-capturing parentheses (i.e. the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes) in the pattern. A left-capturing parenthesis is any <code>(</code> pattern character that is matched by the <code>(</code> terminal of the <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> production.\n          </li>\n          <li>\n            <var>DotAll</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"s\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            <var>IgnoreCase</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"i\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            <var>Multiline</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"m\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            <var>Unicode</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"u\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          </li>\n        </ul>\n        <p>Furthermore, the descriptions below use the following internal data structures:</p>\n        <ul>\n          <li>\n            A <em>CharSet</em> is a mathematical set of characters, either code units or code points depending up the state of the <var>Unicode</var> flag. &#8220;All characters&#8221; means either all code unit values or all code point values also depending upon the state of <var>Unicode</var>.\n          </li>\n          <li>\n            A <em>State</em> is an ordered pair (<var>endIndex</var>, <var>captures</var>) where <var>endIndex</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> and <var>captures</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>NcapturingParens</var>, indexed 1 through <var>NcapturingParens</var>. States are used to represent partial match states in the regular expression matching algorithms. The <var>endIndex</var> is one plus the index of the last input character matched so far by the pattern, while <var>captures</var> holds the results of capturing parentheses. The element of <var>captures</var> at index <var>n</var> is either a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of characters that represents the value obtained by the <var>n</var><sup>th</sup> set of capturing parentheses or <emu-val>undefined</emu-val> if the <var>n</var><sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many States may be in use at any time during the matching process.\n          </li>\n          <li>\n            A <em>MatchResult</em> is either a State or the special token <emu-const>failure</emu-const> that indicates that the match failed.\n          </li>\n          <li>\n            A <em>Continuation</em> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that takes one State argument and returns a MatchResult result. The Continuation attempts to match the remaining portion (specified by the closure's captured values) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. If the match succeeds, the Continuation returns the final State that it reached; if the match fails, the Continuation returns <emu-const>failure</emu-const>.\n          </li>\n          <li>\n            A <em>Matcher</em> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that takes two arguments&#8212;a State and a Continuation&#8212;and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure's captured values) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. The Continuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State, the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as well. If it can, the Matcher returns the State returned by Continuation; if not, the Matcher may try different choices at its choice points, repeatedly calling Continuation until it either succeeds or all possibilities have been exhausted.\n          </li>\n        </ul>\n      </emu-clause>\n\n      "}}, "figData": {}}}