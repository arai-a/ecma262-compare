{"from": {"secList": ["sec-runtime-semantics-charactersetmatcher-abstract-operation", "sec-compileatom", "sec-compilesubpattern", "sec-backreference-matcher"], "secData": {"sec-runtime-semantics-charactersetmatcher-abstract-operation": {"num": "22.2.2.7.1", "title": "#sec-runtime-semantics-charactersetmatcher-abstract-operation CharacterSetMatcher ( A, invert, direction )", "html": "<emu-clause id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\" type=\"abstract operation\" aoid=\"CharacterSetMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\">#sec-runtime-semantics-charactersetmatcher-abstract-operation</span> CharacterSetMatcher ( <var>A</var>, <var>invert</var>, <var>direction</var> )</h1>\n          <p>The abstract operation CharacterSetMatcher takes arguments <var>A</var> (a CharSet), <var>invert</var> (a Boolean), and <var>direction</var> (1 or -1). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>A</var>, <var>invert</var>, and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>index</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>Let <var>ch</var> be the character <var>Input</var>[<var>index</var>].</li><li>Let <var>cc</var> be <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>ch</var>).</li><li>If there exists a member <var>a</var> of <var>A</var> such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>a</var>) is <var>cc</var>, let <var>found</var> be <emu-val>true</emu-val>. Otherwise, let <var>found</var> be <emu-val>false</emu-val>.</li><li>If <var>invert</var> is <emu-val>false</emu-val> and <var>found</var> is <emu-val>false</emu-val>, return <emu-const>failure</emu-const>.</li><li>If <var>invert</var> is <emu-val>true</emu-val> and <var>found</var> is <emu-val>true</emu-val>, return <emu-const>failure</emu-const>.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>y</var>).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-compileatom": {"num": "22.2.2.7", "title": "#sec-compileatom Runtime Semantics: CompileAtom", "html": "<emu-clause id=\"sec-compileatom\" type=\"sdo\" oldids=\"sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape\" aoid=\"CompileAtom\"><span id=\"sec-decimalescape\"></span><span id=\"sec-characterescape\"></span><span id=\"sec-atomescape\"></span><span id=\"sec-atom\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compileatom\">#sec-compileatom</span> Runtime Semantics: CompileAtom</h1>\n        <p>The syntax-directed operation CompileAtom takes argument <var>direction</var> (1 or -1). It returns a Matcher.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>This section is amended in <emu-xref href=\"#sec-compileatom-annexb\"><a href=\"#sec-compileatom-annexb\" class=\"excluded-xref\" excluded-id=\"sec-compileatom-annexb\">#sec-compileatom-annexb</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <!-- Atom -->\n        <p>It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"vv9sxhyc\" id=\"prod-Js9cL8Bl\"><emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>ch</var> be the character matched by <emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"lljkc4zd\" id=\"prod-HeZ4ZCvZ\"><emu-t>.</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>A</var> be the CharSet of all characters.</li><li>If <var>DotAll</var> is not <emu-val>true</emu-val>, then<ol><li>Remove from <var>A</var> all characters corresponding to a code point on the right-hand side of the <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt> production.</li></ol></li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"zqqoud41\" id=\"prod-lKfl4ziO\"><emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>cc</var> be <emu-xref aoid=\"CompileCharacterClass\"><a href=\"#sec-compilecharacterclass\">CompileCharacterClass</a></emu-xref> of <emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>cc</var>.[[CharSet]], <var>cc</var>.[[Invert]], <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\" id=\"prod-rOrnsPez\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> prior to or enclosing this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>direction</var>, <var>m</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>x</var>, <var>c</var>, <var>direction</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Let <var>cap</var> be a copy of <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>ye</var> be <var>y</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> = 1, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xe</var> &#8804; <var>ye</var>.</li><li>Let <var>s</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>xe</var> (inclusive) through <var>ye</var> (exclusive).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is -1.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ye</var> &#8804; <var>xe</var>.</li><li>Let <var>s</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>ye</var> (inclusive) through <var>xe</var> (exclusive).</li></ol></li><li>Set <var>cap</var>[<var>parenIndex</var> + 1] to <var>s</var>.</li><li>Let <var>z</var> be the State (<var>ye</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>z</var>).</li></ol></li><li>Return <var>m</var>(<var>x</var>, <var>d</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"1223xxig\" id=\"prod-G6MNAyJ9\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>:</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n\n        <!-- AtomEscape -->\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"fr_5bnut\" id=\"prod-cCYT06VF\"><emu-nt><a href=\"#prod-DecimalEscape\">DecimalEscape</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>n</var> be the <emu-xref aoid=\"CapturingGroupNumber\"><a href=\"#sec-patterns-static-semantics-capturing-group-number\">CapturingGroupNumber</a></emu-xref> of <emu-nt><a href=\"#prod-DecimalEscape\">DecimalEscape</a></emu-nt>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> &#8804; <var>NcapturingParens</var>.</li><li>Return !&#160;<emu-xref aoid=\"BackreferenceMatcher\"><a href=\"#sec-backreference-matcher\">BackreferenceMatcher</a></emu-xref>(<var>n</var>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>An escape sequence of the form <code>\\</code> followed by a non-zero decimal number <var>n</var> matches the result of the <var>n</var><sup>th</sup> set of capturing parentheses (<emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>). It is an error if the regular expression has fewer than <var>n</var> capturing parentheses. If the regular expression has <var>n</var> or more capturing parentheses but the <var>n</var><sup>th</sup> one is <emu-val>undefined</emu-val> because it has not captured anything, then the backreference always succeeds.</p>\n        </div></emu-note>\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"fjarvpc8\" id=\"prod-HH-Xi2Q_\"><emu-nt><a href=\"#prod-CharacterEscape\">CharacterEscape</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>cv</var> be the <emu-xref aoid=\"CharacterValue\"><a href=\"#sec-patterns-static-semantics-character-value\">CharacterValue</a></emu-xref> of <emu-nt><a href=\"#prod-CharacterEscape\">CharacterEscape</a></emu-nt>.</li><li>Let <var>ch</var> be the character whose character value is <var>cv</var>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"bww-5j2p\" id=\"prod-k2ESRh0v\"><emu-nt><a href=\"#prod-CharacterClassEscape\">CharacterClassEscape</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>A</var> be <emu-xref aoid=\"CompileToCharSet\"><a href=\"#sec-compiletocharset\">CompileToCharSet</a></emu-xref> of <emu-nt><a href=\"#prod-CharacterClassEscape\">CharacterClassEscape</a></emu-nt>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"dd_xjonr\" id=\"prod-VB-OogXI\">\n        <emu-t>k</emu-t>\n        <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Search the enclosing <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> for an instance of a <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt> containing a <emu-nt><a href=\"#prod-RegExpIdentifierName\">RegExpIdentifierName</a></emu-nt> which has a <emu-xref aoid=\"CapturingGroupName\"><a href=\"#sec-static-semantics-capturinggroupname\">CapturingGroupName</a></emu-xref> equal to the <emu-xref aoid=\"CapturingGroupName\"><a href=\"#sec-static-semantics-capturinggroupname\">CapturingGroupName</a></emu-xref> of the <emu-nt><a href=\"#prod-RegExpIdentifierName\">RegExpIdentifierName</a></emu-nt> contained in <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: A unique such <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt> is found.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of the located <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> prior to or enclosing the located <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>, including its immediately enclosing <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return !&#160;<emu-xref aoid=\"BackreferenceMatcher\"><a href=\"#sec-backreference-matcher\">BackreferenceMatcher</a></emu-xref>(<var>parenIndex</var>, <var>direction</var>).</li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-charactersetmatcher-abstract-operation\"><h1><span class=\"secnum\">22.2.2.7.1</span>#sec-runtime-semantics-charactersetmatcher-abstract-operation CharacterSetMatcher ( A, invert, direction )</h1>...</div><div id=\"excluded-sec-backreference-matcher\"><h1><span class=\"secnum\">22.2.2.7.2</span>#sec-backreference-matcher BackreferenceMatcher ( n, direction )</h1>...</div><div id=\"excluded-sec-runtime-semantics-canonicalize-ch\"><h1><span class=\"secnum\">22.2.2.7.3</span>#sec-runtime-semantics-canonicalize-ch Canonicalize ( ch )</h1>...</div></emu-clause>\n\n      "}, "sec-compilesubpattern": {"num": "22.2.2.3", "title": "#sec-compilesubpattern Runtime Semantics: CompileSubpattern", "html": "<emu-clause id=\"sec-compilesubpattern\" type=\"sdo\" oldids=\"sec-disjunction,sec-alternative,sec-term\" aoid=\"CompileSubpattern\"><span id=\"sec-term\"></span><span id=\"sec-alternative\"></span><span id=\"sec-disjunction\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compilesubpattern\">#sec-compilesubpattern</span> Runtime Semantics: CompileSubpattern</h1>\n        <p>The syntax-directed operation CompileSubpattern takes argument <var>direction</var> (1 or -1). It returns a Matcher.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>This section is amended in <emu-xref href=\"#sec-compilesubpattern-annexb\"><a href=\"#sec-compilesubpattern-annexb\" class=\"excluded-xref\" excluded-id=\"sec-compilesubpattern-annexb\">#sec-compilesubpattern-annexb</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <!-- Disjunction -->\n        <p>It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Disjunction\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"jt2lba_1\" id=\"prod-y4rdvkKA\">\n        <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>\n        <emu-t>|</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m1</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>m2</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>r</var> be <var>m1</var>(<var>x</var>, <var>c</var>).</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <var>r</var>.</li><li>Return <var>m2</var>(<var>x</var>, <var>c</var>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>|</code> regular expression operator separates two alternatives. The pattern first tries to match the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> (followed by the sequel of the regular expression); if it fails, it tries to match the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> (followed by the sequel of the regular expression). If the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. If choices in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> are exhausted, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> is tried instead of the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. Any capturing parentheses inside a portion of the pattern skipped by <code>|</code> produce <emu-val>undefined</emu-val> values instead of Strings. Thus, for example,</p>\n          <pre><code class=\"javascript hljs\">/a|ab/.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the result <emu-val>\"a\"</emu-val> and not <emu-val>\"ab\"</emu-val>. Moreover,</p>\n          <pre><code class=\"javascript hljs\">/((a)|(ab))((c)|(bc))/.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the array</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>]</code></pre>\n          <p>and not</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-literal\">undefined</span>]</code></pre>\n          <p>The order in which the two alternatives are tried is independent of the value of <var>direction</var>.</p>\n        </div></emu-note>\n\n        <!-- Alternative -->\n        <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"n7nathbb\" id=\"prod-DxcBBSWc\"><emu-gann>[empty]</emu-gann></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Return <var>c</var>(<var>x</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"vctbprkq\" id=\"prod-fiPiStf_\">\n        <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>\n        <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m1</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>m2</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> with argument <var>direction</var>.</li><li>If <var>direction</var> = 1, then<ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>c</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>m2</var>(<var>y</var>, <var>c</var>).</li></ol></li><li>Return <var>m1</var>(<var>x</var>, <var>d</var>).</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is -1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>c</var> and <var>m1</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>m1</var>(<var>y</var>, <var>c</var>).</li></ol></li><li>Return <var>m2</var>(<var>x</var>, <var>d</var>).</li></ol></li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>Consecutive <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>s try to simultaneously match consecutive portions of <var>Input</var>. When <var>direction</var> = 1, if the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and all choices in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. When <var>direction</var> = -1, the evaluation order of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> and <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are reversed.</p>\n        </div></emu-note>\n\n        <!-- Term -->\n        <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"4d3cub6p\" id=\"prod-tmSpn0_R\"><emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"CompileAssertion\"><a href=\"#sec-compileassertion\">CompileAssertion</a></emu-xref> of <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n          <p>The resulting Matcher is independent of <var>direction</var>.</p>\n        </div></emu-note>\n        <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"qd3tqxbs\" id=\"prod-fNHoehtY\"><emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"CompileAtom\"><a href=\"#sec-compileatom\">CompileAtom</a></emu-xref> of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"rk7qpcwj\" id=\"prod-LaYcA3Qv\">\n        <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>\n        <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileAtom\"><a href=\"#sec-compileatom\">CompileAtom</a></emu-xref> of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>q</var> be <emu-xref aoid=\"CompileQuantifier\"><a href=\"#sec-compilequantifier\">CompileQuantifier</a></emu-xref> of <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>q</var>.[[Min]] &#8804; <var>q</var>.[[Max]].</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> prior to or enclosing this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>.</li><li>Let <var>parenCount</var> be the number of left-capturing parentheses in <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> enclosed by <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var>, <var>q</var>, <var>parenIndex</var>, and <var>parenCount</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Return !&#160;<emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>q</var>.[[Min]], <var>q</var>.[[Max]], <var>q</var>.[[Greedy]], <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>).</li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-repeatmatcher-abstract-operation\"><h1><span class=\"secnum\">22.2.2.3.1</span>#sec-runtime-semantics-repeatmatcher-abstract-operation RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )</h1>...</div></emu-clause>\n\n      "}, "sec-backreference-matcher": {"num": "22.2.2.7.2", "title": "#sec-backreference-matcher BackreferenceMatcher ( n, direction )", "html": "<emu-clause id=\"sec-backreference-matcher\" type=\"abstract operation\" aoid=\"BackreferenceMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-backreference-matcher\">#sec-backreference-matcher</span> BackreferenceMatcher ( <var>n</var>, <var>direction</var> )</h1>\n          <p>The abstract operation BackreferenceMatcher takes arguments <var>n</var> (a positive <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and <var>direction</var> (1 or -1). It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> &#8805; 1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>n</var> and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>s</var> be <var>cap</var>[<var>n</var>].</li><li>If <var>s</var> is <emu-val>undefined</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>len</var> be the number of elements in <var>s</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var> &#215; <var>len</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>g</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>If there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> between 0 (inclusive) and <var>len</var> (exclusive) such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>s</var>[<var>i</var>]) is not the same character value as <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>Input</var>[<var>g</var> + <var>i</var>]), return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>y</var>).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}, "to": {"secList": ["sec-runtime-semantics-charactersetmatcher-abstract-operation", "sec-compileatom", "sec-compilesubpattern", "sec-backreference-matcher"], "secData": {"sec-runtime-semantics-charactersetmatcher-abstract-operation": {"num": "22.2.2.7.1", "title": "#sec-runtime-semantics-charactersetmatcher-abstract-operation CharacterSetMatcher ( A, invert, direction )", "html": "<emu-clause id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\" type=\"abstract operation\" aoid=\"CharacterSetMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\">#sec-runtime-semantics-charactersetmatcher-abstract-operation</span> CharacterSetMatcher ( <var>A</var>, <var>invert</var>, <var>direction</var> )</h1>\n          <p>The abstract operation CharacterSetMatcher takes arguments <var>A</var> (a CharSet), <var>invert</var> (a Boolean), and <var>direction</var> (<emu-const>forward</emu-const> or <emu-const>backward</emu-const>). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>A</var>, <var>invert</var>, and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> is <emu-const>forward</emu-const>, let <var>f</var> be <var>e</var> + 1.</li><li>Else, let <var>f</var> be <var>e</var> - 1.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>index</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>Let <var>ch</var> be the character <var>Input</var>[<var>index</var>].</li><li>Let <var>cc</var> be <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>ch</var>).</li><li>If there exists a member <var>a</var> of <var>A</var> such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>a</var>) is <var>cc</var>, let <var>found</var> be <emu-val>true</emu-val>. Otherwise, let <var>found</var> be <emu-val>false</emu-val>.</li><li>If <var>invert</var> is <emu-val>false</emu-val> and <var>found</var> is <emu-val>false</emu-val>, return <emu-const>failure</emu-const>.</li><li>If <var>invert</var> is <emu-val>true</emu-val> and <var>found</var> is <emu-val>true</emu-val>, return <emu-const>failure</emu-const>.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>y</var>).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-compileatom": {"num": "22.2.2.7", "title": "#sec-compileatom Runtime Semantics: CompileAtom", "html": "<emu-clause id=\"sec-compileatom\" type=\"sdo\" oldids=\"sec-atom,sec-atomescape,sec-characterescape,sec-decimalescape\" aoid=\"CompileAtom\"><span id=\"sec-decimalescape\"></span><span id=\"sec-characterescape\"></span><span id=\"sec-atomescape\"></span><span id=\"sec-atom\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compileatom\">#sec-compileatom</span> Runtime Semantics: CompileAtom</h1>\n        <p>The syntax-directed operation CompileAtom takes argument <var>direction</var> (<emu-const>forward</emu-const> or <emu-const>backward</emu-const>). It returns a Matcher.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>This section is amended in <emu-xref href=\"#sec-compileatom-annexb\"><a href=\"#sec-compileatom-annexb\" class=\"excluded-xref\" excluded-id=\"sec-compileatom-annexb\">#sec-compileatom-annexb</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <!-- Atom -->\n        <p>It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"vv9sxhyc\" id=\"prod-Js9cL8Bl\"><emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>ch</var> be the character matched by <emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"lljkc4zd\" id=\"prod-HeZ4ZCvZ\"><emu-t>.</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>A</var> be the CharSet of all characters.</li><li>If <var>DotAll</var> is not <emu-val>true</emu-val>, then<ol><li>Remove from <var>A</var> all characters corresponding to a code point on the right-hand side of the <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt> production.</li></ol></li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"zqqoud41\" id=\"prod-lKfl4ziO\"><emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>cc</var> be <emu-xref aoid=\"CompileCharacterClass\"><a href=\"#sec-compilecharacterclass\">CompileCharacterClass</a></emu-xref> of <emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>cc</var>.[[CharSet]], <var>cc</var>.[[Invert]], <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\" id=\"prod-rOrnsPez\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> prior to or enclosing this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>direction</var>, <var>m</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>x</var>, <var>c</var>, <var>direction</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Let <var>cap</var> be a copy of <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>ye</var> be <var>y</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> is <emu-const>forward</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xe</var> &#8804; <var>ye</var>.</li><li>Let <var>s</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>xe</var> (inclusive) through <var>ye</var> (exclusive).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is <emu-const>backward</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ye</var> &#8804; <var>xe</var>.</li><li>Let <var>s</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>ye</var> (inclusive) through <var>xe</var> (exclusive).</li></ol></li><li>Set <var>cap</var>[<var>parenIndex</var> + 1] to <var>s</var>.</li><li>Let <var>z</var> be the State (<var>ye</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>z</var>).</li></ol></li><li>Return <var>m</var>(<var>x</var>, <var>d</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"1223xxig\" id=\"prod-G6MNAyJ9\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>:</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n\n        <!-- AtomEscape -->\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"fr_5bnut\" id=\"prod-cCYT06VF\"><emu-nt><a href=\"#prod-DecimalEscape\">DecimalEscape</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>n</var> be the <emu-xref aoid=\"CapturingGroupNumber\"><a href=\"#sec-patterns-static-semantics-capturing-group-number\">CapturingGroupNumber</a></emu-xref> of <emu-nt><a href=\"#prod-DecimalEscape\">DecimalEscape</a></emu-nt>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> &#8804; <var>NcapturingParens</var>.</li><li>Return !&#160;<emu-xref aoid=\"BackreferenceMatcher\"><a href=\"#sec-backreference-matcher\">BackreferenceMatcher</a></emu-xref>(<var>n</var>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>An escape sequence of the form <code>\\</code> followed by a non-zero decimal number <var>n</var> matches the result of the <var>n</var><sup>th</sup> set of capturing parentheses (<emu-xref href=\"#sec-notation\"><a href=\"#sec-notation\" class=\"excluded-xref\" excluded-id=\"sec-notation\">#sec-notation</a></emu-xref>). It is an error if the regular expression has fewer than <var>n</var> capturing parentheses. If the regular expression has <var>n</var> or more capturing parentheses but the <var>n</var><sup>th</sup> one is <emu-val>undefined</emu-val> because it has not captured anything, then the backreference always succeeds.</p>\n        </div></emu-note>\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"fjarvpc8\" id=\"prod-HH-Xi2Q_\"><emu-nt><a href=\"#prod-CharacterEscape\">CharacterEscape</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>cv</var> be the <emu-xref aoid=\"CharacterValue\"><a href=\"#sec-patterns-static-semantics-character-value\">CharacterValue</a></emu-xref> of <emu-nt><a href=\"#prod-CharacterEscape\">CharacterEscape</a></emu-nt>.</li><li>Let <var>ch</var> be the character whose character value is <var>cv</var>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"bww-5j2p\" id=\"prod-k2ESRh0v\"><emu-nt><a href=\"#prod-CharacterClassEscape\">CharacterClassEscape</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>A</var> be <emu-xref aoid=\"CompileToCharSet\"><a href=\"#sec-compiletocharset\">CompileToCharSet</a></emu-xref> of <emu-nt><a href=\"#prod-CharacterClassEscape\">CharacterClassEscape</a></emu-nt>.</li><li>Return !&#160;<emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"AtomEscape\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"dd_xjonr\" id=\"prod-VB-OogXI\">\n        <emu-t>k</emu-t>\n        <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Search the enclosing <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> for an instance of a <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt> containing a <emu-nt><a href=\"#prod-RegExpIdentifierName\">RegExpIdentifierName</a></emu-nt> which has a <emu-xref aoid=\"CapturingGroupName\"><a href=\"#sec-static-semantics-capturinggroupname\">CapturingGroupName</a></emu-xref> equal to the <emu-xref aoid=\"CapturingGroupName\"><a href=\"#sec-static-semantics-capturinggroupname\">CapturingGroupName</a></emu-xref> of the <emu-nt><a href=\"#prod-RegExpIdentifierName\">RegExpIdentifierName</a></emu-nt> contained in <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: A unique such <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt> is found.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of the located <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> prior to or enclosing the located <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>, including its immediately enclosing <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return !&#160;<emu-xref aoid=\"BackreferenceMatcher\"><a href=\"#sec-backreference-matcher\">BackreferenceMatcher</a></emu-xref>(<var>parenIndex</var>, <var>direction</var>).</li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-charactersetmatcher-abstract-operation\"><h1><span class=\"secnum\">22.2.2.7.1</span>#sec-runtime-semantics-charactersetmatcher-abstract-operation CharacterSetMatcher ( A, invert, direction )</h1>...</div><div id=\"excluded-sec-backreference-matcher\"><h1><span class=\"secnum\">22.2.2.7.2</span>#sec-backreference-matcher BackreferenceMatcher ( n, direction )</h1>...</div><div id=\"excluded-sec-runtime-semantics-canonicalize-ch\"><h1><span class=\"secnum\">22.2.2.7.3</span>#sec-runtime-semantics-canonicalize-ch Canonicalize ( ch )</h1>...</div></emu-clause>\n\n      "}, "sec-compilesubpattern": {"num": "22.2.2.3", "title": "#sec-compilesubpattern Runtime Semantics: CompileSubpattern", "html": "<emu-clause id=\"sec-compilesubpattern\" type=\"sdo\" oldids=\"sec-disjunction,sec-alternative,sec-term\" aoid=\"CompileSubpattern\"><span id=\"sec-term\"></span><span id=\"sec-alternative\"></span><span id=\"sec-disjunction\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compilesubpattern\">#sec-compilesubpattern</span> Runtime Semantics: CompileSubpattern</h1>\n        <p>The syntax-directed operation CompileSubpattern takes argument <var>direction</var> (<emu-const>forward</emu-const> or <emu-const>backward</emu-const>). It returns a Matcher.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>This section is amended in <emu-xref href=\"#sec-compilesubpattern-annexb\"><a href=\"#sec-compilesubpattern-annexb\" class=\"excluded-xref\" excluded-id=\"sec-compilesubpattern-annexb\">#sec-compilesubpattern-annexb</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <!-- Disjunction -->\n        <p>It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Disjunction\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"jt2lba_1\" id=\"prod-y4rdvkKA\">\n        <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>\n        <emu-t>|</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m1</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>m2</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>r</var> be <var>m1</var>(<var>x</var>, <var>c</var>).</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <var>r</var>.</li><li>Return <var>m2</var>(<var>x</var>, <var>c</var>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>|</code> regular expression operator separates two alternatives. The pattern first tries to match the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> (followed by the sequel of the regular expression); if it fails, it tries to match the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> (followed by the sequel of the regular expression). If the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. If choices in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> are exhausted, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> is tried instead of the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. Any capturing parentheses inside a portion of the pattern skipped by <code>|</code> produce <emu-val>undefined</emu-val> values instead of Strings. Thus, for example,</p>\n          <pre><code class=\"javascript hljs\">/a|ab/.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the result <emu-val>\"a\"</emu-val> and not <emu-val>\"ab\"</emu-val>. Moreover,</p>\n          <pre><code class=\"javascript hljs\">/((a)|(ab))((c)|(bc))/.<span class=\"hljs-title function_\">exec</span>(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the array</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>]</code></pre>\n          <p>and not</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-literal\">undefined</span>]</code></pre>\n          <p>The order in which the two alternatives are tried is independent of the value of <var>direction</var>.</p>\n        </div></emu-note>\n\n        <!-- Alternative -->\n        <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"n7nathbb\" id=\"prod-DxcBBSWc\"><emu-gann>[empty]</emu-gann></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Return <var>c</var>(<var>x</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"vctbprkq\" id=\"prod-fiPiStf_\">\n        <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>\n        <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m1</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>m2</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> with argument <var>direction</var>.</li><li>If <var>direction</var> is <emu-const>forward</emu-const>, then<ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>c</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>m2</var>(<var>y</var>, <var>c</var>).</li></ol></li><li>Return <var>m1</var>(<var>x</var>, <var>d</var>).</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is <emu-const>backward</emu-const>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>c</var> and <var>m1</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>m1</var>(<var>y</var>, <var>c</var>).</li></ol></li><li>Return <var>m2</var>(<var>x</var>, <var>d</var>).</li></ol></li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>Consecutive <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>s try to simultaneously match consecutive portions of <var>Input</var>. When <var>direction</var> is <emu-const>forward</emu-const>, if the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and all choices in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. When <var>direction</var> is <emu-const>backward</emu-const>, the evaluation order of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> and <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are reversed.</p>\n        </div></emu-note>\n\n        <!-- Term -->\n        <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"4d3cub6p\" id=\"prod-tmSpn0_R\"><emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"CompileAssertion\"><a href=\"#sec-compileassertion\">CompileAssertion</a></emu-xref> of <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n          <p>The resulting Matcher is independent of <var>direction</var>.</p>\n        </div></emu-note>\n        <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"qd3tqxbs\" id=\"prod-fNHoehtY\"><emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"CompileAtom\"><a href=\"#sec-compileatom\">CompileAtom</a></emu-xref> of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"rk7qpcwj\" id=\"prod-LaYcA3Qv\">\n        <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>\n        <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileAtom\"><a href=\"#sec-compileatom\">CompileAtom</a></emu-xref> of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var>.</li><li>Let <var>q</var> be <emu-xref aoid=\"CompileQuantifier\"><a href=\"#sec-compilequantifier\">CompileQuantifier</a></emu-xref> of <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>q</var>.[[Min]] &#8804; <var>q</var>.[[Max]].</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> prior to or enclosing this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>.</li><li>Let <var>parenCount</var> be the number of left-capturing parentheses in <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"waoim9ah\">\n        <emu-t>(</emu-t>\n        <emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar> <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Nodes</a></emu-xref> enclosed by <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var>, <var>q</var>, <var>parenIndex</var>, and <var>parenCount</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Return !&#160;<emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>q</var>.[[Min]], <var>q</var>.[[Max]], <var>q</var>.[[Greedy]], <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>).</li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-repeatmatcher-abstract-operation\"><h1><span class=\"secnum\">22.2.2.3.1</span>#sec-runtime-semantics-repeatmatcher-abstract-operation RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )</h1>...</div></emu-clause>\n\n      "}, "sec-backreference-matcher": {"num": "22.2.2.7.2", "title": "#sec-backreference-matcher BackreferenceMatcher ( n, direction )", "html": "<emu-clause id=\"sec-backreference-matcher\" type=\"abstract operation\" aoid=\"BackreferenceMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-backreference-matcher\">#sec-backreference-matcher</span> BackreferenceMatcher ( <var>n</var>, <var>direction</var> )</h1>\n          <p>The abstract operation BackreferenceMatcher takes arguments <var>n</var> (a positive <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and <var>direction</var> (<emu-const>forward</emu-const> or <emu-const>backward</emu-const>). It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> &#8805; 1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>n</var> and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>s</var> be <var>cap</var>[<var>n</var>].</li><li>If <var>s</var> is <emu-val>undefined</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>len</var> be the number of elements in <var>s</var>.</li><li>If <var>direction</var> is <emu-const>forward</emu-const>, let <var>f</var> be <var>e</var> + <var>len</var>.</li><li>Else, let <var>f</var> be <var>e</var> - <var>len</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>g</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>If there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> between 0 (inclusive) and <var>len</var> (exclusive) such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>s</var>[<var>i</var>]) is not the same character value as <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>Input</var>[<var>g</var> + <var>i</var>]), return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>y</var>).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}}