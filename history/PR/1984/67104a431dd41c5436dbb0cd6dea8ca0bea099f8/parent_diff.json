{"from": {"secList": ["sec-newpromisereactionjob", "sec-newpromiseresolvethenablejob", "sec-hostenqueuepromisejob", "sec-jobs"], "secData": {"sec-newpromisereactionjob": {"num": "25.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\">\n        <span id=\"sec-promisereactionjob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-newpromiseresolvethenablejob": {"num": "25.6.2.2", "title": "#sec-newpromiseresolvethenablejob NewPromiseResolveThenableJob ( promiseToResolve, thenable, then )", "html": "<emu-clause id=\"sec-newpromiseresolvethenablejob\" aoid=\"NewPromiseResolveThenableJob\" oldids=\"sec-promiseresolvethenablejob\">\n        <span id=\"sec-promiseresolvethenablejob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromiseresolvethenablejob\">#sec-newpromiseresolvethenablejob</span> NewPromiseResolveThenableJob ( <var>promiseToResolve</var>, <var>thenable</var>, <var>then</var> )</h1>\n        <p>The abstract operation NewPromiseResolveThenableJob takes arguments <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var> and performs the following steps when called:<ol><li>Let <var>resolvingFunctions</var> be <emu-xref aoid=\"CreateResolvingFunctions\"><a href=\"#sec-createresolvingfunctions\">CreateResolvingFunctions</a></emu-xref>(<var>promiseToResolve</var>).</li><li>Let <var>thenCallResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>then</var>, <var>thenable</var>, &#171; <var>resolvingFunctions</var>.[[Resolve]], <var>resolvingFunctions</var>.[[Reject]] &#187;).</li><li>If <var>thenCallResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resolvingFunctions</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>thenCallResult</var>.[[Value]] &#187;).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>thenCallResult</var>).</li></ol></li><li>Let <var>getThenRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>then</var>).</li><li>If <var>getThenRealmResult</var> is a normal completion, then let <var>thenRealm</var> be <var>getThenRealmResult</var>.[[Value]].</li><li>Otherwise, let <var>thenRealm</var> be <emu-val>null</emu-val>.</li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>thenRealm</var> }.\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>This <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> uses the supplied thenable and its <code>then</code> method to resolve the given promise. This process must take place as a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> to ensure that the evaluation of the <code>then</code> method occurs after evaluation of any surrounding code has completed.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-hostenqueuepromisejob": {"num": "8.4.1", "title": "#sec-hostenqueuepromisejob HostEnqueuePromiseJob ( job, realm )", "html": "<emu-clause id=\"sec-hostenqueuepromisejob\" aoid=\"HostEnqueuePromiseJob\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-hostenqueuepromisejob\">#sec-hostenqueuepromisejob</span> HostEnqueuePromiseJob ( <var>job</var>, <var>realm</var> )</h1>\n      <p>HostEnqueuePromiseJob is a host-defined abstract operation that schedules the <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> <var>job</var> to be performed, at some future time. The Abstract Closures used with this algorithm are intended to be related to the handling of Promises, or otherwise, to be scheduled with equal priority to Promise handling operations.</p>\n      <p>The <var>realm</var> parameter is passed through to hosts with no normative requirements; it is either <emu-val>null</emu-val> or a <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref>.</p>\n\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        The <var>realm</var> for PromiseResolveThenableJobs is the result of calling <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref> on the <var>then</var> <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>. The <var>realm</var> for PromiseReactionJobs is the result of calling <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref> on the handler if the handler is not <emu-val>undefined</emu-val>. Otherwise the <var>realm</var> is <emu-val>null</emu-val>. The WHATWG HTML specification, for example, uses <var>realm</var> to check for ability to run script and to prepare to run script.\n      \n      </div></emu-note>\n\n      <p>The implementation of HostEnqueuePromiseJob must conform to the requirements in  <emu-xref href=\"#sec-jobs\"><a href=\"#sec-jobs\" class=\"excluded-xref\" excluded-id=\"sec-jobs\">#sec-jobs</a></emu-xref>. Additionally, Jobs must be scheduled in FIFO order, with Jobs running in the same order as the HostEnqueuePromiseJob invocations which scheduled them.</p>\n    </emu-clause>\n  "}, "sec-jobs": {"num": "8.4", "title": "#sec-jobs Jobs and Host Operations to Enqueue Jobs", "html": "<emu-clause id=\"sec-jobs\" oldids=\"sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue\">\n    <span id=\"job-queue\"></span><span id=\"sec-runjobs\"></span><span id=\"sec-enqueuejob\"></span><span id=\"sec-jobs-and-job-queues\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-jobs\">#sec-jobs</span> Jobs and Host Operations to Enqueue Jobs</h1>\n    <p>A  <dfn id=\"job\">Job</dfn> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that initiates an ECMAScript computation when no other ECMAScript computation is currently in progress.</p>\n    <p>Jobs are scheduled for execution by ECMAScript host environments. This specification describes the host hook <emu-xref aoid=\"HostEnqueuePromiseJob\"><a href=\"#sec-hostenqueuepromisejob\">HostEnqueuePromiseJob</a></emu-xref> to schedule one kind of job; host environments may define additional <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> which schedule jobs. Such operations accept a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> as the parameter and schedule it to be performed at some future time. Their implementations must conform to the following requirements:</p>\n\n    <ul>\n      <li>At some future point in time, when there is no <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref> and the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> is empty, the implementation must:\n        \n        <ol>\n          <li>Push an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li>\n          <li>Perform any implementation-defined preparation steps.</li>\n          <li>Call the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref>.</li>\n          <li>Perform any implementation-defined cleanup steps.</li>\n          <li>Pop the previously-pushed <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li>\n        </ol>\n      </li>\n      <li>Only one <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> may be actively undergoing evaluation at any point in time.</li>\n      <li>Once evaluation of a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> starts, it must run to completion before evaluation of any other <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> starts.</li>\n      <li>The <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> must return a normal completion, implementing its own handling of errors.</li>\n    </ul>\n\n    <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n      <p>Host environments are not required to treat Jobs uniformly with respect to scheduling. For example, web browsers and Node.js treat Promise-handling Jobs as a higher priority than other work; future features may add Jobs that are not treated at such a high priority.</p>\n    </div></emu-note>\n\n    <div id=\"excluded-sec-hostenqueuepromisejob\"><h1><span class=\"secnum\">8.4.1</span>#sec-hostenqueuepromisejob HostEnqueuePromiseJob ( job, realm )</h1>...</div></emu-clause>\n\n  "}}, "figData": {}}, "to": {"secList": ["sec-newpromisereactionjob", "sec-newpromiseresolvethenablejob", "sec-hostenqueuepromisejob", "sec-jobs"], "secData": {"sec-newpromisereactionjob": {"num": "25.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\">\n        <span id=\"sec-promisereactionjob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li><li>Else, set <var>handlerRealm</var> to <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>.</li><li>NOTE: <var>handlerRealm</var> is never <emu-val>null</emu-val> when the handler is not <emu-val>undefined</emu-val>. When the handler is a revoked Proxy and no code runs, <var>handlerRealm</var> is used to create error objects.</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.\n        </li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-newpromiseresolvethenablejob": {"num": "25.6.2.2", "title": "#sec-newpromiseresolvethenablejob NewPromiseResolveThenableJob ( promiseToResolve, thenable, then )", "html": "<emu-clause id=\"sec-newpromiseresolvethenablejob\" aoid=\"NewPromiseResolveThenableJob\" oldids=\"sec-promiseresolvethenablejob\">\n        <span id=\"sec-promiseresolvethenablejob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromiseresolvethenablejob\">#sec-newpromiseresolvethenablejob</span> NewPromiseResolveThenableJob ( <var>promiseToResolve</var>, <var>thenable</var>, <var>then</var> )</h1>\n        <p>The abstract operation NewPromiseResolveThenableJob takes arguments <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var> and performs the following steps when called:<ol><li>Let <var>resolvingFunctions</var> be <emu-xref aoid=\"CreateResolvingFunctions\"><a href=\"#sec-createresolvingfunctions\">CreateResolvingFunctions</a></emu-xref>(<var>promiseToResolve</var>).</li><li>Let <var>thenCallResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>then</var>, <var>thenable</var>, &#171; <var>resolvingFunctions</var>.[[Resolve]], <var>resolvingFunctions</var>.[[Reject]] &#187;).</li><li>If <var>thenCallResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resolvingFunctions</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>thenCallResult</var>.[[Value]] &#187;).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>thenCallResult</var>).</li></ol></li><li>Let <var>getThenRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>then</var>).</li><li>If <var>getThenRealmResult</var> is a normal completion, then let <var>thenRealm</var> be <var>getThenRealmResult</var>.[[Value]].</li><li>Else, let <var>thenRealm</var> be <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>.</li><li>NOTE: <var>thenRealm</var> is never <emu-val>null</emu-val>. When <var>then</var> is a revoked Proxy and no code runs, <var>thenRealm</var> is used to create error objects.</li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>thenRealm</var> }.\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>This <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> uses the supplied thenable and its <code>then</code> method to resolve the given promise. This process must take place as a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> to ensure that the evaluation of the <code>then</code> method occurs after evaluation of any surrounding code has completed.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-hostenqueuepromisejob": {"num": "8.4.1", "title": "#sec-hostenqueuepromisejob HostEnqueuePromiseJob ( job, realm )", "html": "<emu-clause id=\"sec-hostenqueuepromisejob\" aoid=\"HostEnqueuePromiseJob\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-hostenqueuepromisejob\">#sec-hostenqueuepromisejob</span> HostEnqueuePromiseJob ( <var>job</var>, <var>realm</var> )</h1>\n      <p>HostEnqueuePromiseJob is a host-defined abstract operation that schedules the <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> <var>job</var> to be performed, at some future time. The Abstract Closures used with this algorithm are intended to be related to the handling of Promises, or otherwise, to be scheduled with equal priority to Promise handling operations.</p>\n      <p>The <var>realm</var> parameter is either <emu-val>null</emu-val> or a <emu-xref href=\"#realm-record\"><a href=\"#realm-record\">Realm Record</a></emu-xref>.</p>\n\n      <p>The implementation of HostEnqueuePromiseJob must conform to the requirements in  <emu-xref href=\"#sec-jobs\"><a href=\"#sec-jobs\" class=\"excluded-xref\" excluded-id=\"sec-jobs\">#sec-jobs</a></emu-xref>. Additionally, Jobs enqueued by this hook must conform to all of the following requirements:</p>\n      <ul>\n        <li>If <var>realm</var> is not <emu-val>null</emu-val>, the implementation must perform implementation-defined steps such that <var>job</var> is <emu-xref href=\"#job-preparedtoevaluatecode\"><a href=\"#job-preparedtoevaluatecode\">prepared to evaluate code</a></emu-xref>.</li>\n        <li>Let <var>scriptOrModule</var> be <emu-xref aoid=\"GetActiveScriptOrModule\"><a href=\"#sec-getactivescriptormodule\">GetActiveScriptOrModule</a></emu-xref>(). The implementation must perform implementation-defined steps such that <var>job</var> <emu-xref href=\"#job-propagatesactivescriptormodule\"><a href=\"#job-propagatesactivescriptormodule\">propagates the script or module</a></emu-xref> <var>scriptOrModule</var>.</li>\n        <li>Jobs must be scheduled in FIFO order, with Jobs running in the same order as the HostEnqueuePromiseJob invocations which scheduled them.</li>\n      </ul>\n\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <var>realm</var> for PromiseResolveThenableJobs is usually the result of calling <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref> on the <var>then</var> <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>. The <var>realm</var> for PromiseReactionJobs is usually the result of calling <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref> on the handler if the handler is not <emu-val>undefined</emu-val>. When the <var>realm</var> is <emu-val>null</emu-val> due to being called on a revoked Proxy, the current <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> at the time of the <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref> call is used instead. When the <var>realm</var> is <emu-val>null</emu-val> and no user ECMAScript code will be evaluated, and no new ECMAScript objects (e.g. Error objects) will be created. The WHATWG HTML specification, for example, uses <var>realm</var> to check for ability to run script and for the  <a href=\"https://html.spec.whatwg.org/#entry\">entry</a> concept.</p>\n        <p>The script or module that <var>job</var> propagates may be <emu-val>null</emu-val>.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-jobs": {"num": "8.4", "title": "#sec-jobs Jobs and Host Operations to Enqueue Jobs", "html": "<emu-clause id=\"sec-jobs\" oldids=\"sec-jobs-and-job-queues,sec-enqueuejob,sec-runjobs,job-queue\">\n    <span id=\"job-queue\"></span><span id=\"sec-runjobs\"></span><span id=\"sec-enqueuejob\"></span><span id=\"sec-jobs-and-job-queues\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-jobs\">#sec-jobs</span> Jobs and Host Operations to Enqueue Jobs</h1>\n    <p>A  <dfn id=\"job\">Job</dfn> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that initiates an ECMAScript computation when no other ECMAScript computation is currently in progress.</p>\n    <p>Jobs are scheduled for execution by ECMAScript host environments. This specification describes the host hook <emu-xref aoid=\"HostEnqueuePromiseJob\"><a href=\"#sec-hostenqueuepromisejob\">HostEnqueuePromiseJob</a></emu-xref> to schedule one kind of job; host environments may define additional <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> which schedule jobs. Such operations accept a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> as the parameter and schedule it to be performed at some future time. Their implementations must conform to the following requirements:</p>\n\n    <ul>\n      <li>At some future point in time, when there is no <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref> and the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> is empty, the implementation must perform the following:\n        \n        <ol>\n          <li>Perform any implementation-defined preparation steps.</li>\n          <li>Call the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref>.</li>\n          <li>Perform any implementation-defined cleanup steps.</li>\n          <li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> is empty.</li>\n        </ol>\n      </li>\n      <li>Only one <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> may be actively undergoing evaluation at any point in time.</li>\n      <li>Once evaluation of a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> starts, it must run to completion before evaluation of any other <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> starts.</li>\n      <li>The <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> must return a normal completion, implementing its own handling of errors.</li>\n    </ul>\n\n    <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n      Host environments are not required to treat Jobs uniformly with respect to scheduling. For example, web browsers and Node.js treat Promise-handling Jobs as a higher priority than other work; future features may add Jobs that are not treated at such a high priority.\n    \n    </div></emu-note>\n\n    <p>A <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <var>job</var>  <dfn id=\"job-propagatesactivescriptormodule\">propagates the script or module</dfn> <var>scriptOrModule</var> (a <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref>, a <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, or <emu-val>null</emu-val>) if all of the following conditions are true whenever <var>job</var> is called:</p>\n    <ul>\n      <li><emu-xref aoid=\"GetActiveScriptOrModule\"><a href=\"#sec-getactivescriptormodule\">GetActiveScriptOrModule</a></emu-xref>() is <var>scriptOrModule</var>.</li>\n      <li>If <var>scriptOrModule</var> is a <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> or <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, let <var>ec</var> be the topmost <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> on the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> whose ScriptOrModule component is <var>scriptOrModule</var>. The <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> component of <var>ec</var> is <var>scriptOrModule</var>.[[Realm]].</li>\n    </ul>\n\n    <p>A <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <var>job</var> is  <dfn id=\"job-preparedtoevaluatecode\">prepared to evaluate code</dfn> if all of the following conditions are true whenever <var>job</var> is called:</p>\n    <ul>\n      <li>The <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> is not empty.</li>\n      <li>The <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> component of the topmost <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> on the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> is a <emu-xref href=\"#realm-record\"><a href=\"#realm-record\">Realm Record</a></emu-xref>.</li>\n    </ul>\n\n    <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n      <p>Host environments may prepare an execution to evaluate code by pushing execution contexts onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>. The specific steps are implementation-defined.</p>\n      <p>The specific choice of <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> is up to the host environment. This initial <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> and <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> is only in use before any callback function is invoked. When a callback function related to a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref>, like a Promise handler, is invoked, the invocation pushes its own <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> and <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref>.</p>\n    </div></emu-note>\n\n    <p>Particular kinds of Jobs have additional conformance requirements.</p>\n\n    <div id=\"excluded-sec-hostenqueuepromisejob\"><h1><span class=\"secnum\">8.4.1</span>#sec-hostenqueuepromisejob HostEnqueuePromiseJob ( job, realm )</h1>...</div></emu-clause>\n\n  "}}, "figData": {}}}