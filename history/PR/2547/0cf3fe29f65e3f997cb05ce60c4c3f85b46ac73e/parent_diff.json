{"from": {"secList": ["sec-numeric-types-number-tostring", "sec-ecmascript-language-types-bigint-type", "sec-numeric-types", "sec-implicit-completion-values", "sec-bigintbitwiseop", "sec-numeric-types-bigint-remainder", "sec-numeric-types-bigint-unsignedRightShift", "sec-issuperreference", "sec-prefix-decrement-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-unaryMinus", "sec-numberbitwiseop", "sec-numeric-types-bigint-exponentiate", "sec-numeric-types-bigint-add", "sec-makeprivatereference", "sec-numeric-types-number-sameValue", "sec-ecmascript-language-types-number-type", "sec-bitwise-not-operator-runtime-semantics-evaluation", "sec-topropertydescriptor", "sec-isaccessordescriptor", "sec-islessthan", "sec-frompropertydescriptor", "sec-gather-available-ancestors", "sec-numeric-types-bigint-multiply", "sec-numeric-types-bigint-signedRightShift", "sec-numeric-types-number-bitwiseAND", "sec-createsharedbytedatablock", "sec-binaryor", "sec-prefix-increment-operator-runtime-semantics-evaluation", "sec-atomics.sub", "sec-updateempty", "sec-numeric-types-number-unsignedRightShift", "sec-execute-async-module", "sec-copydatablockbytes", "sec-numeric-types-number-lessThan", "sec-numeric-types-bigint-subtract", "sec-throwcompletion", "sec-numeric-types-number-add", "sec-numeric-types-number-equal", "sec-initializereferencedbinding", "sec-binaryxor", "sec-numeric-types-bigint-bitwiseXOR", "sec-completion-record-specification-type", "sec-ispropertyreference", "sec-isdatadescriptor", "sec-numeric-types-number-bitwiseNOT", "sec-getvalue", "sec-normalcompletion", "sec-asyncblockstart", "sec-stringindexof", "sec-completepropertydescriptor", "sec-numeric-types-bigint-divide", "sec-numeric-types-number-bitwiseOR", "sec-postfix-increment-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-leftShift", "sec-numeric-types-number-multiply", "sec-samevalue", "sec-numeric-types-bigint-lessThan", "sec-isgenericdescriptor", "sec-runtime-semantics", "sec-async-module-execution-rejected", "sec-createbytedatablock", "sec-getthisvalue", "sec-numeric-types-bigint-bitwiseAND", "sec-numeric-types-bigint-sameValueZero", "sec-async-module-execution-fulfilled", "sec-static-semantics-classelementevaluation", "sec-putvalue", "sec-numeric-types-number-subtract", "sec-importedlocalnames", "sec-isstrictlyequal", "sec-applystringornumericbinaryoperator", "sec-isunresolvablereference", "sec-numeric-types-number-sameValueZero", "sec-toprimitive", "sec-binaryand", "sec-numeric-types-number-leftShift", "sec-numeric-types-number-unaryMinus", "sec-atomics.add", "sec-numeric-types-number-divide", "sec-asyncgeneratordrainqueue", "sec-postfix-decrement-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-bitwiseNOT", "sec-numeric-types-number-remainder", "sec-numeric-types-number-signedRightShift", "sec-isprivatereference", "sec-samevaluezero", "sec-numeric-types-number-exponentiate", "sec-unary-minus-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-sameValue", "sec-numeric-types-number-bitwiseXOR", "sec-numeric-types-bigint-bitwiseOR", "sec-numeric-types-bigint-tostring", "sec-numeric-types-bigint-equal"], "secData": {"sec-numeric-types-number-tostring": {"num": "6.1.6.1.20", "title": "#sec-numeric-types-number-tostring Number::toString ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-tostring\" type=\"numeric method\" oldids=\"sec-tostring-applied-to-the-number-type\" aoid=\"Number::toString\"><span id=\"sec-tostring-applied-to-the-number-type\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-tostring\">#sec-numeric-types-number-tostring</span> Number::toString ( <var>x</var> )</h1>\n          <p>The abstract operation Number::toString takes argument <var>x</var> (a Number). It converts <var>x</var> to String format. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return the String <emu-val>\"NaN\"</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <emu-val>-0</emu-val><sub>&#120125;</sub>, return the String <emu-val>\"0\"</emu-val>.</li><li>If <var>x</var> &lt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of <emu-val>\"-\"</emu-val> and ! <emu-xref aoid=\"Number::toString\"><a href=\"#sec-numeric-types-number-tostring\">Number::toString</a></emu-xref>(-<var>x</var>).</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return the String <emu-val>\"Infinity\"</emu-val>.</li><li id=\"step-number-tostring-intermediate-values\">Otherwise, let <var>n</var>, <var>k</var>, and <var>s</var> be <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> such that <var>k</var> &#8805; 1, 10<sup><var>k</var> - 1</sup> &#8804; <var>s</var> &lt; 10<sup><var>k</var></sup>, <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>s</var> &#215; 10<sup><var>n</var> - <var>k</var></sup>) is <var>x</var>, and <var>k</var> is as small as possible. Note that <var>k</var> is the number of digits in the decimal representation of <var>s</var>, that <var>s</var> is not divisible by 10, and that the least significant digit of <var>s</var> is not necessarily uniquely determined by these criteria.</li><li>If <var>k</var> &#8804; <var>n</var> &#8804; 21, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code units of the <var>k</var> digits of the decimal representation of <var>s</var> (in order, with no leading zeroes)</li><li><var>n</var> - <var>k</var> occurrences of the code unit 0x0030 (DIGIT ZERO)</li></ul></li><li>If 0 &lt; <var>n</var> &#8804; 21, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code units of the most significant <var>n</var> digits of the decimal representation of <var>s</var></li><li>the code unit 0x002E (FULL STOP)</li><li>the code units of the remaining <var>k</var> - <var>n</var> digits of the decimal representation of <var>s</var></li></ul></li><li>If -6 &lt; <var>n</var> &#8804; 0, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code unit 0x0030 (DIGIT ZERO)</li><li>the code unit 0x002E (FULL STOP)</li><li>-<var>n</var> occurrences of the code unit 0x0030 (DIGIT ZERO)</li><li>the code units of the <var>k</var> digits of the decimal representation of <var>s</var></li></ul></li><li>Otherwise, if <var>k</var> = 1, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code unit of the single digit of <var>s</var></li><li>the code unit 0x0065 (LATIN SMALL LETTER E)</li><li>the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether <var>n</var> - 1 is positive or negative</li><li>the code units of the decimal representation of the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>n</var> - 1) (with no leading zeroes)</li></ul></li><li>Return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code units of the most significant digit of the decimal representation of <var>s</var></li><li>the code unit 0x002E (FULL STOP)</li><li>the code units of the remaining <var>k</var> - 1 digits of the decimal representation of <var>s</var></li><li>the code unit 0x0065 (LATIN SMALL LETTER E)</li><li>the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether <var>n</var> - 1 is positive or negative</li><li>the code units of the decimal representation of the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>n</var> - 1) (with no leading zeroes)</li></ul></li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:</p>\n            <ul>\n              <li>\n                If x is any <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> other than <emu-val>-0</emu-val><sub>&#120125;</sub>, then <emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(x)) is exactly the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as x.\n              </li>\n              <li>\n                The least significant digit of s is not always uniquely determined by the requirements listed in step <emu-xref href=\"#step-number-tostring-intermediate-values\"><a href=\"#step-number-tostring-intermediate-values\" class=\"excluded-xref\" excluded-id=\"step-number-tostring-intermediate-values\">#step-number-tostring-intermediate-values</a></emu-xref>.\n              </li>\n            </ul>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step <emu-xref href=\"#step-number-tostring-intermediate-values\"><a href=\"#step-number-tostring-intermediate-values\" class=\"excluded-xref\" excluded-id=\"step-number-tostring-intermediate-values\">#step-number-tostring-intermediate-values</a></emu-xref> be used as a guideline:</p>\n            <emu-alg replaces-step=\"step-number-tostring-intermediate-values\"><ol start=\"5\"><li>Otherwise, let <var>n</var>, <var>k</var>, and <var>s</var> be <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> such that <var>k</var> &#8805; 1, 10<sup><var>k</var> - 1</sup> &#8804; <var>s</var> &lt; 10<sup><var>k</var></sup>, <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>s</var> &#215; 10<sup><var>n</var> - <var>k</var></sup>) is <var>x</var>, and <var>k</var> is as small as possible. If there are multiple possibilities for <var>s</var>, choose the value of <var>s</var> for which <var>s</var> &#215; 10<sup><var>n</var> - <var>k</var></sup> is closest in value to <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>). If there are two such possible values of <var>s</var>, choose the one that is even. Note that <var>k</var> is the number of digits in the decimal representation of <var>s</var> and that <var>s</var> is not divisible by 10.</li></ol></emu-alg>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:</p>\n            <p>Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). 30 November 1990. Available as\n              <br>\n              <a href=\"http://ampl.com/REFS/abstracts.html#rounding\">http://ampl.com/REFS/abstracts.html#rounding</a>. Associated code available as\n              <br>\n              <a href=\"http://netlib.sandia.gov/fp/dtoa.c\">http://netlib.sandia.gov/fp/dtoa.c</a> and as\n              <br>\n              <a href=\"http://netlib.sandia.gov/fp/g_fmt.c\">http://netlib.sandia.gov/fp/g_fmt.c</a> and may also be found at the various <code>netlib</code> mirror sites.</p>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-ecmascript-language-types-bigint-type": {"num": "6.1.6.2", "title": "#sec-ecmascript-language-types-bigint-type The BigInt Type", "html": "<emu-clause id=\"sec-ecmascript-language-types-bigint-type\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-language-types-bigint-type\">#sec-ecmascript-language-types-bigint-type</span> The BigInt Type</h1>\n        <p>The BigInt type represents an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value. The value may be any size and is not limited to a particular bit-width. Generally, where not otherwise noted, operations are designed to return exact mathematically-based answers. For binary operations, BigInts act as two's complement binary strings, with negative numbers treated as having bits set infinitely to the left.</p>\n\n        <p>The BigInt::unit value is <emu-val>1</emu-val><sub>&#8484;</sub>.</p>\n\n        <div id=\"excluded-sec-numeric-types-bigint-unaryMinus\"><h1><span class=\"secnum\">6.1.6.2.1</span>#sec-numeric-types-bigint-unaryMinus BigInt::unaryMinus ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseNOT\"><h1><span class=\"secnum\">6.1.6.2.2</span>#sec-numeric-types-bigint-bitwiseNOT BigInt::bitwiseNOT ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-exponentiate\"><h1><span class=\"secnum\">6.1.6.2.3</span>#sec-numeric-types-bigint-exponentiate BigInt::exponentiate ( base, exponent )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-multiply\"><h1><span class=\"secnum\">6.1.6.2.4</span>#sec-numeric-types-bigint-multiply BigInt::multiply ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-divide\"><h1><span class=\"secnum\">6.1.6.2.5</span>#sec-numeric-types-bigint-divide BigInt::divide ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-remainder\"><h1><span class=\"secnum\">6.1.6.2.6</span>#sec-numeric-types-bigint-remainder BigInt::remainder ( n, d )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-add\"><h1><span class=\"secnum\">6.1.6.2.7</span>#sec-numeric-types-bigint-add BigInt::add ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-subtract\"><h1><span class=\"secnum\">6.1.6.2.8</span>#sec-numeric-types-bigint-subtract BigInt::subtract ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-leftShift\"><h1><span class=\"secnum\">6.1.6.2.9</span>#sec-numeric-types-bigint-leftShift BigInt::leftShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-signedRightShift\"><h1><span class=\"secnum\">6.1.6.2.10</span>#sec-numeric-types-bigint-signedRightShift BigInt::signedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-unsignedRightShift\"><h1><span class=\"secnum\">6.1.6.2.11</span>#sec-numeric-types-bigint-unsignedRightShift BigInt::unsignedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-lessThan\"><h1><span class=\"secnum\">6.1.6.2.12</span>#sec-numeric-types-bigint-lessThan BigInt::lessThan ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-equal\"><h1><span class=\"secnum\">6.1.6.2.13</span>#sec-numeric-types-bigint-equal BigInt::equal ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-sameValue\"><h1><span class=\"secnum\">6.1.6.2.14</span>#sec-numeric-types-bigint-sameValue BigInt::sameValue ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-sameValueZero\"><h1><span class=\"secnum\">6.1.6.2.15</span>#sec-numeric-types-bigint-sameValueZero BigInt::sameValueZero ( x, y )</h1>...</div><div id=\"excluded-sec-binaryand\"><h1><span class=\"secnum\">6.1.6.2.16</span>#sec-binaryand BinaryAnd ( x, y )</h1>...</div><div id=\"excluded-sec-binaryor\"><h1><span class=\"secnum\">6.1.6.2.17</span>#sec-binaryor BinaryOr ( x, y )</h1>...</div><div id=\"excluded-sec-binaryxor\"><h1><span class=\"secnum\">6.1.6.2.18</span>#sec-binaryxor BinaryXor ( x, y )</h1>...</div><div id=\"excluded-sec-bigintbitwiseop\"><h1><span class=\"secnum\">6.1.6.2.19</span>#sec-bigintbitwiseop BigIntBitwiseOp ( op, x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseAND\"><h1><span class=\"secnum\">6.1.6.2.20</span>#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseXOR\"><h1><span class=\"secnum\">6.1.6.2.21</span>#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseOR\"><h1><span class=\"secnum\">6.1.6.2.22</span>#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-tostring\"><h1><span class=\"secnum\">6.1.6.2.23</span>#sec-numeric-types-bigint-tostring BigInt::toString ( x )</h1>...</div></emu-clause>\n    "}, "sec-numeric-types": {"num": "6.1.6", "title": "#sec-numeric-types Numeric Types", "html": "<emu-clause id=\"sec-numeric-types\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types\">#sec-numeric-types</span> Numeric Types</h1>\n      <p>ECMAScript has two built-in numeric types: Number and BigInt. In this specification, every numeric type <var>T</var> contains a multiplicative identity value denoted <var>T</var>::unit. The specification types also have the following <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref>, likewise denoted <var>T</var>::<i>op</i> for a given operation with specification name <i>op</i>. All argument types are <var>T</var>. The \"Result\" column shows the return type, along with an indication if it is possible for some invocations of the operation to return an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</p>\n      <emu-table id=\"table-numeric-type-ops\" caption=\"Numeric Type Operations\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-numeric-type-ops\">#table-numeric-type-ops</span>: Numeric Type Operations</figcaption>\n        <table>\n          <tbody>\n          <tr>\n            <th>\n              Invocation Synopsis\n            </th>\n            <th>\n              Example source\n            </th>\n            <th>\n              Invoked by the Evaluation semantics of ...\n            </th>\n            <th>\n              Result\n            </th>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::unaryMinus(x)\n            </td>\n            <td>\n              <code>-x</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-unary-minus-operator\" title=\"\"><a href=\"#sec-unary-minus-operator\">Unary <code>-</code> Operator</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::bitwiseNOT(x)\n            </td>\n            <td>\n              <code>~x</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-bitwise-not-operator\" title=\"\"><a href=\"#sec-bitwise-not-operator\">Bitwise NOT Operator ( <code>~</code> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::exponentiate(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;**&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-exp-operator\" title=\"\"><a href=\"#sec-exp-operator\">Exponentiation Operator</a></emu-xref>\n              and <emu-xref href=\"#sec-math.pow\" title=\"\"><a href=\"#sec-math.pow\">Math.pow ( <var>base</var>, <var>exponent</var> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>, may throw <emu-val>RangeError</emu-val>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::multiply(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;*&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-multiplicative-operators\" title=\"\"><a href=\"#sec-multiplicative-operators\">Multiplicative Operators</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::divide(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;/&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-multiplicative-operators\" title=\"\"><a href=\"#sec-multiplicative-operators\">Multiplicative Operators</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>, may throw <emu-val>RangeError</emu-val>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::remainder(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;%&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-multiplicative-operators\" title=\"\"><a href=\"#sec-multiplicative-operators\">Multiplicative Operators</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>, may throw <emu-val>RangeError</emu-val>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::add(x,&#160;y)\n            </td>\n            <td>\n              <code>x ++</code><br><code>++ x</code><br><code>x&#160;+&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-postfix-increment-operator\" title=\"\"><a href=\"#sec-postfix-increment-operator\">Postfix Increment Operator</a></emu-xref>,\n              <emu-xref href=\"#sec-prefix-increment-operator\" title=\"\"><a href=\"#sec-prefix-increment-operator\">Prefix Increment Operator</a></emu-xref>,\n              and <emu-xref href=\"#sec-addition-operator-plus\" title=\"\"><a href=\"#sec-addition-operator-plus\">The Addition Operator ( <code>+</code> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::subtract(x,&#160;y)\n            </td>\n            <td>\n              <code>x --</code><br><code>-- x</code><br><code>x&#160;-&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-postfix-decrement-operator\" title=\"\"><a href=\"#sec-postfix-decrement-operator\">Postfix Decrement Operator</a></emu-xref>,\n              <emu-xref href=\"#sec-prefix-decrement-operator\" title=\"\"><a href=\"#sec-prefix-decrement-operator\">Prefix Decrement Operator</a></emu-xref>,\n              and <emu-xref href=\"#sec-subtraction-operator-minus\" title=\"\"><a href=\"#sec-subtraction-operator-minus\">The Subtraction Operator ( <code>-</code> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::leftShift(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;&lt;&lt;&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-left-shift-operator\" title=\"\"><a href=\"#sec-left-shift-operator\">The Left Shift Operator ( <code>&lt;&lt;</code> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::signedRightShift(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;&gt;&gt;&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-signed-right-shift-operator\" title=\"\"><a href=\"#sec-signed-right-shift-operator\">The Signed Right Shift Operator ( <code>&gt;&gt;</code> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::unsignedRightShift(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;&gt;&gt;&gt;&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-unsigned-right-shift-operator\" title=\"\"><a href=\"#sec-unsigned-right-shift-operator\">The Unsigned Right Shift Operator ( <code>&gt;&gt;&gt;</code> )</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>, may throw <emu-val>TypeError</emu-val>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::lessThan(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;&lt;&#160;y</code><br><code>x&#160;&gt;&#160;y</code><br><code>x&#160;&lt;=&#160;y</code><br><code>x&#160;&gt;=&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-relational-operators\" title=\"\"><a href=\"#sec-relational-operators\">Relational Operators</a></emu-xref>,\n              via <emu-xref href=\"#sec-islessthan\" title=\"\"><a href=\"#sec-islessthan\">IsLessThan ( <var>x</var>, <var>y</var>, <var>LeftFirst</var> )</a></emu-xref>\n            </td>\n            <td>\n              Boolean or <emu-val>undefined</emu-val> (for unordered inputs)\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::equal(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;==&#160;y</code><br><code>x&#160;!=&#160;y</code><br><code>x&#160;===&#160;y</code><br><code>x&#160;!==&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-equality-operators\" title=\"\"><a href=\"#sec-equality-operators\">Equality Operators</a></emu-xref>,\n              via <emu-xref href=\"#sec-isstrictlyequal\" title=\"\"><a href=\"#sec-isstrictlyequal\">IsStrictlyEqual ( <var>x</var>, <var>y</var> )</a></emu-xref>\n            </td>\n            <td>\n              Boolean\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::sameValue(x,&#160;y)\n            </td>\n            <td>\n              <code>Object.is(x, y)</code>\n            </td>\n            <td>\n              Object internal methods,\n              via <emu-xref href=\"#sec-samevalue\" title=\"\"><a href=\"#sec-samevalue\">SameValue ( <var>x</var>, <var>y</var> )</a></emu-xref>,\n              to test exact value equality\n            </td>\n            <td>\n              Boolean\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::sameValueZero(x,&#160;y)\n            </td>\n            <td>\n              <code>[x].includes(y)</code>\n            </td>\n            <td>\n              Array, Map, and Set methods,\n              via <emu-xref href=\"#sec-samevaluezero\" title=\"\"><a href=\"#sec-samevaluezero\">SameValueZero ( <var>x</var>, <var>y</var> )</a></emu-xref>,\n              to test value equality ignoring differences between Numbers in the zero cohort (i.e., <emu-val>-0</emu-val><sub>&#120125;</sub> and <emu-val>+0</emu-val><sub>&#120125;</sub>)\n            </td>\n            <td>\n              Boolean\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::bitwiseAND(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;&amp;&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-binary-bitwise-operators\" title=\"\"><a href=\"#sec-binary-bitwise-operators\">Binary Bitwise Operators</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::bitwiseXOR(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;^&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-binary-bitwise-operators\" title=\"\"><a href=\"#sec-binary-bitwise-operators\">Binary Bitwise Operators</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::bitwiseOR(x,&#160;y)\n            </td>\n            <td>\n              <code>x&#160;|&#160;y</code>\n            </td>\n            <td>\n              <emu-xref href=\"#sec-binary-bitwise-operators\" title=\"\"><a href=\"#sec-binary-bitwise-operators\">Binary Bitwise Operators</a></emu-xref>\n            </td>\n            <td>\n              <var>T</var>\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <var>T</var>::toString(x)\n            </td>\n            <td>\n              <code>String(x)</code>\n            </td>\n            <td>\n              Many expressions and built-in functions, via <emu-xref href=\"#sec-tostring\" title=\"\"><a href=\"#sec-tostring\">ToString ( <var>argument</var> )</a></emu-xref>\n            </td>\n            <td>\n              String\n            </td>\n\n          </tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <p>The <var>T</var>::unit value and <var>T</var>::<var>op</var> operations are not a part of the ECMAScript language; they are defined here solely to aid the specification of the semantics of the ECMAScript language. Other <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> are defined throughout this specification.</p>\n      <p>Because the numeric types are in general not convertible without loss of precision or truncation, the ECMAScript language provides no implicit conversion among these types. Programmers must explicitly call <code>Number</code> and <code>BigInt</code> functions to convert among types when calling a function which requires another type.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The first and subsequent editions of ECMAScript have provided, for certain operators, implicit numeric conversions that could lose precision or truncate. These legacy implicit conversions are maintained for backward compatibility, but not provided for BigInt in order to minimize opportunity for programmer error, and to leave open the option of generalized <em>value types</em> in a future edition.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-ecmascript-language-types-number-type\"><h1><span class=\"secnum\">6.1.6.1</span>#sec-ecmascript-language-types-number-type The Number Type</h1>...</div><div id=\"excluded-sec-ecmascript-language-types-bigint-type\"><h1><span class=\"secnum\">6.1.6.2</span>#sec-ecmascript-language-types-bigint-type The BigInt Type</h1>...</div></emu-clause>\n\n    "}, "sec-implicit-completion-values": {"num": "5.2.3.1", "title": "#sec-implicit-completion-values Implicit Completion Values", "html": "<emu-clause id=\"sec-implicit-completion-values\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-implicit-completion-values\">#sec-implicit-completion-values</span> Implicit Completion Values</h1>\n        <p>The algorithms of this specification often implicitly return <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Records</a></emu-xref> whose [[Type]] is <emu-const>normal</emu-const>. Unless it is otherwise obvious from the context, an algorithm statement that returns a value that is not a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>, such as:</p>\n        <emu-alg><ol><li>Return <emu-val>\"Infinity\"</emu-val>.</li></ol></emu-alg>\n        <p>means the same thing as:</p>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>\"Infinity\"</emu-val>).</li></ol></emu-alg>\n        <p>However, if the value expression of a &#8220;return&#8221; statement is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> construction literal, the resulting <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> is returned. If the value expression is a call to an abstract operation, the &#8220;return&#8221; statement simply returns the <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> produced by the abstract operation.</p>\n        <p>The abstract operation <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>completionRecord</var>) is used to emphasize that a previously computed <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> is being returned. The <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> abstract operation takes a single argument, <var>completionRecord</var>, and performs the following steps:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completionRecord</var> is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>.</li><li>Return <var>completionRecord</var> as the <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> of this abstract operation.</li></ol></emu-alg>\n        <p>A &#8220;return&#8221; statement without a value in an algorithm step means the same thing as:</p>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></emu-alg>\n        <p>Any reference to a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> value that is in a context that does not explicitly require a complete <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> value is equivalent to an explicit reference to the [[Value]] field of the <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> value unless the <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</p>\n      </emu-clause>\n\n      "}, "sec-bigintbitwiseop": {"num": "6.1.6.2.19", "title": "#sec-bigintbitwiseop BigIntBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-bigintbitwiseop\" type=\"abstract operation\" aoid=\"BigIntBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bigintbitwiseop\">#sec-bigintbitwiseop</span> BigIntBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigIntBitwiseOp takes arguments <var>op</var> (<code>&amp;</code>, <code>^</code>, or <code>|</code>), <var>x</var> (a BigInt), and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Set <var>x</var> to <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>).</li><li>Set <var>y</var> to <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>).</li><li>Let <var>result</var> be 0.</li><li>Let <var>shift</var> be 0.</li><li>Repeat, until (<var>x</var> = 0 or <var>x</var> = -1) and (<var>y</var> = 0 or <var>y</var> = -1),<ol><li>Let <var>xDigit</var> be <var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>Let <var>yDigit</var> be <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>If <var>op</var> is <code>&amp;</code>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else if <var>op</var> is <code>|</code>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>^</code>.</li><li>Set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li></ol></li><li>Set <var>shift</var> to <var>shift</var> + 1.</li><li>Set <var>x</var> to (<var>x</var> - <var>xDigit</var>) / 2.</li><li>Set <var>y</var> to (<var>y</var> - <var>yDigit</var>) / 2.</li></ol></li><li>If <var>op</var> is <code>&amp;</code>, let <var>tmp</var> be <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else if <var>op</var> is <code>|</code>, let <var>tmp</var> be <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>^</code>.</li><li>Let <var>tmp</var> be <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li></ol></li><li>If <var>tmp</var> &#8800; 0, then<ol><li>Set <var>result</var> to <var>result</var> - 2<sup><var>shift</var></sup>.</li><li>NOTE: This extends the sign.</li></ol></li><li>Return the BigInt value for <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-remainder": {"num": "6.1.6.2.6", "title": "#sec-numeric-types-bigint-remainder BigInt::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-bigint-remainder\" type=\"numeric method\" aoid=\"BigInt::remainder\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-remainder\">#sec-numeric-types-bigint-remainder</span> BigInt::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The abstract operation BigInt::remainder takes arguments <var>n</var> (a BigInt) and <var>d</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>d</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>n</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, return <emu-val>0</emu-val><sub>&#8484;</sub>.</li><li>Let <var>r</var> be the BigInt defined by the mathematical relation <var>r</var> = <var>n</var> - (<var>d</var> &#215; <var>q</var>) where <var>q</var> is a BigInt that is negative only if <var>n</var>/<var>d</var> is negative and positive only if <var>n</var>/<var>d</var> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <var>n</var> and <var>d</var>.</li><li>Return <var>r</var>.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">The sign of the result equals the sign of the dividend.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-unsignedRightShift": {"num": "6.1.6.2.11", "title": "#sec-numeric-types-bigint-unsignedRightShift BigInt::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-unsignedRightShift\" type=\"numeric method\" aoid=\"BigInt::unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-unsignedRightShift\">#sec-numeric-types-bigint-unsignedRightShift</span> BigInt::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::unsignedRightShift takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-issuperreference": {"num": "6.2.4.3", "title": "#sec-issuperreference IsSuperReference ( V )", "html": "<emu-clause id=\"sec-issuperreference\" type=\"abstract operation\" oldids=\"ao-issuperreference\" aoid=\"IsSuperReference\"><span id=\"ao-issuperreference\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-issuperreference\">#sec-issuperreference</span> IsSuperReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsSuperReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[ThisValue]] is not <emu-const>empty</emu-const>, return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-prefix-decrement-operator-runtime-semantics-evaluation": {"num": "13.4.5.1", "title": "#sec-prefix-decrement-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-prefix-decrement-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-prefix-decrement-operator-runtime-semantics-evaluation\">#sec-prefix-decrement-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"onrvwudi\">\n        <emu-t>--</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>Let <var>newValue</var> be !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::subtract(<var>oldValue</var>, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::unit).</li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>expr</var>, <var>newValue</var>).</li><li>Return <var>newValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-unaryMinus": {"num": "6.1.6.2.1", "title": "#sec-numeric-types-bigint-unaryMinus BigInt::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-unaryMinus\" type=\"numeric method\" aoid=\"BigInt::unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-unaryMinus\">#sec-numeric-types-bigint-unaryMinus</span> BigInt::unaryMinus ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::unaryMinus takes argument <var>x</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, return <emu-val>0</emu-val><sub>&#8484;</sub>.</li><li>Return the BigInt value that represents the negation of <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numberbitwiseop": {"num": "6.1.6.1.16", "title": "#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-numberbitwiseop\" type=\"abstract operation\" aoid=\"NumberBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numberbitwiseop\">#sec-numberbitwiseop</span> NumberBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation NumberBitwiseOp takes arguments <var>op</var> (<code>&amp;</code>, <code>^</code>, or <code>|</code>), <var>x</var> (a Number), and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>y</var>).</li><li>Let <var>lbits</var> be the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>lnum</var>).</li><li>Let <var>rbits</var> be the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>).</li><li>If <var>op</var> is <code>&amp;</code>, let <var>result</var> be the result of applying the bitwise AND operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else if <var>op</var> is <code>^</code>, let <var>result</var> be the result of applying the bitwise exclusive OR (XOR) operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else, <var>op</var> is <code>|</code>. Let <var>result</var> be the result of applying the bitwise inclusive OR operation to <var>lbits</var> and <var>rbits</var>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> represented by the 32-bit two's complement bit string <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-exponentiate": {"num": "6.1.6.2.3", "title": "#sec-numeric-types-bigint-exponentiate BigInt::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-bigint-exponentiate\" type=\"numeric method\" aoid=\"BigInt::exponentiate\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-exponentiate\">#sec-numeric-types-bigint-exponentiate</span> BigInt::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>The abstract operation BigInt::exponentiate takes arguments <var>base</var> (a BigInt) and <var>exponent</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>exponent</var> &lt; <emu-val>0</emu-val><sub>&#8484;</sub>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>base</var> is <emu-val>0</emu-val><sub>&#8484;</sub> and <var>exponent</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, return <emu-val>1</emu-val><sub>&#8484;</sub>.</li><li>Return the BigInt value that represents <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>) raised to the power <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>exponent</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-add": {"num": "6.1.6.2.7", "title": "#sec-numeric-types-bigint-add BigInt::add ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-add\" type=\"numeric method\" aoid=\"BigInt::add\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-add\">#sec-numeric-types-bigint-add</span> BigInt::add ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::add takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return the BigInt value that represents the sum of <var>x</var> and <var>y</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-makeprivatereference": {"num": "6.2.4.9", "title": "#sec-makeprivatereference MakePrivateReference ( baseValue, privateIdentifier )", "html": "<emu-clause id=\"sec-makeprivatereference\" type=\"abstract operation\" aoid=\"MakePrivateReference\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-makeprivatereference\">#sec-makeprivatereference</span> MakePrivateReference ( <var>baseValue</var>, <var>privateIdentifier</var> )</h1>\n        <p>The abstract operation MakePrivateReference takes arguments <var>baseValue</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>privateIdentifier</var> (a String). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>privEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>privEnv</var> is not <emu-val>null</emu-val>.</li><li>Let <var>privateName</var> be !&#160;<emu-xref aoid=\"ResolvePrivateIdentifier\"><a href=\"#sec-resolve-private-identifier\">ResolvePrivateIdentifier</a></emu-xref>(<var>privEnv</var>, <var>privateIdentifier</var>).</li><li>Return the <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref> { [[Base]]: <var>baseValue</var>, [[ReferencedName]]: <var>privateName</var>, [[Strict]]: <emu-val>true</emu-val>, [[ThisValue]]: <emu-const>empty</emu-const> }.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-number-sameValue": {"num": "6.1.6.1.14", "title": "#sec-numeric-types-number-sameValue Number::sameValue ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValue\" type=\"numeric method\" aoid=\"Number::sameValue\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValue\">#sec-numeric-types-number-sameValue</span> Number::sameValue ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::sameValue takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-ecmascript-language-types-number-type": {"num": "6.1.6.1", "title": "#sec-ecmascript-language-types-number-type The Number Type", "html": "<emu-clause id=\"sec-ecmascript-language-types-number-type\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-language-types-number-type\">#sec-ecmascript-language-types-number-type</span> The Number Type</h1>\n        <p>The Number type has exactly 18,437,736,874,454,810,627 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>) values, representing the double-precision 64-bit format <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) distinct &#8220;Not-a-Number&#8221; values of the IEEE Standard are represented in ECMAScript as a single special <emu-val>NaN</emu-val> value. (Note that the <emu-val>NaN</emu-val> value is produced by the program expression <code>NaN</code>.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>; to ECMAScript code, all <emu-val>NaN</emu-val> values are indistinguishable from each other.</p>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The bit pattern that might be observed in an ArrayBuffer (see <emu-xref href=\"#sec-arraybuffer-objects\"><a href=\"#sec-arraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-arraybuffer-objects\">#sec-arraybuffer-objects</a></emu-xref>) or a SharedArrayBuffer (see <emu-xref href=\"#sec-sharedarraybuffer-objects\"><a href=\"#sec-sharedarraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-sharedarraybuffer-objects\">#sec-sharedarraybuffer-objects</a></emu-xref>) after a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> has been stored into it is not necessarily the same as the internal representation of that <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> used by the ECMAScript implementation.</p>\n        </div></emu-note>\n        <p>There are two other special values, called <emu-val>positive Infinity</emu-val> and <emu-val>negative Infinity</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> and <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, respectively. (Note that these two infinite Number values are produced by the program expressions <code>+Infinity</code> (or simply <code>Infinity</code>) and <code>-Infinity</code>.)</p>\n        <p>The other 18,437,736,874,454,810,624 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup></emu-eqn>) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> there is a corresponding negative value having the same magnitude.</p>\n        <p>Note that there is both a <emu-val>positive zero</emu-val> and a <emu-val>negative zero</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>, respectively. (Note that these two different zero Number values are produced by the program expressions <code>+0</code> (or simply <code>0</code>) and <code>-0</code>.)</p>\n        <p>The 18,437,736,874,454,810,622 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>) finite non-zero values are of two kinds:</p>\n        <p>18,428,729,675,200,069,632 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>54</sup></emu-eqn>) of them are normalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 2<sup>52</sup> &#8804; <var>m</var> &lt; 2<sup>53</sup>, and <var>e</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that -1074 &#8804; <var>e</var> &#8804; 971.</p>\n        <p>The remaining 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) values are denormalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 0 &lt; <var>m</var> &lt; 2<sup>52</sup>, and <var>e</var> is -1074.</p>\n        <p>Note that all the positive and negative <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type. The <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> 0 has two representations in the Number type: <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n        <p>A finite number has an <em>odd significand</em> if it is non-zero and the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>m</var> used to express it (in one of the two forms shown above) is odd. Otherwise, it has an <em>even significand</em>.</p>\n        <p>In this specification, the phrase &#8220;the <dfn id=\"number-value\">Number value</dfn> for <var>x</var>&#8221; where <var>x</var> represents an exact real mathematical quantity (which might even be an irrational number such as &#960;) means a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> chosen in the following manner. Consider the set of all finite values of the Number type, with <emu-val>-0</emu-val><sub>&#120125;</sub> removed and with two additional values added to it that are not representable in the Number type, namely 2<sup>1024</sup> (which is <emu-eqn class=\"inline\">+1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>) and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> (which is <emu-eqn class=\"inline\">-1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>). Choose the member of this set that is closest in value to <var>x</var>. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2<sup>1024</sup> and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> are considered to have even significands. Finally, if 2<sup>1024</sup> was chosen, replace it with <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>; if <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> was chosen, replace it with <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>; if <emu-val>+0</emu-val><sub>&#120125;</sub> was chosen, replace it with <emu-val>-0</emu-val><sub>&#120125;</sub> if and only if <var>x</var> &lt; 0; any other chosen value is used unchanged. The result is the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for <var>x</var>. (This procedure corresponds exactly to the behaviour of the <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode.)</p>\n        <p>The <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for +&#8734; is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, and the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for -&#8734; is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>.</p>\n        <p>Some ECMAScript operators deal only with <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> in specific ranges such as <emu-eqn class=\"inline\">-2<sup>31</sup></emu-eqn> through <emu-eqn class=\"inline\">2<sup>31</sup> - 1</emu-eqn>, inclusive, or in the range 0 through <emu-eqn class=\"inline\">2<sup>16</sup> - 1</emu-eqn>, inclusive. These operators accept any value of the Number type but first convert each such value to an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value in the expected range. See the descriptions of the numeric conversion operations in <emu-xref href=\"#sec-type-conversion\"><a href=\"#sec-type-conversion\" class=\"excluded-xref\" excluded-id=\"sec-type-conversion\">#sec-type-conversion</a></emu-xref>.</p>\n\n        <p>The Number::unit value is <emu-val>1</emu-val><sub>&#120125;</sub>.</p>\n\n        <div id=\"excluded-sec-numeric-types-number-unaryMinus\"><h1><span class=\"secnum\">6.1.6.1.1</span>#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseNOT\"><h1><span class=\"secnum\">6.1.6.1.2</span>#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-exponentiate\"><h1><span class=\"secnum\">6.1.6.1.3</span>#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )</h1>...</div><div id=\"excluded-sec-numeric-types-number-multiply\"><h1><span class=\"secnum\">6.1.6.1.4</span>#sec-numeric-types-number-multiply Number::multiply ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-divide\"><h1><span class=\"secnum\">6.1.6.1.5</span>#sec-numeric-types-number-divide Number::divide ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-remainder\"><h1><span class=\"secnum\">6.1.6.1.6</span>#sec-numeric-types-number-remainder Number::remainder ( n, d )</h1>...</div><div id=\"excluded-sec-numeric-types-number-add\"><h1><span class=\"secnum\">6.1.6.1.7</span>#sec-numeric-types-number-add Number::add ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-subtract\"><h1><span class=\"secnum\">6.1.6.1.8</span>#sec-numeric-types-number-subtract Number::subtract ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-leftShift\"><h1><span class=\"secnum\">6.1.6.1.9</span>#sec-numeric-types-number-leftShift Number::leftShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-signedRightShift\"><h1><span class=\"secnum\">6.1.6.1.10</span>#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-unsignedRightShift\"><h1><span class=\"secnum\">6.1.6.1.11</span>#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-lessThan\"><h1><span class=\"secnum\">6.1.6.1.12</span>#sec-numeric-types-number-lessThan Number::lessThan ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-equal\"><h1><span class=\"secnum\">6.1.6.1.13</span>#sec-numeric-types-number-equal Number::equal ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValue\"><h1><span class=\"secnum\">6.1.6.1.14</span>#sec-numeric-types-number-sameValue Number::sameValue ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValueZero\"><h1><span class=\"secnum\">6.1.6.1.15</span>#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )</h1>...</div><div id=\"excluded-sec-numberbitwiseop\"><h1><span class=\"secnum\">6.1.6.1.16</span>#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseAND\"><h1><span class=\"secnum\">6.1.6.1.17</span>#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseXOR\"><h1><span class=\"secnum\">6.1.6.1.18</span>#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseOR\"><h1><span class=\"secnum\">6.1.6.1.19</span>#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-tostring\"><h1><span class=\"secnum\">6.1.6.1.20</span>#sec-numeric-types-number-tostring Number::toString ( x )</h1>...</div></emu-clause>\n\n      "}, "sec-bitwise-not-operator-runtime-semantics-evaluation": {"num": "13.5.6.1", "title": "#sec-bitwise-not-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-bitwise-not-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bitwise-not-operator-runtime-semantics-evaluation\">#sec-bitwise-not-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UnaryExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"b9nqec7b\">\n        <emu-t>~</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>).</li><li>Return ! <var>T</var>::bitwiseNOT(<var>oldValue</var>).</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-topropertydescriptor": {"num": "6.2.5.5", "title": "#sec-topropertydescriptor ToPropertyDescriptor ( Obj )", "html": "<emu-clause id=\"sec-topropertydescriptor\" type=\"abstract operation\" aoid=\"ToPropertyDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-topropertydescriptor\">#sec-topropertydescriptor</span> ToPropertyDescriptor ( <var>Obj</var> )</h1>\n        <p>The abstract operation ToPropertyDescriptor takes argument <var>Obj</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>Obj</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>desc</var> be a new <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> that initially has no fields.</li><li>Let <var>hasEnumerable</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"enumerable\"</emu-val>).</li><li>If <var>hasEnumerable</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>enumerable</var> be !&#160;<emu-xref aoid=\"ToBoolean\"><a href=\"#sec-toboolean\">ToBoolean</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"enumerable\"</emu-val>)).</li><li>Set <var>desc</var>.[[Enumerable]] to <var>enumerable</var>.</li></ol></li><li>Let <var>hasConfigurable</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"configurable\"</emu-val>).</li><li>If <var>hasConfigurable</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>configurable</var> be !&#160;<emu-xref aoid=\"ToBoolean\"><a href=\"#sec-toboolean\">ToBoolean</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"configurable\"</emu-val>)).</li><li>Set <var>desc</var>.[[Configurable]] to <var>configurable</var>.</li></ol></li><li>Let <var>hasValue</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"value\"</emu-val>).</li><li>If <var>hasValue</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"value\"</emu-val>).</li><li>Set <var>desc</var>.[[Value]] to <var>value</var>.</li></ol></li><li>Let <var>hasWritable</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"writable\"</emu-val>).</li><li>If <var>hasWritable</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>writable</var> be !&#160;<emu-xref aoid=\"ToBoolean\"><a href=\"#sec-toboolean\">ToBoolean</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"writable\"</emu-val>)).</li><li>Set <var>desc</var>.[[Writable]] to <var>writable</var>.</li></ol></li><li>Let <var>hasGet</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"get\"</emu-val>).</li><li>If <var>hasGet</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>getter</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"get\"</emu-val>).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>getter</var>) is <emu-val>false</emu-val> and <var>getter</var> is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>desc</var>.[[Get]] to <var>getter</var>.</li></ol></li><li>Let <var>hasSet</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"set\"</emu-val>).</li><li>If <var>hasSet</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>setter</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"set\"</emu-val>).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>setter</var>) is <emu-val>false</emu-val> and <var>setter</var> is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>desc</var>.[[Set]] to <var>setter</var>.</li></ol></li><li>If <var>desc</var>.[[Get]] is present or <var>desc</var>.[[Set]] is present, then<ol><li>If <var>desc</var>.[[Value]] is present or <var>desc</var>.[[Writable]] is present, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Return <var>desc</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isaccessordescriptor": {"num": "6.2.5.1", "title": "#sec-isaccessordescriptor IsAccessorDescriptor ( Desc )", "html": "<emu-clause id=\"sec-isaccessordescriptor\" type=\"abstract operation\" aoid=\"IsAccessorDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isaccessordescriptor\">#sec-isaccessordescriptor</span> IsAccessorDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation IsAccessorDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>false</emu-val>.</li><li>If both <var>Desc</var>.[[Get]] and <var>Desc</var>.[[Set]] are absent, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-islessthan": {"num": "7.2.13", "title": "#sec-islessthan IsLessThan ( x, y, LeftFirst )", "html": "<emu-clause id=\"sec-islessthan\" type=\"abstract operation\" oldids=\"sec-abstract-relational-comparison\" aoid=\"IsLessThan\"><span id=\"sec-abstract-relational-comparison\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-islessthan\">#sec-islessthan</span> IsLessThan ( <var>x</var>, <var>y</var>, <var>LeftFirst</var> )</h1>\n      <p>The abstract operation IsLessThan takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), and <var>LeftFirst</var> (a Boolean). It provides the semantics for the comparison <var>x</var> &lt; <var>y</var>, returning <emu-val>true</emu-val>, <emu-val>false</emu-val>, or <emu-val>undefined</emu-val> (which indicates that at least one operand is <emu-val>NaN</emu-val>). The <var>LeftFirst</var> flag is used to control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. If <var>LeftFirst</var> is <emu-val>true</emu-val>, the <var>x</var> parameter corresponds to an expression that occurs to the left of the <var>y</var> parameter's corresponding expression. If <var>LeftFirst</var> is <emu-val>false</emu-val>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If the <var>LeftFirst</var> flag is <emu-val>true</emu-val>, then<ol><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li></ol></li><li>Else,<ol><li>NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li></ol></li><li id=\"step-arc-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>py</var>, <var>px</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>px</var>, <var>py</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>k</var> be the smallest non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that the code unit at index <var>k</var> within <var>px</var> is different from the code unit at index <var>k</var> within <var>py</var>. (There must be such a <var>k</var>, for neither String is a prefix of the other.)</li><li>Let <var>m</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>px</var>.</li><li>Let <var>n</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>py</var>.</li><li>If <var>m</var> &lt; <var>n</var>, return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>py</var>).</li><li>If <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return <emu-xref aoid=\"BigInt::lessThan\"><a href=\"#sec-numeric-types-bigint-lessThan\">BigInt::lessThan</a></emu-xref>(<var>px</var>, <var>ny</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is BigInt, then<ol><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>px</var>).</li><li>If <var>nx</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return <emu-xref aoid=\"BigInt::lessThan\"><a href=\"#sec-numeric-types-bigint-lessThan\">BigInt::lessThan</a></emu-xref>(<var>nx</var>, <var>py</var>).</li></ol></li><li>NOTE: Because <var>px</var> and <var>py</var> are primitive values, evaluation order is not important.</li><li>Let <var>nx</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>px</var>).</li><li>Let <var>ny</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>py</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is the same as <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>), return <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>)::lessThan(<var>nx</var>, <var>ny</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is Number, or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is BigInt.</li><li>If <var>nx</var> or <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>nx</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>nx</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>nx</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>ny</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> differs from step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">2.c</a></emu-xref> in the algorithm that handles the addition operator <code>+</code> (<emu-xref href=\"#sec-applystringornumericbinaryoperator\"><a href=\"#sec-applystringornumericbinaryoperator\" class=\"excluded-xref\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</a></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-frompropertydescriptor": {"num": "6.2.5.4", "title": "#sec-frompropertydescriptor FromPropertyDescriptor ( Desc )", "html": "<emu-clause id=\"sec-frompropertydescriptor\" type=\"abstract operation\" aoid=\"FromPropertyDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-frompropertydescriptor\">#sec-frompropertydescriptor</span> FromPropertyDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation FromPropertyDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-object-prototype-object\"><a href=\"#sec-properties-of-the-object-prototype-object\">%Object.prototype%</a></emu-xref>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>obj</var> is an extensible <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> with no own properties.</li><li>If <var>Desc</var> has a [[Value]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"value\"</emu-val>, <var>Desc</var>.[[Value]]).</li></ol></li><li>If <var>Desc</var> has a [[Writable]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"writable\"</emu-val>, <var>Desc</var>.[[Writable]]).</li></ol></li><li>If <var>Desc</var> has a [[Get]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"get\"</emu-val>, <var>Desc</var>.[[Get]]).</li></ol></li><li>If <var>Desc</var> has a [[Set]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"set\"</emu-val>, <var>Desc</var>.[[Set]]).</li></ol></li><li>If <var>Desc</var> has an [[Enumerable]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"enumerable\"</emu-val>, <var>Desc</var>.[[Enumerable]]).</li></ol></li><li>If <var>Desc</var> has a [[Configurable]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"configurable\"</emu-val>, <var>Desc</var>.[[Configurable]]).</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-gather-available-ancestors": {"num": "16.2.1.5.2.3", "title": "#sec-gather-available-ancestors GatherAvailableAncestors ( module, execList )", "html": "<emu-clause id=\"sec-gather-available-ancestors\" type=\"abstract operation\" aoid=\"GatherAvailableAncestors\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-gather-available-ancestors\">#sec-gather-available-ancestors</span> GatherAvailableAncestors ( <var>module</var>, <var>execList</var> )</h1>\n            <p>The abstract operation GatherAvailableAncestors takes arguments <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>) and <var>execList</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Records</a></emu-xref>). It performs the following steps when called:</p>\n            <emu-alg><ol><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> of <var>module</var>.[[AsyncParentModules]], do<ol><li>If <var>execList</var> does not contain <var>m</var> and <var>m</var>.[[CycleRoot]].[[EvaluationError]] is <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[Status]] is <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[EvaluationError]] is <emu-const>empty</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[AsyncEvaluation]] is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[PendingAsyncDependencies]] &gt; 0.</li><li>Set <var>m</var>.[[PendingAsyncDependencies]] to <var>m</var>.[[PendingAsyncDependencies]] - 1.</li><li>If <var>m</var>.[[PendingAsyncDependencies]] = 0, then<ol><li>Append <var>m</var> to <var>execList</var>.</li><li>If <var>m</var>.[[HasTLA]] is <emu-val>false</emu-val>, perform !&#160;<emu-xref aoid=\"GatherAvailableAncestors\"><a href=\"#sec-gather-available-ancestors\">GatherAvailableAncestors</a></emu-xref>(<var>m</var>, <var>execList</var>).</li></ol></li></ol></li></ol></li></ol></emu-alg>\n            <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n              <p>When an asynchronous execution for a root <var>module</var> is fulfilled, this function determines the list of modules which are able to synchronously execute together on this completion, populating them in <var>execList</var>.</p>\n            </div></emu-note>\n          </emu-clause>\n\n          "}, "sec-numeric-types-bigint-multiply": {"num": "6.1.6.2.4", "title": "#sec-numeric-types-bigint-multiply BigInt::multiply ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-multiply\" type=\"numeric method\" aoid=\"BigInt::multiply\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-multiply\">#sec-numeric-types-bigint-multiply</span> BigInt::multiply ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::multiply takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return the BigInt value that represents the product of <var>x</var> and <var>y</var>.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">Even if the result has a much larger bit width than the input, the exact mathematical answer is given.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-signedRightShift": {"num": "6.1.6.2.10", "title": "#sec-numeric-types-bigint-signedRightShift BigInt::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-signedRightShift\" type=\"numeric method\" aoid=\"BigInt::signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-signedRightShift\">#sec-numeric-types-bigint-signedRightShift</span> BigInt::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::signedRightShift takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigInt::leftShift\"><a href=\"#sec-numeric-types-bigint-leftShift\">BigInt::leftShift</a></emu-xref>(<var>x</var>, -<var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseAND": {"num": "6.1.6.1.17", "title": "#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseAND\" type=\"numeric method\" aoid=\"Number::bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseAND\">#sec-numeric-types-number-bitwiseAND</span> Number::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseAND takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-createsharedbytedatablock": {"num": "6.2.8.2", "title": "#sec-createsharedbytedatablock CreateSharedByteDataBlock ( size )", "html": "<emu-clause id=\"sec-createsharedbytedatablock\" type=\"abstract operation\" aoid=\"CreateSharedByteDataBlock\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-createsharedbytedatablock\">#sec-createsharedbytedatablock</span> CreateSharedByteDataBlock ( <var>size</var> )</h1>\n        <p>The abstract operation CreateSharedByteDataBlock takes argument <var>size</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>db</var> be a new <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>zero</var> be &#171; 0 &#187;.</li><li>For each index <var>i</var> of <var>db</var>, do<ol><li>Append <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">WriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>Init</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>db</var>, [[ByteIndex]]: <var>i</var>, [[ElementSize]]: 1, [[Payload]]: <var>zero</var> } to <var>eventList</var>.</li></ol></li><li>Return <var>db</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-binaryor": {"num": "6.1.6.2.17", "title": "#sec-binaryor BinaryOr ( x, y )", "html": "<emu-clause id=\"sec-binaryor\" type=\"abstract operation\" aoid=\"BinaryOr\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-binaryor\">#sec-binaryor</span> BinaryOr ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BinaryOr takes arguments <var>x</var> (0 or 1) and <var>y</var> (0 or 1). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is 1 or <var>y</var> is 1, return 1.</li><li>Else, return 0.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-prefix-increment-operator-runtime-semantics-evaluation": {"num": "13.4.4.1", "title": "#sec-prefix-increment-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-prefix-increment-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-prefix-increment-operator-runtime-semantics-evaluation\">#sec-prefix-increment-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"vwgxygda\">\n        <emu-t>++</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>Let <var>newValue</var> be !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::add(<var>oldValue</var>, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::unit).</li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>expr</var>, <var>newValue</var>).</li><li>Return <var>newValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-atomics.sub": {"num": "25.4.11", "title": "#sec-atomics.sub Atomics.sub ( typedArray, index, value )", "html": "<emu-clause id=\"sec-atomics.sub\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atomics.sub\">#sec-atomics.sub</span> Atomics.sub ( <var>typedArray</var>, <var>index</var>, <var>value</var> )</h1>\n      <p>The following steps are taken:</p>\n      <emu-alg><ol><li>Let <var>type</var> be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>subtract</var> be a new <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> with parameters (<var>xBytes</var>, <var>yBytes</var>) that captures <var>type</var> and <var>isLittleEndian</var> and performs the following steps atomically when called:<ol><li>Let <var>x</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>xBytes</var>, <var>isLittleEndian</var>).</li><li>Let <var>y</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>yBytes</var>, <var>isLittleEndian</var>).</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>).</li><li>Let <var>difference</var> be <var>T</var>::subtract(<var>x</var>, <var>y</var>).</li><li>Let <var>differenceBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>difference</var>, <var>isLittleEndian</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>differenceBytes</var>, <var>xBytes</var>, and <var>yBytes</var> have the same number of elements.</li><li>Return <var>differenceBytes</var>.</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"AtomicReadModifyWrite\"><a href=\"#sec-atomicreadmodifywrite\">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <var>subtract</var>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-updateempty": {"num": "6.2.3.4", "title": "#sec-updateempty UpdateEmpty ( completionRecord, value )", "html": "<emu-clause id=\"sec-updateempty\" type=\"abstract operation\" aoid=\"UpdateEmpty\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-updateempty\">#sec-updateempty</span> UpdateEmpty ( <var>completionRecord</var>, <var>value</var> )</h1>\n        <p>The abstract operation UpdateEmpty takes arguments <var>completionRecord</var> and <var>value</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>completionRecord</var>.[[Type]] is either <emu-const>return</emu-const> or <emu-const>throw</emu-const>, then <var>completionRecord</var>.[[Value]] is not <emu-const>empty</emu-const>.</li><li>If <var>completionRecord</var>.[[Value]] is not <emu-const>empty</emu-const>, return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>completionRecord</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <var>completionRecord</var>.[[Type]], [[Value]]: <var>value</var>, [[Target]]: <var>completionRecord</var>.[[Target]] }.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-number-unsignedRightShift": {"num": "6.1.6.1.11", "title": "#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-unsignedRightShift\" type=\"numeric method\" aoid=\"Number::unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unsignedRightShift\">#sec-numeric-types-number-unsignedRightShift</span> Number::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::unsignedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of performing a zero-filling right shift of <var>lnum</var> by <var>shiftCount</var> bits. Vacated bits are filled with zero. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit unsigned bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-execute-async-module": {"num": "16.2.1.5.2.2", "title": "#sec-execute-async-module ExecuteAsyncModule ( module )", "html": "<emu-clause id=\"sec-execute-async-module\" type=\"abstract operation\" aoid=\"ExecuteAsyncModule\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-execute-async-module\">#sec-execute-async-module</span> ExecuteAsyncModule ( <var>module</var> )</h1>\n            <p>The abstract operation ExecuteAsyncModule takes argument <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>). It performs the following steps when called:</p>\n\n            <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluating</emu-const> or <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[HasTLA]] is <emu-val>true</emu-val>.</li><li>Let <var>capability</var> be !&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>).</li><li>Let <var>fulfilledClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>module</var> and performs the following steps when called:<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionFulfilled\"><a href=\"#sec-async-module-execution-fulfilled\">AsyncModuleExecutionFulfilled</a></emu-xref>(<var>module</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>fulfilledClosure</var>, 0, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Let <var>rejectedClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>error</var>) that captures <var>module</var> and performs the following steps when called:<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionRejected\"><a href=\"#sec-async-module-execution-rejected\">AsyncModuleExecutionRejected</a></emu-xref>(<var>module</var>, <var>error</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectedClosure</var>, 0, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>capability</var>.[[Promise]], <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Perform ! <var>module</var>.ExecuteModule(<var>capability</var>).</li></ol></emu-alg>\n          </emu-clause>\n\n          "}, "sec-copydatablockbytes": {"num": "6.2.8.3", "title": "#sec-copydatablockbytes CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )", "html": "<emu-clause id=\"sec-copydatablockbytes\" type=\"abstract operation\" aoid=\"CopyDataBlockBytes\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-copydatablockbytes\">#sec-copydatablockbytes</span> CopyDataBlockBytes ( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> )</h1>\n        <p>The abstract operation CopyDataBlockBytes takes arguments <var>toBlock</var> (a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref> or a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>), <var>toIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>fromBlock</var> (a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref> or a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>), <var>fromIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), and <var>count</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>fromBlock</var> and <var>toBlock</var> are distinct values.</li><li>Let <var>fromSize</var> be the number of bytes in <var>fromBlock</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>fromIndex</var> + <var>count</var> &#8804; <var>fromSize</var>.</li><li>Let <var>toSize</var> be the number of bytes in <var>toBlock</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>toIndex</var> + <var>count</var> &#8804; <var>toSize</var>.</li><li>Repeat, while <var>count</var> &gt; 0,<ol><li>If <var>fromBlock</var> is a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>bytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose sole element is a nondeterministically chosen <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">byte value</a></emu-xref>.</li><li>NOTE: In implementations, <var>bytes</var> is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>readEvent</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadSharedMemory</a></emu-xref> { [[Order]]: <emu-const>Unordered</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>fromBlock</var>, [[ByteIndex]]: <var>fromIndex</var>, [[ElementSize]]: 1 }.</li><li>Append <var>readEvent</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>readEvent</var>, [[ChosenValue]]: <var>bytes</var> } to <var>execution</var>.[[ChosenValues]].</li><li>If <var>toBlock</var> is a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>, then<ol><li>Append <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">WriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>Unordered</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>toBlock</var>, [[ByteIndex]]: <var>toIndex</var>, [[ElementSize]]: 1, [[Payload]]: <var>bytes</var> } to <var>eventList</var>.</li></ol></li><li>Else,<ol><li>Set <var>toBlock</var>[<var>toIndex</var>] to <var>bytes</var>[0].</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>toBlock</var> is not a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>.</li><li>Set <var>toBlock</var>[<var>toIndex</var>] to <var>fromBlock</var>[<var>fromIndex</var>].</li></ol></li><li>Set <var>toIndex</var> to <var>toIndex</var> + 1.</li><li>Set <var>fromIndex</var> to <var>fromIndex</var> + 1.</li><li>Set <var>count</var> to <var>count</var> - 1.</li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-number-lessThan": {"num": "6.1.6.1.12", "title": "#sec-numeric-types-number-lessThan Number::lessThan ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-lessThan\" type=\"numeric method\" aoid=\"Number::lessThan\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-lessThan\">#sec-numeric-types-number-lessThan</span> Number::lessThan ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::lessThan takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>x</var> and <var>y</var> are the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> and <var>y</var> are finite and non-zero.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>), return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-subtract": {"num": "6.1.6.2.8", "title": "#sec-numeric-types-bigint-subtract BigInt::subtract ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-subtract\" type=\"numeric method\" aoid=\"BigInt::subtract\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-subtract\">#sec-numeric-types-bigint-subtract</span> BigInt::subtract ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::subtract takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return the BigInt value that represents the difference <var>x</var> minus <var>y</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-throwcompletion": {"num": "6.2.3.3", "title": "#sec-throwcompletion ThrowCompletion ( value )", "html": "<emu-clause id=\"sec-throwcompletion\" type=\"abstract operation\" aoid=\"ThrowCompletion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-throwcompletion\">#sec-throwcompletion</span> ThrowCompletion ( <var>value</var> )</h1>\n        <p>The abstract operation ThrowCompletion takes argument <var>value</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>throw</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-add": {"num": "6.1.6.1.7", "title": "#sec-numeric-types-number-add Number::add ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-add\" type=\"numeric method\" oldids=\"sec-applying-the-additive-operators-to-numbers\" aoid=\"Number::add\"><span id=\"sec-applying-the-additive-operators-to-numbers\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-add\">#sec-numeric-types-number-add</span> Number::add ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::add takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs addition according to the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic, producing the sum of its arguments. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> or <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <var>y</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> and <var>y</var> are both finite.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>-0</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) + <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>Finite-precision addition is commutative, but not always associative.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-equal": {"num": "6.1.6.1.13", "title": "#sec-numeric-types-number-equal Number::equal ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-equal\" type=\"numeric method\" aoid=\"Number::equal\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-equal\">#sec-numeric-types-number-equal</span> Number::equal ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::equal takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-initializereferencedbinding": {"num": "6.2.4.8", "title": "#sec-initializereferencedbinding InitializeReferencedBinding ( V, W )", "html": "<emu-clause id=\"sec-initializereferencedbinding\" type=\"abstract operation\" aoid=\"InitializeReferencedBinding\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-initializereferencedbinding\">#sec-initializereferencedbinding</span> InitializeReferencedBinding ( <var>V</var>, <var>W</var> )</h1>\n        <p>The abstract operation InitializeReferencedBinding takes arguments <var>V</var> and <var>W</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>V</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>W</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>V</var> is a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsUnresolvableReference\"><a href=\"#sec-isunresolvablereference\">IsUnresolvableReference</a></emu-xref>(<var>V</var>) is <emu-val>false</emu-val>.</li><li>Let <var>base</var> be <var>V</var>.[[Base]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Return <var>base</var>.InitializeBinding(<var>V</var>.[[ReferencedName]], <var>W</var>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-binaryxor": {"num": "6.1.6.2.18", "title": "#sec-binaryxor BinaryXor ( x, y )", "html": "<emu-clause id=\"sec-binaryxor\" type=\"abstract operation\" aoid=\"BinaryXor\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-binaryxor\">#sec-binaryxor</span> BinaryXor ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BinaryXor takes arguments <var>x</var> (0 or 1) and <var>y</var> (0 or 1). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is 1 and <var>y</var> is 0, return 1.</li><li>Else if <var>x</var> is 0 and <var>y</var> is 1, return 1.</li><li>Else, return 0.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseXOR": {"num": "6.1.6.2.21", "title": "#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseXOR\" type=\"numeric method\" aoid=\"BigInt::bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseXOR\">#sec-numeric-types-bigint-bitwiseXOR</span> BigInt::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseXOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-completion-record-specification-type": {"num": "6.2.3", "title": "#sec-completion-record-specification-type The Completion Record Specification Type", "html": "<emu-clause id=\"sec-completion-record-specification-type\" aoid=\"Completion\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completion-record-specification-type\">#sec-completion-record-specification-type</span> The Completion Record Specification Type</h1>\n      <p>The Completion type is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> used to explain the runtime propagation of values and control flow such as the behaviour of statements (<code>break</code>, <code>continue</code>, <code>return</code> and <code>throw</code>) that perform nonlocal transfers of control.</p>\n      <p>Values of the Completion type are <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> values whose fields are defined by <emu-xref href=\"#table-completion-record-fields\"><a href=\"#table-completion-record-fields\" class=\"excluded-xref\" excluded-id=\"table-completion-record-fields\">#table-completion-record-fields</a></emu-xref>. Such values are referred to as <dfn variants=\"Completion Record\">Completion Records</dfn>.</p>\n      <emu-table id=\"table-completion-record-fields\" caption=\"Completion Record Fields\" oldids=\"table-8\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-completion-record-fields\">#table-completion-record-fields</span>: <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> Fields</figcaption><span id=\"table-8\"></span>\n        <table>\n          <tbody>\n          <tr>\n            <th>\n              Field Name\n            </th>\n            <th>\n              Value\n            </th>\n            <th>\n              Meaning\n            </th>\n          </tr>\n          <tr>\n            <td>\n              [[Type]]\n            </td>\n            <td>\n              One of <emu-const>normal</emu-const>, <emu-const>break</emu-const>, <emu-const>continue</emu-const>, <emu-const>return</emu-const>, or <emu-const>throw</emu-const>\n            </td>\n            <td>\n              The type of completion that occurred.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Value]]\n            </td>\n            <td>\n              any <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref> or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The value that was produced.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Target]]\n            </td>\n            <td>\n              any ECMAScript string or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The target label for directed control transfers.\n            </td>\n          </tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <p>The following shorthand terms are sometimes used to refer to completions.</p>\n      <ul>\n        <li><dfn variants=\"normal completions\">normal completion</dfn> refers to any completion with a [[Type]] value of <emu-const>normal</emu-const>.</li>\n        <li><dfn variants=\"break completions\">break completion</dfn> refers to any completion with a [[Type]] value of <emu-const>break</emu-const>.</li>\n        <li><dfn variants=\"continue completions\">continue completion</dfn> refers to any completion with a [[Type]] value of <emu-const>continue</emu-const>.</li>\n        <li><dfn variants=\"return completions\">return completion</dfn> refers to any completion with a [[Type]] value of <emu-const>return</emu-const>.</li>\n        <li><dfn variants=\"throw completions\">throw completion</dfn> refers to any completion with a [[Type]] value of <emu-const>throw</emu-const>.</li>\n        <li><dfn variants=\"abrupt completions\">abrupt completion</dfn> refers to any completion with a [[Type]] value other than <emu-const>normal</emu-const>.</li>\n      </ul>\n      <p>Callable objects that are defined in this specification only return a normal completion or a throw completion. Returning any other kind of completion is considered an editorial error.</p>\n      <p><emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">Implementation-defined</a></emu-xref> callable objects must return either a normal completion or a throw completion.</p>\n\n      <emu-clause id=\"await\" oldids=\"await-fulfilled,await-rejected\" aoid=\"Await\"><span id=\"await-rejected\"></span><span id=\"await-fulfilled\"></span>\n        <h1><span class=\"secnum\">6.2.3.1</span> Await</h1>\n\n        <p>Algorithm steps that say</p>\n\n        <emu-alg><ol><li>Let <var>completion</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n        <p>mean the same thing as:</p>\n\n        <emu-alg><ol><li>Let <var>asyncContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li>Let <var>fulfilledClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>value</var>) that captures <var>asyncContext</var> and performs the following steps when called:<ol><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Suspend <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>value</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>fulfilledClosure</var>, 1, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Let <var>rejectedClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>reason</var>) that captures <var>asyncContext</var> and performs the following steps when called:<ol><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Suspend <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>reason</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectedClosure</var>, 1, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed with a <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> <var>completion</var>, the following steps of the algorithm that invoked <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> will be performed, with <var>completion</var> available.</li><li>Return.</li><li>NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of <var>asyncContext</var>.</li></ol></emu-alg>\n\n        <p>where all aliases in the above steps, with the exception of <var>completion</var>, are ephemeral and visible only in the steps pertaining to Await.</p>\n\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Await can be combined with the <code>?</code> and <code>!</code> prefixes, so that for example</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n          <p>means the same thing as:</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </div></emu-note>\n      </emu-clause>\n\n      <div id=\"excluded-sec-normalcompletion\"><h1><span class=\"secnum\">6.2.3.2</span>#sec-normalcompletion NormalCompletion ( value )</h1>...</div><div id=\"excluded-sec-throwcompletion\"><h1><span class=\"secnum\">6.2.3.3</span>#sec-throwcompletion ThrowCompletion ( value )</h1>...</div><div id=\"excluded-sec-updateempty\"><h1><span class=\"secnum\">6.2.3.4</span>#sec-updateempty UpdateEmpty ( completionRecord, value )</h1>...</div></emu-clause>\n\n    "}, "sec-ispropertyreference": {"num": "6.2.4.1", "title": "#sec-ispropertyreference IsPropertyReference ( V )", "html": "<emu-clause id=\"sec-ispropertyreference\" type=\"abstract operation\" oldids=\"ao-ispropertyreference\" aoid=\"IsPropertyReference\"><span id=\"ao-ispropertyreference\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ispropertyreference\">#sec-ispropertyreference</span> IsPropertyReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsPropertyReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[Base]] is <emu-const>unresolvable</emu-const>, return <emu-val>false</emu-val>.</li><li>If <var>V</var>.[[Base]] is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, return <emu-val>false</emu-val>; otherwise return <emu-val>true</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isdatadescriptor": {"num": "6.2.5.2", "title": "#sec-isdatadescriptor IsDataDescriptor ( Desc )", "html": "<emu-clause id=\"sec-isdatadescriptor\" type=\"abstract operation\" aoid=\"IsDataDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isdatadescriptor\">#sec-isdatadescriptor</span> IsDataDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation IsDataDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>false</emu-val>.</li><li>If both <var>Desc</var>.[[Value]] and <var>Desc</var>.[[Writable]] are absent, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-bitwiseNOT": {"num": "6.1.6.1.2", "title": "#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseNOT\" type=\"numeric method\" aoid=\"Number::bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseNOT\">#sec-numeric-types-number-bitwiseNOT</span> Number::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation Number::bitwiseNOT takes argument <var>x</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>oldValue</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Return the result of applying bitwise complement to <var>oldValue</var>. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-getvalue": {"num": "6.2.4.5", "title": "#sec-getvalue GetValue ( V )", "html": "<emu-clause id=\"sec-getvalue\" type=\"abstract operation\" aoid=\"GetValue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getvalue\">#sec-getvalue</span> GetValue ( <var>V</var> )</h1>\n        <p>The abstract operation GetValue takes argument <var>V</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>V</var>).</li><li>If <var>V</var> is not a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>, return <var>V</var>.</li><li>If <emu-xref aoid=\"IsUnresolvableReference\"><a href=\"#sec-isunresolvablereference\">IsUnresolvableReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>If <emu-xref aoid=\"IsPropertyReference\"><a href=\"#sec-ispropertyreference\">IsPropertyReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li id=\"step-getvalue-toobject\">Let <var>baseObj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>V</var>.[[Base]]).</li><li>If <emu-xref aoid=\"IsPrivateReference\"><a href=\"#sec-isprivatereference\">IsPrivateReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"PrivateGet\"><a href=\"#sec-privateget\">PrivateGet</a></emu-xref>(<var>baseObj</var>, <var>V</var>.[[ReferencedName]]).</li></ol></li><li>Return ? <var>baseObj</var>.[[Get]](<var>V</var>.[[ReferencedName]], <emu-xref aoid=\"GetThisValue\"><a href=\"#sec-getthisvalue\">GetThisValue</a></emu-xref>(<var>V</var>)).</li></ol></li><li>Else,<ol><li>Let <var>base</var> be <var>V</var>.[[Base]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Return ? <var>base</var>.GetBindingValue(<var>V</var>.[[ReferencedName]], <var>V</var>.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\" class=\"excluded-xref\" excluded-id=\"sec-environment-records\">#sec-environment-records</a></emu-xref>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The object that may be created in step <emu-xref href=\"#step-getvalue-toobject\"><a href=\"#step-getvalue-toobject\">4.a</a></emu-xref> is not accessible outside of the above abstract operation and the <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-normalcompletion": {"num": "6.2.3.2", "title": "#sec-normalcompletion NormalCompletion ( value )", "html": "<emu-clause id=\"sec-normalcompletion\" type=\"abstract operation\" aoid=\"NormalCompletion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-normalcompletion\">#sec-normalcompletion</span> NormalCompletion ( <var>value</var> )</h1>\n        <p>The abstract operation NormalCompletion takes argument <var>value</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>normal</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncblockstart": {"num": "27.7.5.2", "title": "#sec-asyncblockstart AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )", "html": "<emu-clause id=\"sec-asyncblockstart\" type=\"abstract operation\" aoid=\"AsyncBlockStart\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncblockstart\">#sec-asyncblockstart</span> AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</h1>\n        <p>The abstract operation AsyncBlockStart takes arguments <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), <var>asyncBody</var> (a <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref>), and <var>asyncContext</var> (an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>.</li><li>Let <var>runningContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncBody</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li id=\"step-asyncblockstart-return-undefined\">Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">normal completion</a></emu-xref> with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"><a href=\"#step-asyncblockstart-return-undefined\">3.g</a></emu-xref> above.</li><li>Return.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-stringindexof": {"num": "6.1.4.1", "title": "#sec-stringindexof StringIndexOf ( string, searchValue, fromIndex )", "html": "<emu-clause id=\"sec-stringindexof\" type=\"abstract operation\" aoid=\"StringIndexOf\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-stringindexof\">#sec-stringindexof</span> StringIndexOf ( <var>string</var>, <var>searchValue</var>, <var>fromIndex</var> )</h1>\n        <p>The abstract operation StringIndexOf takes arguments <var>string</var> (a String), <var>searchValue</var> (a String), and <var>fromIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>len</var> be the length of <var>string</var>.</li><li>If <var>searchValue</var> is the empty String and <var>fromIndex</var> &#8804; <var>len</var>, return <var>fromIndex</var>.</li><li>Let <var>searchLen</var> be the length of <var>searchValue</var>.</li><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> starting with <var>fromIndex</var> such that <var>i</var> &#8804; <var>len</var> - <var>searchLen</var>, in ascending order, do<ol><li>Let <var>candidate</var> be the <emu-xref href=\"#substring\"><a href=\"#substring\">substring</a></emu-xref> of <var>string</var> from <var>i</var> to <var>i</var> + <var>searchLen</var>.</li><li>If <var>candidate</var> is the same sequence of code units as <var>searchValue</var>, return <var>i</var>.</li></ol></li><li>Return -1.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>If <var>searchValue</var> is the empty String and <var>fromIndex</var> is less than or equal to the length of <var>string</var>, this algorithm returns <var>fromIndex</var>. The empty String is effectively found at every position within a string, including after the last code unit.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>This algorithm always returns -1 if <var>fromIndex</var> &gt; the length of <var>string</var>.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-completepropertydescriptor": {"num": "6.2.5.6", "title": "#sec-completepropertydescriptor CompletePropertyDescriptor ( Desc )", "html": "<emu-clause id=\"sec-completepropertydescriptor\" type=\"abstract operation\" aoid=\"CompletePropertyDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completepropertydescriptor\">#sec-completepropertydescriptor</span> CompletePropertyDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation CompletePropertyDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>like</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>undefined</emu-val>, [[Writable]]: <emu-val>false</emu-val>, [[Get]]: <emu-val>undefined</emu-val>, [[Set]]: <emu-val>undefined</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</li><li>If <emu-xref aoid=\"IsGenericDescriptor\"><a href=\"#sec-isgenericdescriptor\">IsGenericDescriptor</a></emu-xref>(<var>Desc</var>) is <emu-val>true</emu-val> or <emu-xref aoid=\"IsDataDescriptor\"><a href=\"#sec-isdatadescriptor\">IsDataDescriptor</a></emu-xref>(<var>Desc</var>) is <emu-val>true</emu-val>, then<ol><li>If <var>Desc</var> does not have a [[Value]] field, set <var>Desc</var>.[[Value]] to <var>like</var>.[[Value]].</li><li>If <var>Desc</var> does not have a [[Writable]] field, set <var>Desc</var>.[[Writable]] to <var>like</var>.[[Writable]].</li></ol></li><li>Else,<ol><li>If <var>Desc</var> does not have a [[Get]] field, set <var>Desc</var>.[[Get]] to <var>like</var>.[[Get]].</li><li>If <var>Desc</var> does not have a [[Set]] field, set <var>Desc</var>.[[Set]] to <var>like</var>.[[Set]].</li></ol></li><li>If <var>Desc</var> does not have an [[Enumerable]] field, set <var>Desc</var>.[[Enumerable]] to <var>like</var>.[[Enumerable]].</li><li>If <var>Desc</var> does not have a [[Configurable]] field, set <var>Desc</var>.[[Configurable]] to <var>like</var>.[[Configurable]].</li><li>Return <var>Desc</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-divide": {"num": "6.1.6.2.5", "title": "#sec-numeric-types-bigint-divide BigInt::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-divide\" type=\"numeric method\" aoid=\"BigInt::divide\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-divide\">#sec-numeric-types-bigint-divide</span> BigInt::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::divide takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>y</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>quotient</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) / <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>).</li><li>Return the BigInt value that represents <var>quotient</var> rounded towards 0 to the next <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseOR": {"num": "6.1.6.1.19", "title": "#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseOR\" type=\"numeric method\" aoid=\"Number::bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseOR\">#sec-numeric-types-number-bitwiseOR</span> Number::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseOR takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-postfix-increment-operator-runtime-semantics-evaluation": {"num": "13.4.2.1", "title": "#sec-postfix-increment-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-postfix-increment-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-postfix-increment-operator-runtime-semantics-evaluation\">#sec-postfix-increment-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"i_jjg0ex\">\n        <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>\n        <emu-t>++</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>lhs</var> be the result of evaluating <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>lhs</var>)).</li><li>Let <var>newValue</var> be !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::add(<var>oldValue</var>, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::unit).</li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhs</var>, <var>newValue</var>).</li><li>Return <var>oldValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-leftShift": {"num": "6.1.6.2.9", "title": "#sec-numeric-types-bigint-leftShift BigInt::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-leftShift\" type=\"numeric method\" aoid=\"BigInt::leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-leftShift\">#sec-numeric-types-bigint-leftShift</span> BigInt::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::leftShift takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>y</var> &lt; <emu-val>0</emu-val><sub>&#8484;</sub>, then<ol><li>Return the BigInt value that represents <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) / 2<sup>-<var>y</var></sup>, rounding down to the nearest <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, including for negative numbers.</li></ol></li><li>Return the BigInt value that represents <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &#215; 2<sup><var>y</var></sup>.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">Semantics here should be equivalent to a bitwise shift, treating the BigInt as an infinite length string of binary two's complement digits.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-multiply": {"num": "6.1.6.1.4", "title": "#sec-numeric-types-number-multiply Number::multiply ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-multiply\" type=\"numeric method\" oldids=\"sec-applying-the-mul-operator\" aoid=\"Number::multiply\"><span id=\"sec-applying-the-mul-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-multiply\">#sec-numeric-types-number-multiply</span> Number::multiply ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::multiply takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs multiplication according to the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic, producing the product of <var>x</var> and <var>y</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> or <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>y</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>Return -<var>x</var>.</li></ol></li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>y</var>.</li><li>Return -<var>y</var>.</li></ol></li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &#215; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>Finite-precision multiplication is commutative, but not always associative.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-samevalue": {"num": "7.2.10", "title": "#sec-samevalue SameValue ( x, y )", "html": "<emu-clause id=\"sec-samevalue\" type=\"abstract operation\" aoid=\"SameValue\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-samevalue\">#sec-samevalue</span> SameValue ( <var>x</var>, <var>y</var> )</h1>\n      <p>The abstract operation SameValue takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It returns a completion record whose [[Type]] is <emu-const>normal</emu-const> and whose [[Value]] is a Boolean indicating whether or not the two arguments are the same value. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number or BigInt, then<ol><li>Return !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>)::sameValue(<var>x</var>, <var>y</var>).</li></ol></li><li>Return !&#160;<emu-xref aoid=\"SameValueNonNumeric\"><a href=\"#sec-samevaluenonnumeric\">SameValueNonNumeric</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>This algorithm differs from the <emu-xref aoid=\"IsStrictlyEqual\"><a href=\"#sec-isstrictlyequal\">IsStrictlyEqual</a></emu-xref> Algorithm by treating all <emu-val>NaN</emu-val> values as equivalent and by differentiating <emu-val>+0</emu-val><sub>&#120125;</sub> from <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-numeric-types-bigint-lessThan": {"num": "6.1.6.2.12", "title": "#sec-numeric-types-bigint-lessThan BigInt::lessThan ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-lessThan\" type=\"numeric method\" aoid=\"BigInt::lessThan\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-lessThan\">#sec-numeric-types-bigint-lessThan</span> BigInt::lessThan ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::lessThan takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-isgenericdescriptor": {"num": "6.2.5.3", "title": "#sec-isgenericdescriptor IsGenericDescriptor ( Desc )", "html": "<emu-clause id=\"sec-isgenericdescriptor\" type=\"abstract operation\" aoid=\"IsGenericDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isgenericdescriptor\">#sec-isgenericdescriptor</span> IsGenericDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation IsGenericDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsAccessorDescriptor\"><a href=\"#sec-isaccessordescriptor\">IsAccessorDescriptor</a></emu-xref>(<var>Desc</var>) and <emu-xref aoid=\"IsDataDescriptor\"><a href=\"#sec-isdatadescriptor\">IsDataDescriptor</a></emu-xref>(<var>Desc</var>) are both <emu-val>false</emu-val>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-runtime-semantics": {"num": "5.2.3", "title": "#sec-runtime-semantics Runtime Semantics", "html": "<emu-clause id=\"sec-runtime-semantics\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics\">#sec-runtime-semantics</span> Runtime Semantics</h1>\n      <p>Algorithms which specify semantics that must be called at runtime are called <dfn>runtime semantics</dfn>. Runtime semantics are defined by <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> or syntax-directed operations. Such algorithms always return a completion record.</p>\n      <div id=\"excluded-sec-implicit-completion-values\"><h1><span class=\"secnum\">5.2.3.1</span>#sec-implicit-completion-values Implicit Completion Values</h1>...</div><div id=\"excluded-sec-throw-an-exception\"><h1><span class=\"secnum\">5.2.3.2</span>#sec-throw-an-exception Throw an Exception</h1>...</div><div id=\"excluded-sec-returnifabrupt\"><h1><span class=\"secnum\">5.2.3.3</span>#sec-returnifabrupt ReturnIfAbrupt</h1>...</div><div id=\"excluded-sec-returnifabrupt-shorthands\"><h1><span class=\"secnum\">5.2.3.4</span>#sec-returnifabrupt-shorthands ReturnIfAbrupt Shorthands</h1>...</div></emu-clause>\n    "}, "sec-async-module-execution-rejected": {"num": "16.2.1.5.2.5", "title": "#sec-async-module-execution-rejected AsyncModuleExecutionRejected ( module, error )", "html": "<emu-clause id=\"sec-async-module-execution-rejected\" type=\"abstract operation\" aoid=\"AsyncModuleExecutionRejected\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-module-execution-rejected\">#sec-async-module-execution-rejected</span> AsyncModuleExecutionRejected ( <var>module</var>, <var>error</var> )</h1>\n            <p>The abstract operation AsyncModuleExecutionRejected takes arguments <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>) and <var>error</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n            <emu-alg><ol><li>If <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is not <emu-const>empty</emu-const>.</li><li>Return.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[AsyncEvaluation]] is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is <emu-const>empty</emu-const>.</li><li>Set <var>module</var>.[[EvaluationError]] to <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>error</var>).</li><li>Set <var>module</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> of <var>module</var>.[[AsyncParentModules]], do<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionRejected\"><a href=\"#sec-async-module-execution-rejected\">AsyncModuleExecutionRejected</a></emu-xref>(<var>m</var>, <var>error</var>).</li></ol></li><li>If <var>module</var>.[[TopLevelCapability]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[CycleRoot]] is <var>module</var>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>module</var>.[[TopLevelCapability]].[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>error</var> &#187;).</li></ol></li></ol></emu-alg>\n          </emu-clause>\n        "}, "sec-createbytedatablock": {"num": "6.2.8.1", "title": "#sec-createbytedatablock CreateByteDataBlock ( size )", "html": "<emu-clause id=\"sec-createbytedatablock\" type=\"abstract operation\" aoid=\"CreateByteDataBlock\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-createbytedatablock\">#sec-createbytedatablock</span> CreateByteDataBlock ( <var>size</var> )</h1>\n        <p>The abstract operation CreateByteDataBlock takes argument <var>size</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>db</var> be a new <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Set all of the bytes of <var>db</var> to 0.</li><li>Return <var>db</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-getthisvalue": {"num": "6.2.4.7", "title": "#sec-getthisvalue GetThisValue ( V )", "html": "<emu-clause id=\"sec-getthisvalue\" type=\"abstract operation\" aoid=\"GetThisValue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getthisvalue\">#sec-getthisvalue</span> GetThisValue ( <var>V</var> )</h1>\n        <p>The abstract operation GetThisValue takes argument <var>V</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsPropertyReference\"><a href=\"#sec-ispropertyreference\">IsPropertyReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>.</li><li>If <emu-xref aoid=\"IsSuperReference\"><a href=\"#sec-issuperreference\">IsSuperReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, return <var>V</var>.[[ThisValue]]; otherwise return <var>V</var>.[[Base]].</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-bigint-bitwiseAND": {"num": "6.1.6.2.20", "title": "#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseAND\" type=\"numeric method\" aoid=\"BigInt::bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseAND\">#sec-numeric-types-bigint-bitwiseAND</span> BigInt::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseAND takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-sameValueZero": {"num": "6.1.6.2.15", "title": "#sec-numeric-types-bigint-sameValueZero BigInt::sameValueZero ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-sameValueZero\" type=\"numeric method\" aoid=\"BigInt::sameValueZero\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-sameValueZero\">#sec-numeric-types-bigint-sameValueZero</span> BigInt::sameValueZero ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::sameValueZero takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigInt::equal\"><a href=\"#sec-numeric-types-bigint-equal\">BigInt::equal</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-async-module-execution-fulfilled": {"num": "16.2.1.5.2.4", "title": "#sec-async-module-execution-fulfilled AsyncModuleExecutionFulfilled ( module )", "html": "<emu-clause id=\"sec-async-module-execution-fulfilled\" type=\"abstract operation\" aoid=\"AsyncModuleExecutionFulfilled\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-module-execution-fulfilled\">#sec-async-module-execution-fulfilled</span> AsyncModuleExecutionFulfilled ( <var>module</var> )</h1>\n            <p>The abstract operation AsyncModuleExecutionFulfilled takes argument <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>). It performs the following steps when called:</p>\n            <emu-alg><ol><li>If <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is not <emu-const>empty</emu-const>.</li><li>Return.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[AsyncEvaluation]] is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is <emu-const>empty</emu-const>.</li><li>Set <var>module</var>.[[AsyncEvaluation]] to <emu-val>false</emu-val>.</li><li>Set <var>module</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>If <var>module</var>.[[TopLevelCapability]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[CycleRoot]] is <var>module</var>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>module</var>.[[TopLevelCapability]].[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Let <var>execList</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Perform !&#160;<emu-xref aoid=\"GatherAvailableAncestors\"><a href=\"#sec-gather-available-ancestors\">GatherAvailableAncestors</a></emu-xref>(<var>module</var>, <var>execList</var>).</li><li>Let <var>sortedExecList</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the elements of <var>execList</var>, in the order in which they had their [[AsyncEvaluation]] fields set to <emu-val>true</emu-val> in <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: All elements of <var>sortedExecList</var> have their [[AsyncEvaluation]] field set to <emu-val>true</emu-val>, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to <emu-const>empty</emu-const>.</li><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> of <var>sortedExecList</var>, do<ol><li>If <var>m</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[EvaluationError]] is not <emu-const>empty</emu-const>.</li></ol></li><li>Else if <var>m</var>.[[HasTLA]] is <emu-val>true</emu-val>, then<ol><li>Perform !&#160;<emu-xref aoid=\"ExecuteAsyncModule\"><a href=\"#sec-execute-async-module\">ExecuteAsyncModule</a></emu-xref>(<var>m</var>).</li></ol></li><li>Else,<ol><li>Let <var>result</var> be <var>m</var>.ExecuteModule().</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionRejected\"><a href=\"#sec-async-module-execution-rejected\">AsyncModuleExecutionRejected</a></emu-xref>(<var>m</var>, <var>result</var>.[[Value]]).</li></ol></li><li>Else,<ol><li>Set <var>m</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>If <var>m</var>.[[TopLevelCapability]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[CycleRoot]] is <var>m</var>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>m</var>.[[TopLevelCapability]].[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li></ol></li></ol></li></ol></li></ol></emu-alg>\n          </emu-clause>\n\n          "}, "sec-static-semantics-classelementevaluation": {"num": "15.7.13", "title": "#sec-static-semantics-classelementevaluation Runtime Semantics: ClassElementEvaluation", "html": "<emu-clause id=\"sec-static-semantics-classelementevaluation\" type=\"sdo\" aoid=\"ClassElementEvaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-static-semantics-classelementevaluation\">#sec-static-semantics-classelementevaluation</span> Runtime Semantics: ClassElementEvaluation</h1>\n      <p>The syntax-directed operation ClassElementEvaluation takes argument <var>object</var>. It is defined piecewise over the following productions:</p>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"bwbyf1-5\" id=\"prod-tPq9hD-G\">\n        <emu-nt><a href=\"#prod-FieldDefinition\">FieldDefinition</a></emu-nt>\n        <emu-t>;</emu-t>\n    </emu-rhs>\n</emu-production>\n<emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"cpyv1xvc\" id=\"prod-Cn1oLmsN\">\n        <emu-t>static</emu-t>\n        <emu-nt><a href=\"#prod-FieldDefinition\">FieldDefinition</a></emu-nt>\n        <emu-t>;</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"ClassFieldDefinitionEvaluation\"><a href=\"#sec-runtime-semantics-classfielddefinitionevaluation\">ClassFieldDefinitionEvaluation</a></emu-xref> of <emu-nt><a href=\"#prod-FieldDefinition\">FieldDefinition</a></emu-nt> with argument <var>object</var>.</li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"s8ilfl9g\" id=\"prod-Qe_eKZ3f\"><emu-nt><a href=\"#prod-MethodDefinition\">MethodDefinition</a></emu-nt></emu-rhs>\n</emu-production>\n<emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"-ljgtrpo\" id=\"prod-DNhqQKHO\">\n        <emu-t>static</emu-t>\n        <emu-nt><a href=\"#prod-MethodDefinition\">MethodDefinition</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"MethodDefinitionEvaluation\"><a href=\"#sec-runtime-semantics-methoddefinitionevaluation\">MethodDefinitionEvaluation</a></emu-xref> of <emu-nt><a href=\"#prod-MethodDefinition\">MethodDefinition</a></emu-nt> with arguments <var>object</var> and <emu-val>false</emu-val>.</li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"2ui-f2qn\" id=\"prod-Hb23PvBK\"><emu-nt><a href=\"#prod-ClassStaticBlock\">ClassStaticBlock</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"ClassStaticBlockDefinitionEvaluation\"><a href=\"#sec-runtime-semantics-classstaticblockdefinitionevaluation\">ClassStaticBlockDefinitionEvaluation</a></emu-xref> of <emu-nt><a href=\"#prod-ClassStaticBlock\">ClassStaticBlock</a></emu-nt> with argument <var>object</var>.</li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"sg2sawim\" id=\"prod-V88LvFxI\"><emu-t>;</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return.</li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-putvalue": {"num": "6.2.4.6", "title": "#sec-putvalue PutValue ( V, W )", "html": "<emu-clause id=\"sec-putvalue\" type=\"abstract operation\" aoid=\"PutValue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-putvalue\">#sec-putvalue</span> PutValue ( <var>V</var>, <var>W</var> )</h1>\n        <p>The abstract operation PutValue takes arguments <var>V</var> and <var>W</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>V</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>W</var>).</li><li>If <var>V</var> is not a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>If <emu-xref aoid=\"IsUnresolvableReference\"><a href=\"#sec-isunresolvablereference\">IsUnresolvableReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li>If <var>V</var>.[[Strict]] is <emu-val>true</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Let <var>globalObj</var> be <emu-xref aoid=\"GetGlobalObject\"><a href=\"#sec-getglobalobject\">GetGlobalObject</a></emu-xref>().</li><li>Return ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>globalObj</var>, <var>V</var>.[[ReferencedName]], <var>W</var>, <emu-val>false</emu-val>).</li></ol></li><li>If <emu-xref aoid=\"IsPropertyReference\"><a href=\"#sec-ispropertyreference\">IsPropertyReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li id=\"step-putvalue-toobject\">Let <var>baseObj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>V</var>.[[Base]]).</li><li>If <emu-xref aoid=\"IsPrivateReference\"><a href=\"#sec-isprivatereference\">IsPrivateReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"PrivateSet\"><a href=\"#sec-privateset\">PrivateSet</a></emu-xref>(<var>baseObj</var>, <var>V</var>.[[ReferencedName]], <var>W</var>).</li></ol></li><li>Let <var>succeeded</var> be ? <var>baseObj</var>.[[Set]](<var>V</var>.[[ReferencedName]], <var>W</var>, <emu-xref aoid=\"GetThisValue\"><a href=\"#sec-getthisvalue\">GetThisValue</a></emu-xref>(<var>V</var>)).</li><li>If <var>succeeded</var> is <emu-val>false</emu-val> and <var>V</var>.[[Strict]] is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return.</li></ol></li><li>Else,<ol><li>Let <var>base</var> be <var>V</var>.[[Base]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Return ? <var>base</var>.SetMutableBinding(<var>V</var>.[[ReferencedName]], <var>W</var>, <var>V</var>.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\" class=\"excluded-xref\" excluded-id=\"sec-environment-records\">#sec-environment-records</a></emu-xref>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The object that may be created in step <emu-xref href=\"#step-putvalue-toobject\"><a href=\"#step-putvalue-toobject\">5.a</a></emu-xref> is not accessible outside of the above abstract operation and the <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-subtract": {"num": "6.1.6.1.8", "title": "#sec-numeric-types-number-subtract Number::subtract ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-subtract\" type=\"numeric method\" aoid=\"Number::subtract\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-subtract\">#sec-numeric-types-number-subtract</span> Number::subtract ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::subtract takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs subtraction, producing the difference of its operands; <var>x</var> is the minuend and <var>y</var> is the subtrahend. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>(<var>x</var>, <emu-xref aoid=\"Number::unaryMinus\"><a href=\"#sec-numeric-types-number-unaryMinus\">Number::unaryMinus</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>It is always the case that <code>x - y</code> produces the same result as <code>x + (-y)</code>.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-importedlocalnames": {"num": "16.2.1.2", "title": "#sec-importedlocalnames Static Semantics: ImportedLocalNames ( importEntries )", "html": "<emu-clause id=\"sec-importedlocalnames\" type=\"abstract operation\" aoid=\"ImportedLocalNames\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-importedlocalnames\">#sec-importedlocalnames</span> Static Semantics: ImportedLocalNames ( <var>importEntries</var> )</h1>\n        <p>The abstract operation ImportedLocalNames takes argument <var>importEntries</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Records</a></emu-xref> (see <emu-xref href=\"#table-importentry-record-fields\"><a href=\"#table-importentry-record-fields\" class=\"excluded-xref\" excluded-id=\"table-importentry-record-fields\">#table-importentry-record-fields</a></emu-xref>)). It creates a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of all of the local name bindings defined by <var>importEntries</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>localNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Record</a></emu-xref> <var>i</var> of <var>importEntries</var>, do<ol><li>Append <var>i</var>.[[LocalName]] to <var>localNames</var>.</li></ol></li><li>Return <var>localNames</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isstrictlyequal": {"num": "7.2.15", "title": "#sec-isstrictlyequal IsStrictlyEqual ( x, y )", "html": "<emu-clause id=\"sec-isstrictlyequal\" type=\"abstract operation\" oldids=\"sec-strict-equality-comparison\" aoid=\"IsStrictlyEqual\"><span id=\"sec-strict-equality-comparison\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isstrictlyequal\">#sec-isstrictlyequal</span> IsStrictlyEqual ( <var>x</var>, <var>y</var> )</h1>\n      <p>The abstract operation IsStrictlyEqual takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It provides the semantics for the comparison <var>x</var> === <var>y</var>, returning <emu-val>true</emu-val> or <emu-val>false</emu-val>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number or BigInt, then<ol><li>Return !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>)::equal(<var>x</var>, <var>y</var>).</li></ol></li><li>Return !&#160;<emu-xref aoid=\"SameValueNonNumeric\"><a href=\"#sec-samevaluenonnumeric\">SameValueNonNumeric</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>This algorithm differs from the <emu-xref aoid=\"SameValue\"><a href=\"#sec-samevalue\">SameValue</a></emu-xref> Algorithm in its treatment of signed zeroes and NaNs.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-applystringornumericbinaryoperator": {"num": "13.15.3", "title": "#sec-applystringornumericbinaryoperator ApplyStringOrNumericBinaryOperator ( lval, opText, rval )", "html": "<emu-clause id=\"sec-applystringornumericbinaryoperator\" type=\"abstract operation\" aoid=\"ApplyStringOrNumericBinaryOperator\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</span> ApplyStringOrNumericBinaryOperator ( <var>lval</var>, <var>opText</var>, <var>rval</var> )</h1>\n      <p>The abstract operation ApplyStringOrNumericBinaryOperator takes arguments <var>lval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>opText</var> (a sequence of Unicode code points), and <var>rval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>opText</var> is present in the table in step <emu-xref href=\"#step-applystringornumericbinaryoperator-operations-table\"><a href=\"#step-applystringornumericbinaryoperator-operations-table\" class=\"excluded-xref\" excluded-id=\"step-applystringornumericbinaryoperator-operations-table\">#step-applystringornumericbinaryoperator-operations-table</a></emu-xref>.</li><li>If <var>opText</var> is <code>+</code>, then<ol><li id=\"step-binary-op-toprimitive-lval\">Let <var>lprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>lval</var>).</li><li id=\"step-binary-op-toprimitive-rval\">Let <var>rprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>rval</var>).</li><li id=\"step-binary-op-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lprim</var>) is String or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rprim</var>) is String, then<ol><li>Let <var>lstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>lprim</var>).</li><li>Let <var>rstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>rprim</var>).</li><li>Return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of <var>lstr</var> and <var>rstr</var>.</li></ol></li><li>Set <var>lval</var> to <var>lprim</var>.</li><li>Set <var>rval</var> to <var>rprim</var>.</li></ol></li><li>NOTE: At this point, it must be a numeric operation.</li><li>Let <var>lnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>lval</var>).</li><li>Let <var>rnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>rval</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rnum</var>), throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>).</li><li id=\"step-applystringornumericbinaryoperator-operations-table\">Let <var>operation</var> be the abstract operation associated with <var>opText</var> in the following table:\n          <figure>\n            <table class=\"lightweight-table\">\n              <tbody>\n                <tr><th> <var>opText</var>       </th><th> <var>operation</var>             </th></tr>\n                <tr><td> <code>**</code>           </td><td> <var>T</var>::exponentiate       </td></tr>\n                <tr><td> <code>*</code>            </td><td> <var>T</var>::multiply           </td></tr>\n                <tr><td> <code>/</code>            </td><td> <var>T</var>::divide             </td></tr>\n                <tr><td> <code>%</code>            </td><td> <var>T</var>::remainder          </td></tr>\n                <tr><td> <code>+</code>            </td><td> <var>T</var>::add                </td></tr>\n                <tr><td> <code>-</code>            </td><td> <var>T</var>::subtract           </td></tr>\n                <tr><td> <code>&lt;&lt;</code>     </td><td> <var>T</var>::leftShift          </td></tr>\n                <tr><td> <code>&gt;&gt;</code>     </td><td> <var>T</var>::signedRightShift   </td></tr>\n                <tr><td> <code>&gt;&gt;&gt;</code> </td><td> <var>T</var>::unsignedRightShift </td></tr>\n                <tr><td> <code>&amp;</code>        </td><td> <var>T</var>::bitwiseAND         </td></tr>\n                <tr><td> <code>^</code>            </td><td> <var>T</var>::bitwiseXOR         </td></tr>\n                <tr><td> <code>|</code>            </td><td> <var>T</var>::bitwiseOR          </td></tr>\n              </tbody>\n            </table>\n          </figure></li><li>Return ? <var>operation</var>(<var>lnum</var>, <var>rnum</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>No hint is provided in the calls to <emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref> in steps <emu-xref href=\"#step-binary-op-toprimitive-lval\"><a href=\"#step-binary-op-toprimitive-lval\">2.a</a></emu-xref> and <emu-xref href=\"#step-binary-op-toprimitive-rval\"><a href=\"#step-binary-op-toprimitive-rval\">2.b</a></emu-xref>. All standard objects except Dates handle the absence of a hint as if <emu-const>number</emu-const> were given; Dates handle the absence of a hint as if <emu-const>string</emu-const> were given. <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">Exotic objects</a></emu-xref> may handle the absence of a hint in some other manner.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">2.c</a></emu-xref> differs from step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> of the <emu-xref aoid=\"IsLessThan\"><a href=\"#sec-islessthan\">IsLessThan</a></emu-xref> algorithm, by using the logical-or operation instead of the logical-and operation.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-isunresolvablereference": {"num": "6.2.4.2", "title": "#sec-isunresolvablereference IsUnresolvableReference ( V )", "html": "<emu-clause id=\"sec-isunresolvablereference\" type=\"abstract operation\" oldids=\"ao-isunresolvablereference\" aoid=\"IsUnresolvableReference\"><span id=\"ao-isunresolvablereference\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isunresolvablereference\">#sec-isunresolvablereference</span> IsUnresolvableReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsUnresolvableReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[Base]] is <emu-const>unresolvable</emu-const>, return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-sameValueZero": {"num": "6.1.6.1.15", "title": "#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValueZero\" type=\"numeric method\" aoid=\"Number::sameValueZero\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValueZero\">#sec-numeric-types-number-sameValueZero</span> Number::sameValueZero ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::sameValueZero takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-toprimitive": {"num": "7.1.1", "title": "#sec-toprimitive ToPrimitive ( input [ , preferredType ] )", "html": "<emu-clause id=\"sec-toprimitive\" type=\"abstract operation\" oldids=\"table-9\" aoid=\"ToPrimitive\"><span id=\"table-9\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-toprimitive\">#sec-toprimitive</span> ToPrimitive ( <var>input</var> [ , <var>preferredType</var> ] )</h1>\n      <p>The abstract operation ToPrimitive takes argument <var>input</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and optional argument <var>preferredType</var> (<emu-const>string</emu-const> or <emu-const>number</emu-const>). It converts its <var>input</var> argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint <var>preferredType</var> to favour that type. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>input</var>) is Object, then<ol><li>Let <var>exoticToPrim</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>input</var>, <emu-xref href=\"#sec-well-known-symbols\"><a href=\"#sec-well-known-symbols\">@@toPrimitive</a></emu-xref>).</li><li>If <var>exoticToPrim</var> is not <emu-val>undefined</emu-val>, then<ol><li>If <var>preferredType</var> is not present, let <var>hint</var> be <emu-val>\"default\"</emu-val>.</li><li>Else if <var>preferredType</var> is <emu-const>string</emu-const>, let <var>hint</var> be <emu-val>\"string\"</emu-val>.</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>preferredType</var> is <emu-const>number</emu-const>.</li><li>Let <var>hint</var> be <emu-val>\"number\"</emu-val>.</li></ol></li><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>exoticToPrim</var>, <var>input</var>, &#171; <var>hint</var> &#187;).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>result</var>) is not Object, return <var>result</var>.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>If <var>preferredType</var> is not present, let <var>preferredType</var> be <emu-const>number</emu-const>.</li><li>Return ?&#160;<emu-xref aoid=\"OrdinaryToPrimitive\"><a href=\"#sec-ordinarytoprimitive\">OrdinaryToPrimitive</a></emu-xref>(<var>input</var>, <var>preferredType</var>).</li></ol></li><li>Return <var>input</var>.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>When ToPrimitive is called without a hint, then it generally behaves as if the hint were <emu-const>number</emu-const>. However, objects may over-ride this behaviour by defining a <emu-xref href=\"#sec-well-known-symbols\"><a href=\"#sec-well-known-symbols\">@@toPrimitive</a></emu-xref> method. Of the objects defined in this specification only Dates (see <emu-xref href=\"#sec-date.prototype-@@toprimitive\"><a href=\"#sec-date.prototype-@@toprimitive\" class=\"excluded-xref\" excluded-id=\"sec-date.prototype-@@toprimitive\">#sec-date.prototype-@@toprimitive</a></emu-xref>) and Symbol objects (see <emu-xref href=\"#sec-symbol.prototype-@@toprimitive\"><a href=\"#sec-symbol.prototype-@@toprimitive\" class=\"excluded-xref\" excluded-id=\"sec-symbol.prototype-@@toprimitive\">#sec-symbol.prototype-@@toprimitive</a></emu-xref>) over-ride the default ToPrimitive behaviour. Dates treat the absence of a hint as if the hint were <emu-const>string</emu-const>.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-ordinarytoprimitive\"><h1><span class=\"secnum\">7.1.1.1</span>#sec-ordinarytoprimitive OrdinaryToPrimitive ( O, hint )</h1>...</div></emu-clause>\n\n    "}, "sec-binaryand": {"num": "6.1.6.2.16", "title": "#sec-binaryand BinaryAnd ( x, y )", "html": "<emu-clause id=\"sec-binaryand\" type=\"abstract operation\" aoid=\"BinaryAnd\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-binaryand\">#sec-binaryand</span> BinaryAnd ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BinaryAnd takes arguments <var>x</var> (0 or 1) and <var>y</var> (0 or 1). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is 1 and <var>y</var> is 1, return 1.</li><li>Else, return 0.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-leftShift": {"num": "6.1.6.1.9", "title": "#sec-numeric-types-number-leftShift Number::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-leftShift\" type=\"numeric method\" aoid=\"Number::leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-leftShift\">#sec-numeric-types-number-leftShift</span> Number::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::leftShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of left shifting <var>lnum</var> by <var>shiftCount</var> bits. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-unaryMinus": {"num": "6.1.6.1.1", "title": "#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-unaryMinus\" type=\"numeric method\" aoid=\"Number::unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unaryMinus\">#sec-numeric-types-number-unaryMinus</span> Number::unaryMinus ( <var>x</var> )</h1>\n          <p>The abstract operation Number::unaryMinus takes argument <var>x</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>Return the result of negating <var>x</var>; that is, compute a Number with the same magnitude but opposite sign.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-atomics.add": {"num": "25.4.3", "title": "#sec-atomics.add Atomics.add ( typedArray, index, value )", "html": "<emu-clause id=\"sec-atomics.add\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atomics.add\">#sec-atomics.add</span> Atomics.add ( <var>typedArray</var>, <var>index</var>, <var>value</var> )</h1>\n      <p>The following steps are taken:</p>\n      <emu-alg><ol><li>Let <var>type</var> be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>add</var> be a new <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> with parameters (<var>xBytes</var>, <var>yBytes</var>) that captures <var>type</var> and <var>isLittleEndian</var> and performs the following steps atomically when called:<ol><li>Let <var>x</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>xBytes</var>, <var>isLittleEndian</var>).</li><li>Let <var>y</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>yBytes</var>, <var>isLittleEndian</var>).</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>).</li><li>Let <var>sum</var> be <var>T</var>::add(<var>x</var>, <var>y</var>).</li><li>Let <var>sumBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>sum</var>, <var>isLittleEndian</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>sumBytes</var>, <var>xBytes</var>, and <var>yBytes</var> have the same number of elements.</li><li>Return <var>sumBytes</var>.</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"AtomicReadModifyWrite\"><a href=\"#sec-atomicreadmodifywrite\">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <var>add</var>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-numeric-types-number-divide": {"num": "6.1.6.1.5", "title": "#sec-numeric-types-number-divide Number::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-divide\" type=\"numeric method\" oldids=\"sec-applying-the-div-operator\" aoid=\"Number::divide\"><span id=\"sec-applying-the-div-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-divide\">#sec-numeric-types-number-divide</span> Number::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::divide takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs division according to the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic, producing the quotient of <var>x</var> and <var>y</var> where <var>x</var> is the dividend and <var>y</var> is the divisor. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> or <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>y</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>Return -<var>x</var>.</li></ol></li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>-0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>y</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>Return -<var>x</var>.</li></ol></li><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) / <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-asyncgeneratordrainqueue": {"num": "27.6.3.10", "title": "#sec-asyncgeneratordrainqueue AsyncGeneratorDrainQueue ( generator )", "html": "<emu-clause id=\"sec-asyncgeneratordrainqueue\" type=\"abstract operation\" aoid=\"AsyncGeneratorDrainQueue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratordrainqueue\">#sec-asyncgeneratordrainqueue</span> AsyncGeneratorDrainQueue ( <var>generator</var> )</h1>\n        <p>The abstract operation AsyncGeneratorDrainQueue takes argument <var>generator</var> (an AsyncGenerator). It drains the generator's AsyncGeneratorQueue until it encounters an <emu-xref href=\"#sec-asyncgeneratorrequest-records\"><a href=\"#sec-asyncgeneratorrequest-records\">AsyncGeneratorRequest</a></emu-xref> which holds a completion whose type is <emu-const>return</emu-const>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var>.[[AsyncGeneratorState]] is <emu-const>completed</emu-const>.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li>If <var>queue</var> is empty, return.</li><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>next</var> be the first element of <var>queue</var>.</li><li>Let <var>completion</var> be <var>next</var>.[[Completion]].</li><li>If <var>completion</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>awaiting-return</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorAwaitReturn\"><a href=\"#sec-asyncgeneratorawaitreturn\">AsyncGeneratorAwaitReturn</a></emu-xref>(<var>generator</var>).</li><li>Set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li><li>Else,<ol><li>If <var>completion</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Set <var>completion</var> to <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorCompleteStep\"><a href=\"#sec-asyncgeneratorcompletestep\">AsyncGeneratorCompleteStep</a></emu-xref>(<var>generator</var>, <var>completion</var>, <emu-val>true</emu-val>).</li><li>If <var>queue</var> is empty, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-postfix-decrement-operator-runtime-semantics-evaluation": {"num": "13.4.3.1", "title": "#sec-postfix-decrement-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-postfix-decrement-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-postfix-decrement-operator-runtime-semantics-evaluation\">#sec-postfix-decrement-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"jr0tcoqg\">\n        <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>\n        <emu-t>--</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>lhs</var> be the result of evaluating <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>lhs</var>)).</li><li>Let <var>newValue</var> be !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::subtract(<var>oldValue</var>, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>)::unit).</li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhs</var>, <var>newValue</var>).</li><li>Return <var>oldValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-bitwiseNOT": {"num": "6.1.6.2.2", "title": "#sec-numeric-types-bigint-bitwiseNOT BigInt::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseNOT\" type=\"numeric method\" aoid=\"BigInt::bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseNOT\">#sec-numeric-types-bigint-bitwiseNOT</span> BigInt::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseNOT takes argument <var>x</var> (a BigInt). It returns the one's complement of <var>x</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return -<var>x</var> - <emu-val>1</emu-val><sub>&#8484;</sub>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-remainder": {"num": "6.1.6.1.6", "title": "#sec-numeric-types-number-remainder Number::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-number-remainder\" type=\"numeric method\" oldids=\"sec-applying-the-mod-operator\" aoid=\"Number::remainder\"><span id=\"sec-applying-the-mod-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-remainder\">#sec-numeric-types-number-remainder</span> Number::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The abstract operation Number::remainder takes arguments <var>n</var> (a Number) and <var>d</var> (a Number). It yields the remainder from an implied division of its operands where <var>n</var> is the dividend and <var>d</var> is the divisor. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>n</var> is <emu-val>NaN</emu-val> or <var>d</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>n</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>n</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>d</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>d</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <var>n</var>.</li><li>If <var>d</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>d</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>n</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>n</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <var>n</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> and <var>d</var> are finite and non-zero.</li><li>Let <var>r</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>n</var>) - (<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>d</var>) &#215; <var>q</var>) where <var>q</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is negative if and only if <var>n</var> and <var>d</var> have opposite sign, and whose magnitude is as large as possible without exceeding the magnitude of <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>n</var>) / <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>d</var>).</li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>r</var>).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">The result of a floating-point remainder operation as computed by the <code>%</code> operator is not the same as the &#8220;remainder&#8221; operation defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> &#8220;remainder&#8221; operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual <emu-not-ref>integer</emu-not-ref> remainder operator. Instead the ECMAScript language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the Java <emu-not-ref>integer</emu-not-ref> remainder operator; this may be compared with the C library function fmod.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-signedRightShift": {"num": "6.1.6.1.10", "title": "#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-signedRightShift\" type=\"numeric method\" aoid=\"Number::signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-signedRightShift\">#sec-numeric-types-number-signedRightShift</span> Number::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::signedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of performing a sign-extending right shift of <var>lnum</var> by <var>shiftCount</var> bits. The most significant bit is propagated. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-isprivatereference": {"num": "6.2.4.4", "title": "#sec-isprivatereference IsPrivateReference ( V )", "html": "<emu-clause id=\"sec-isprivatereference\" type=\"abstract operation\" aoid=\"IsPrivateReference\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isprivatereference\">#sec-isprivatereference</span> IsPrivateReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsPrivateReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[ReferencedName]] is a <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref>, return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-samevaluezero": {"num": "7.2.11", "title": "#sec-samevaluezero SameValueZero ( x, y )", "html": "<emu-clause id=\"sec-samevaluezero\" type=\"abstract operation\" aoid=\"SameValueZero\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-samevaluezero\">#sec-samevaluezero</span> SameValueZero ( <var>x</var>, <var>y</var> )</h1>\n      <p>The abstract operation SameValueZero takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It returns a completion record whose [[Type]] is <emu-const>normal</emu-const> and whose [[Value]] is a Boolean indicating whether or not the two arguments are the same value (ignoring the difference between <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>). It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number or BigInt, then<ol><li>Return !&#160;<emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>)::sameValueZero(<var>x</var>, <var>y</var>).</li></ol></li><li>Return !&#160;<emu-xref aoid=\"SameValueNonNumeric\"><a href=\"#sec-samevaluenonnumeric\">SameValueNonNumeric</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>SameValueZero differs from <emu-xref aoid=\"SameValue\"><a href=\"#sec-samevalue\">SameValue</a></emu-xref> only in that it treats <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub> as equivalent.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-numeric-types-number-exponentiate": {"num": "6.1.6.1.3", "title": "#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-number-exponentiate\" type=\"numeric method\" oldids=\"sec-applying-the-exp-operator\" aoid=\"Number::exponentiate\"><span id=\"sec-applying-the-exp-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-exponentiate\">#sec-numeric-types-number-exponentiate</span> Number::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>The abstract operation Number::exponentiate takes arguments <var>base</var> (a Number) and <var>exponent</var> (a Number). It returns an <emu-xref href=\"#implementation-approximated\"><a href=\"#implementation-approximated\">implementation-approximated</a></emu-xref> value representing the result of raising <var>base</var> to the <var>exponent</var> power. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>exponent</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>exponent</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>exponent</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>base</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>base</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>base</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Else,<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li></ol></li><li>If <var>base</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>base</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Else,<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is finite and is neither <emu-val>+0</emu-val><sub>&#120125;</sub> nor <emu-val>-0</emu-val><sub>&#120125;</sub>.</li><li>If <var>exponent</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &gt; 1, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) is 1, return <emu-val>NaN</emu-val>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &lt; 1, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>exponent</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &gt; 1, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) is 1, return <emu-val>NaN</emu-val>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &lt; 1, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>exponent</var> is finite and is neither <emu-val>+0</emu-val><sub>&#120125;</sub> nor <emu-val>-0</emu-val><sub>&#120125;</sub>.</li><li>If <var>base</var> &lt; <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>exponent</var> is not an <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>NaN</emu-val>.</li><li>Return an <emu-xref href=\"#implementation-approximated\"><a href=\"#implementation-approximated\">implementation-approximated</a></emu-xref> value representing the result of raising <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>) to the <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>exponent</var>) power.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>The result of <var>base</var> <code>**</code> <var>exponent</var> when <var>base</var> is <emu-val>1</emu-val><sub>&#120125;</sub> or <emu-val>-1</emu-val><sub>&#120125;</sub> and <var>exponent</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, or when <var>base</var> is <emu-val>1</emu-val><sub>&#120125;</sub> and <var>exponent</var> is <emu-val>NaN</emu-val>, differs from <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The first edition of ECMAScript specified a result of <emu-val>NaN</emu-val> for this operation, whereas later versions of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> specified <emu-val>1</emu-val><sub>&#120125;</sub>. The historical ECMAScript behaviour is preserved for compatibility reasons.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-unary-minus-operator-runtime-semantics-evaluation": {"num": "13.5.5.1", "title": "#sec-unary-minus-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-unary-minus-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-unary-minus-operator-runtime-semantics-evaluation\">#sec-unary-minus-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UnaryExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"odzkxnu5\">\n        <emu-t>-</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>).</li><li>Return ! <var>T</var>::unaryMinus(<var>oldValue</var>).</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-sameValue": {"num": "6.1.6.2.14", "title": "#sec-numeric-types-bigint-sameValue BigInt::sameValue ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-sameValue\" type=\"numeric method\" aoid=\"BigInt::sameValue\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-sameValue\">#sec-numeric-types-bigint-sameValue</span> BigInt::sameValue ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::sameValue takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigInt::equal\"><a href=\"#sec-numeric-types-bigint-equal\">BigInt::equal</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseXOR": {"num": "6.1.6.1.18", "title": "#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseXOR\" type=\"numeric method\" aoid=\"Number::bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseXOR\">#sec-numeric-types-number-bitwiseXOR</span> Number::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseXOR takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseOR": {"num": "6.1.6.2.22", "title": "#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseOR\" type=\"numeric method\" aoid=\"BigInt::bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseOR\">#sec-numeric-types-bigint-bitwiseOR</span> BigInt::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-tostring": {"num": "6.1.6.2.23", "title": "#sec-numeric-types-bigint-tostring BigInt::toString ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-tostring\" type=\"numeric method\" aoid=\"BigInt::toString\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-tostring\">#sec-numeric-types-bigint-tostring</span> BigInt::toString ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::toString takes argument <var>x</var> (a BigInt). It converts <var>x</var> to String format. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> &lt; <emu-val>0</emu-val><sub>&#8484;</sub>, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of the String <emu-val>\"-\"</emu-val> and ! <emu-xref aoid=\"BigInt::toString\"><a href=\"#sec-numeric-types-bigint-tostring\">BigInt::toString</a></emu-xref>(-<var>x</var>).</li><li>Return the String value consisting of the code units of the digits of the decimal representation of <var>x</var>.</li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-numeric-types-bigint-equal": {"num": "6.1.6.2.13", "title": "#sec-numeric-types-bigint-equal BigInt::equal ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-equal\" type=\"numeric method\" aoid=\"BigInt::equal\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-equal\">#sec-numeric-types-bigint-equal</span> BigInt::equal ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::equal takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) = <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {"table-numeric-type-ops": "Table 2", "table-completion-record-fields": "Table 9", "table-importentry-record-fields": "Table 59", "table-the-typedarray-constructors": "Table 72"}}, "to": {"secList": ["sec-numeric-types-number-tostring", "sec-ecmascript-language-types-bigint-type", "sec-numeric-types", "sec-bigintbitwiseop", "sec-numeric-types-bigint-remainder", "sec-numeric-types-bigint-unsignedRightShift", "sec-issuperreference", "sec-prefix-decrement-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-unaryMinus", "sec-numberbitwiseop", "sec-numeric-types-bigint-exponentiate", "sec-numeric-types-bigint-add", "sec-makeprivatereference", "sec-numeric-types-number-sameValue", "sec-ecmascript-language-types-number-type", "sec-completion-ao", "sec-bitwise-not-operator-runtime-semantics-evaluation", "sec-topropertydescriptor", "sec-isaccessordescriptor", "sec-islessthan", "sec-frompropertydescriptor", "sec-gather-available-ancestors", "sec-numeric-types-bigint-multiply", "sec-numeric-types-bigint-signedRightShift", "sec-numeric-types-number-bitwiseAND", "sec-createsharedbytedatablock", "sec-binaryor", "sec-prefix-increment-operator-runtime-semantics-evaluation", "sec-atomics.sub", "sec-updateempty", "sec-numeric-types-number-unsignedRightShift", "sec-execute-async-module", "sec-copydatablockbytes", "sec-numeric-types-number-lessThan", "sec-numeric-types-bigint-subtract", "sec-throwcompletion", "sec-numeric-types-number-add", "sec-numeric-types-number-equal", "sec-initializereferencedbinding", "sec-binaryxor", "sec-numeric-types-bigint-bitwiseXOR", "sec-completion-record-specification-type", "sec-ispropertyreference", "sec-isdatadescriptor", "sec-numeric-types-number-bitwiseNOT", "sec-getvalue", "sec-normalcompletion", "sec-asyncblockstart", "sec-stringindexof", "sec-completepropertydescriptor", "sec-numeric-types-bigint-divide", "sec-numeric-types-number-bitwiseOR", "sec-postfix-increment-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-leftShift", "sec-numeric-types-number-multiply", "sec-samevalue", "sec-numeric-types-bigint-lessThan", "sec-isgenericdescriptor", "sec-runtime-semantics", "sec-async-module-execution-rejected", "sec-createbytedatablock", "sec-getthisvalue", "sec-numeric-types-bigint-bitwiseAND", "sec-numeric-types-bigint-sameValueZero", "sec-async-module-execution-fulfilled", "sec-static-semantics-classelementevaluation", "sec-putvalue", "sec-numeric-types-number-subtract", "sec-importedlocalnames", "sec-isstrictlyequal", "sec-applystringornumericbinaryoperator", "sec-isunresolvablereference", "sec-numeric-types-number-sameValueZero", "sec-toprimitive", "sec-binaryand", "sec-numeric-types-number-leftShift", "sec-numeric-types-number-unaryMinus", "sec-atomics.add", "sec-numeric-types-number-divide", "sec-asyncgeneratordrainqueue", "sec-postfix-decrement-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-bitwiseNOT", "sec-numeric-types-number-remainder", "sec-numeric-types-number-signedRightShift", "sec-isprivatereference", "sec-samevaluezero", "sec-numeric-types-number-exponentiate", "sec-unary-minus-operator-runtime-semantics-evaluation", "sec-numeric-types-bigint-sameValue", "sec-numeric-types-number-bitwiseXOR", "sec-numeric-types-bigint-bitwiseOR", "sec-numeric-types-bigint-tostring", "sec-numeric-types-bigint-equal"], "secData": {"sec-numeric-types-number-tostring": {"num": "6.1.6.1.20", "title": "#sec-numeric-types-number-tostring Number::toString ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-tostring\" type=\"numeric method\" oldids=\"sec-tostring-applied-to-the-number-type\" aoid=\"Number::toString\"><span id=\"sec-tostring-applied-to-the-number-type\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-tostring\">#sec-numeric-types-number-tostring</span> Number::toString ( <var>x</var> )</h1>\n          <p>The abstract operation Number::toString takes argument <var>x</var> (a Number) and returns a String. It converts <var>x</var> to String format. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return the String <emu-val>\"NaN\"</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <emu-val>-0</emu-val><sub>&#120125;</sub>, return the String <emu-val>\"0\"</emu-val>.</li><li>If <var>x</var> &lt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of <emu-val>\"-\"</emu-val> and ! <emu-xref aoid=\"Number::toString\"><a href=\"#sec-numeric-types-number-tostring\">Number::toString</a></emu-xref>(-<var>x</var>).</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return the String <emu-val>\"Infinity\"</emu-val>.</li><li id=\"step-number-tostring-intermediate-values\">Otherwise, let <var>n</var>, <var>k</var>, and <var>s</var> be <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> such that <var>k</var> &#8805; 1, 10<sup><var>k</var> - 1</sup> &#8804; <var>s</var> &lt; 10<sup><var>k</var></sup>, <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>s</var> &#215; 10<sup><var>n</var> - <var>k</var></sup>) is <var>x</var>, and <var>k</var> is as small as possible. Note that <var>k</var> is the number of digits in the decimal representation of <var>s</var>, that <var>s</var> is not divisible by 10, and that the least significant digit of <var>s</var> is not necessarily uniquely determined by these criteria.</li><li>If <var>k</var> &#8804; <var>n</var> &#8804; 21, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code units of the <var>k</var> digits of the decimal representation of <var>s</var> (in order, with no leading zeroes)</li><li><var>n</var> - <var>k</var> occurrences of the code unit 0x0030 (DIGIT ZERO)</li></ul></li><li>If 0 &lt; <var>n</var> &#8804; 21, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code units of the most significant <var>n</var> digits of the decimal representation of <var>s</var></li><li>the code unit 0x002E (FULL STOP)</li><li>the code units of the remaining <var>k</var> - <var>n</var> digits of the decimal representation of <var>s</var></li></ul></li><li>If -6 &lt; <var>n</var> &#8804; 0, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code unit 0x0030 (DIGIT ZERO)</li><li>the code unit 0x002E (FULL STOP)</li><li>-<var>n</var> occurrences of the code unit 0x0030 (DIGIT ZERO)</li><li>the code units of the <var>k</var> digits of the decimal representation of <var>s</var></li></ul></li><li>Otherwise, if <var>k</var> = 1, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code unit of the single digit of <var>s</var></li><li>the code unit 0x0065 (LATIN SMALL LETTER E)</li><li>the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether <var>n</var> - 1 is positive or negative</li><li>the code units of the decimal representation of the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>n</var> - 1) (with no leading zeroes)</li></ul></li><li>Return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of:<ul><li>the code units of the most significant digit of the decimal representation of <var>s</var></li><li>the code unit 0x002E (FULL STOP)</li><li>the code units of the remaining <var>k</var> - 1 digits of the decimal representation of <var>s</var></li><li>the code unit 0x0065 (LATIN SMALL LETTER E)</li><li>the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS) according to whether <var>n</var> - 1 is positive or negative</li><li>the code units of the decimal representation of the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>n</var> - 1) (with no leading zeroes)</li></ul></li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:</p>\n            <ul>\n              <li>\n                If x is any <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> other than <emu-val>-0</emu-val><sub>&#120125;</sub>, then <emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(x)) is exactly the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as x.\n              </li>\n              <li>\n                The least significant digit of s is not always uniquely determined by the requirements listed in step <emu-xref href=\"#step-number-tostring-intermediate-values\"><a href=\"#step-number-tostring-intermediate-values\" class=\"excluded-xref\" excluded-id=\"step-number-tostring-intermediate-values\">#step-number-tostring-intermediate-values</a></emu-xref>.\n              </li>\n            </ul>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step <emu-xref href=\"#step-number-tostring-intermediate-values\"><a href=\"#step-number-tostring-intermediate-values\" class=\"excluded-xref\" excluded-id=\"step-number-tostring-intermediate-values\">#step-number-tostring-intermediate-values</a></emu-xref> be used as a guideline:</p>\n            <emu-alg replaces-step=\"step-number-tostring-intermediate-values\"><ol start=\"5\"><li>Otherwise, let <var>n</var>, <var>k</var>, and <var>s</var> be <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> such that <var>k</var> &#8805; 1, 10<sup><var>k</var> - 1</sup> &#8804; <var>s</var> &lt; 10<sup><var>k</var></sup>, <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>s</var> &#215; 10<sup><var>n</var> - <var>k</var></sup>) is <var>x</var>, and <var>k</var> is as small as possible. If there are multiple possibilities for <var>s</var>, choose the value of <var>s</var> for which <var>s</var> &#215; 10<sup><var>n</var> - <var>k</var></sup> is closest in value to <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>). If there are two such possible values of <var>s</var>, choose the one that is even. Note that <var>k</var> is the number of digits in the decimal representation of <var>s</var> and that <var>s</var> is not divisible by 10.</li></ol></emu-alg>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:</p>\n            <p>Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10. AT&amp;T Bell Laboratories (Murray Hill, New Jersey). 30 November 1990. Available as\n              <br>\n              <a href=\"http://ampl.com/REFS/abstracts.html#rounding\">http://ampl.com/REFS/abstracts.html#rounding</a>. Associated code available as\n              <br>\n              <a href=\"http://netlib.sandia.gov/fp/dtoa.c\">http://netlib.sandia.gov/fp/dtoa.c</a> and as\n              <br>\n              <a href=\"http://netlib.sandia.gov/fp/g_fmt.c\">http://netlib.sandia.gov/fp/g_fmt.c</a> and may also be found at the various <code>netlib</code> mirror sites.</p>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-ecmascript-language-types-bigint-type": {"num": "6.1.6.2", "title": "#sec-ecmascript-language-types-bigint-type The BigInt Type", "html": "<emu-clause id=\"sec-ecmascript-language-types-bigint-type\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-language-types-bigint-type\">#sec-ecmascript-language-types-bigint-type</span> The BigInt Type</h1>\n        <p>The BigInt type represents an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value. The value may be any size and is not limited to a particular bit-width. Generally, where not otherwise noted, operations are designed to return exact mathematically-based answers. For binary operations, BigInts act as two's complement binary strings, with negative numbers treated as having bits set infinitely to the left.</p>\n\n        <div id=\"excluded-sec-numeric-types-bigint-unaryMinus\"><h1><span class=\"secnum\">6.1.6.2.1</span>#sec-numeric-types-bigint-unaryMinus BigInt::unaryMinus ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseNOT\"><h1><span class=\"secnum\">6.1.6.2.2</span>#sec-numeric-types-bigint-bitwiseNOT BigInt::bitwiseNOT ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-exponentiate\"><h1><span class=\"secnum\">6.1.6.2.3</span>#sec-numeric-types-bigint-exponentiate BigInt::exponentiate ( base, exponent )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-multiply\"><h1><span class=\"secnum\">6.1.6.2.4</span>#sec-numeric-types-bigint-multiply BigInt::multiply ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-divide\"><h1><span class=\"secnum\">6.1.6.2.5</span>#sec-numeric-types-bigint-divide BigInt::divide ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-remainder\"><h1><span class=\"secnum\">6.1.6.2.6</span>#sec-numeric-types-bigint-remainder BigInt::remainder ( n, d )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-add\"><h1><span class=\"secnum\">6.1.6.2.7</span>#sec-numeric-types-bigint-add BigInt::add ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-subtract\"><h1><span class=\"secnum\">6.1.6.2.8</span>#sec-numeric-types-bigint-subtract BigInt::subtract ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-leftShift\"><h1><span class=\"secnum\">6.1.6.2.9</span>#sec-numeric-types-bigint-leftShift BigInt::leftShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-signedRightShift\"><h1><span class=\"secnum\">6.1.6.2.10</span>#sec-numeric-types-bigint-signedRightShift BigInt::signedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-unsignedRightShift\"><h1><span class=\"secnum\">6.1.6.2.11</span>#sec-numeric-types-bigint-unsignedRightShift BigInt::unsignedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-lessThan\"><h1><span class=\"secnum\">6.1.6.2.12</span>#sec-numeric-types-bigint-lessThan BigInt::lessThan ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-equal\"><h1><span class=\"secnum\">6.1.6.2.13</span>#sec-numeric-types-bigint-equal BigInt::equal ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-sameValue\"><h1><span class=\"secnum\">6.1.6.2.14</span>#sec-numeric-types-bigint-sameValue BigInt::sameValue ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-sameValueZero\"><h1><span class=\"secnum\">6.1.6.2.15</span>#sec-numeric-types-bigint-sameValueZero BigInt::sameValueZero ( x, y )</h1>...</div><div id=\"excluded-sec-binaryand\"><h1><span class=\"secnum\">6.1.6.2.16</span>#sec-binaryand BinaryAnd ( x, y )</h1>...</div><div id=\"excluded-sec-binaryor\"><h1><span class=\"secnum\">6.1.6.2.17</span>#sec-binaryor BinaryOr ( x, y )</h1>...</div><div id=\"excluded-sec-binaryxor\"><h1><span class=\"secnum\">6.1.6.2.18</span>#sec-binaryxor BinaryXor ( x, y )</h1>...</div><div id=\"excluded-sec-bigintbitwiseop\"><h1><span class=\"secnum\">6.1.6.2.19</span>#sec-bigintbitwiseop BigIntBitwiseOp ( op, x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseAND\"><h1><span class=\"secnum\">6.1.6.2.20</span>#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseXOR\"><h1><span class=\"secnum\">6.1.6.2.21</span>#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-bitwiseOR\"><h1><span class=\"secnum\">6.1.6.2.22</span>#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-bigint-tostring\"><h1><span class=\"secnum\">6.1.6.2.23</span>#sec-numeric-types-bigint-tostring BigInt::toString ( x )</h1>...</div></emu-clause>\n    "}, "sec-numeric-types": {"num": "6.1.6", "title": "#sec-numeric-types Numeric Types", "html": "<emu-clause id=\"sec-numeric-types\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types\">#sec-numeric-types</span> Numeric Types</h1>\n      <p>ECMAScript has two built-in numeric types: Number and BigInt. The following <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> are defined over these numeric types. The \"Result\" column shows the return type, along with an indication if it is possible for some invocations of the operation to return an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</p>\n      <emu-table id=\"table-numeric-type-ops\" caption=\"Numeric Type Operations\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-numeric-type-ops\">#table-numeric-type-ops</span>: Numeric Type Operations</figcaption>\n        <table>\n          <tbody>\n          <tr>\n            <th>\n              Operation\n            </th>\n            <th>\n              Example source\n            </th>\n            <th>\n              Invoked by the Evaluation semantics of ...\n            </th>\n            <th>\n              Result\n            </th>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::unaryMinus\"><a href=\"#sec-numeric-types-number-unaryMinus\">Number::unaryMinus</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>-x</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-unary-minus-operator\" title=\"\"><a href=\"#sec-unary-minus-operator\">Unary <code>-</code> Operator</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::unaryMinus\"><a href=\"#sec-numeric-types-bigint-unaryMinus\">BigInt::unaryMinus</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::bitwiseNOT\"><a href=\"#sec-numeric-types-number-bitwiseNOT\">Number::bitwiseNOT</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>~x</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-bitwise-not-operator\" title=\"\"><a href=\"#sec-bitwise-not-operator\">Bitwise NOT Operator ( <code>~</code> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::bitwiseNOT\"><a href=\"#sec-numeric-types-bigint-bitwiseNOT\">BigInt::bitwiseNOT</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::exponentiate\"><a href=\"#sec-numeric-types-number-exponentiate\">Number::exponentiate</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;**&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-exp-operator\" title=\"\"><a href=\"#sec-exp-operator\">Exponentiation Operator</a></emu-xref>\n              and <emu-xref href=\"#sec-math.pow\" title=\"\"><a href=\"#sec-math.pow\">Math.pow ( <var>base</var>, <var>exponent</var> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::exponentiate\"><a href=\"#sec-numeric-types-bigint-exponentiate\">BigInt::exponentiate</a></emu-xref>\n            </td>\n            <td>\n              a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::multiply\"><a href=\"#sec-numeric-types-number-multiply\">Number::multiply</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;*&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-multiplicative-operators\" title=\"\"><a href=\"#sec-multiplicative-operators\">Multiplicative Operators</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::multiply\"><a href=\"#sec-numeric-types-bigint-multiply\">BigInt::multiply</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::divide\"><a href=\"#sec-numeric-types-number-divide\">Number::divide</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;/&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-multiplicative-operators\" title=\"\"><a href=\"#sec-multiplicative-operators\">Multiplicative Operators</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::divide\"><a href=\"#sec-numeric-types-bigint-divide\">BigInt::divide</a></emu-xref>\n            </td>\n            <td>\n              a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::remainder\"><a href=\"#sec-numeric-types-number-remainder\">Number::remainder</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;%&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-multiplicative-operators\" title=\"\"><a href=\"#sec-multiplicative-operators\">Multiplicative Operators</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::remainder\"><a href=\"#sec-numeric-types-bigint-remainder\">BigInt::remainder</a></emu-xref>\n            </td>\n            <td>\n              a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x ++</code><br><code>++ x</code><br><code>x&#160;+&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-postfix-increment-operator\" title=\"\"><a href=\"#sec-postfix-increment-operator\">Postfix Increment Operator</a></emu-xref>,\n              <emu-xref href=\"#sec-prefix-increment-operator\" title=\"\"><a href=\"#sec-prefix-increment-operator\">Prefix Increment Operator</a></emu-xref>,\n              and <emu-xref href=\"#sec-addition-operator-plus\" title=\"\"><a href=\"#sec-addition-operator-plus\">The Addition Operator ( <code>+</code> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::add\"><a href=\"#sec-numeric-types-bigint-add\">BigInt::add</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::subtract\"><a href=\"#sec-numeric-types-number-subtract\">Number::subtract</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x --</code><br><code>-- x</code><br><code>x&#160;-&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-postfix-decrement-operator\" title=\"\"><a href=\"#sec-postfix-decrement-operator\">Postfix Decrement Operator</a></emu-xref>,\n              <emu-xref href=\"#sec-prefix-decrement-operator\" title=\"\"><a href=\"#sec-prefix-decrement-operator\">Prefix Decrement Operator</a></emu-xref>,\n              and <emu-xref href=\"#sec-subtraction-operator-minus\" title=\"\"><a href=\"#sec-subtraction-operator-minus\">The Subtraction Operator ( <code>-</code> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::subtract\"><a href=\"#sec-numeric-types-bigint-subtract\">BigInt::subtract</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::leftShift\"><a href=\"#sec-numeric-types-number-leftShift\">Number::leftShift</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;&lt;&lt;&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-left-shift-operator\" title=\"\"><a href=\"#sec-left-shift-operator\">The Left Shift Operator ( <code>&lt;&lt;</code> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::leftShift\"><a href=\"#sec-numeric-types-bigint-leftShift\">BigInt::leftShift</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::signedRightShift\"><a href=\"#sec-numeric-types-number-signedRightShift\">Number::signedRightShift</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;&gt;&gt;&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-signed-right-shift-operator\" title=\"\"><a href=\"#sec-signed-right-shift-operator\">The Signed Right Shift Operator ( <code>&gt;&gt;</code> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::signedRightShift\"><a href=\"#sec-numeric-types-bigint-signedRightShift\">BigInt::signedRightShift</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::unsignedRightShift\"><a href=\"#sec-numeric-types-number-unsignedRightShift\">Number::unsignedRightShift</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;&gt;&gt;&gt;&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-unsigned-right-shift-operator\" title=\"\"><a href=\"#sec-unsigned-right-shift-operator\">The Unsigned Right Shift Operator ( <code>&gt;&gt;&gt;</code> )</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::unsignedRightShift\"><a href=\"#sec-numeric-types-bigint-unsignedRightShift\">BigInt::unsignedRightShift</a></emu-xref>\n            </td>\n            <td>\n              a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">throw completion</a></emu-xref>\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::lessThan\"><a href=\"#sec-numeric-types-number-lessThan\">Number::lessThan</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;&lt;&#160;y</code><br><code>x&#160;&gt;&#160;y</code><br><code>x&#160;&lt;=&#160;y</code><br><code>x&#160;&gt;=&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-relational-operators\" title=\"\"><a href=\"#sec-relational-operators\">Relational Operators</a></emu-xref>,\n              via <emu-xref href=\"#sec-islessthan\" title=\"\"><a href=\"#sec-islessthan\">IsLessThan ( <var>x</var>, <var>y</var>, <var>LeftFirst</var> )</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              Boolean or <emu-val>undefined</emu-val> (for unordered inputs)\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::lessThan\"><a href=\"#sec-numeric-types-bigint-lessThan\">BigInt::lessThan</a></emu-xref>\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::equal\"><a href=\"#sec-numeric-types-number-equal\">Number::equal</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;==&#160;y</code><br><code>x&#160;!=&#160;y</code><br><code>x&#160;===&#160;y</code><br><code>x&#160;!==&#160;y</code>\n            </td>\n            <td rowspan=\"2\">\n              <emu-xref href=\"#sec-equality-operators\" title=\"\"><a href=\"#sec-equality-operators\">Equality Operators</a></emu-xref>,\n              via <emu-xref href=\"#sec-isstrictlyequal\" title=\"\"><a href=\"#sec-isstrictlyequal\">IsStrictlyEqual ( <var>x</var>, <var>y</var> )</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              Boolean\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::equal\"><a href=\"#sec-numeric-types-bigint-equal\">BigInt::equal</a></emu-xref>\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::sameValue\"><a href=\"#sec-numeric-types-number-sameValue\">Number::sameValue</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>Object.is(x, y)</code>\n            </td>\n            <td rowspan=\"2\">\n              Object internal methods,\n              via <emu-xref href=\"#sec-samevalue\" title=\"\"><a href=\"#sec-samevalue\">SameValue ( <var>x</var>, <var>y</var> )</a></emu-xref>,\n              to test exact value equality\n            </td>\n            <td rowspan=\"2\">\n              Boolean\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::sameValue\"><a href=\"#sec-numeric-types-bigint-sameValue\">BigInt::sameValue</a></emu-xref>\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::sameValueZero\"><a href=\"#sec-numeric-types-number-sameValueZero\">Number::sameValueZero</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>[x].includes(y)</code>\n            </td>\n            <td rowspan=\"2\">\n              Array, Map, and Set methods,\n              via <emu-xref href=\"#sec-samevaluezero\" title=\"\"><a href=\"#sec-samevaluezero\">SameValueZero ( <var>x</var>, <var>y</var> )</a></emu-xref>,\n              to test value equality, ignoring the difference between <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>\n            </td>\n            <td rowspan=\"2\">\n              Boolean\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::sameValueZero\"><a href=\"#sec-numeric-types-bigint-sameValueZero\">BigInt::sameValueZero</a></emu-xref>\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::bitwiseAND\"><a href=\"#sec-numeric-types-number-bitwiseAND\">Number::bitwiseAND</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;&amp;&#160;y</code>\n            </td>\n            <td rowspan=\"6\">\n              <emu-xref href=\"#sec-binary-bitwise-operators\" title=\"\"><a href=\"#sec-binary-bitwise-operators\">Binary Bitwise Operators</a></emu-xref>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::bitwiseAND\"><a href=\"#sec-numeric-types-bigint-bitwiseAND\">BigInt::bitwiseAND</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::bitwiseXOR\"><a href=\"#sec-numeric-types-number-bitwiseXOR\">Number::bitwiseXOR</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;^&#160;y</code>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::bitwiseXOR\"><a href=\"#sec-numeric-types-bigint-bitwiseXOR\">BigInt::bitwiseXOR</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::bitwiseOR\"><a href=\"#sec-numeric-types-number-bitwiseOR\">Number::bitwiseOR</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>x&#160;|&#160;y</code>\n            </td>\n            <td>\n              Number\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::bitwiseOR\"><a href=\"#sec-numeric-types-bigint-bitwiseOR\">BigInt::bitwiseOR</a></emu-xref>\n            </td>\n            <td>\n              BigInt\n            </td>\n          </tr>\n\n          <tr>\n            <td>\n              <emu-xref aoid=\"Number::toString\"><a href=\"#sec-numeric-types-number-tostring\">Number::toString</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              <code>String(x)</code>\n            </td>\n            <td rowspan=\"2\">\n              Many expressions and built-in functions, via <emu-xref href=\"#sec-tostring\" title=\"\"><a href=\"#sec-tostring\">ToString ( <var>argument</var> )</a></emu-xref>\n            </td>\n            <td rowspan=\"2\">\n              String\n            </td>\n          </tr>\n          <tr>\n            <td>\n              <emu-xref aoid=\"BigInt::toString\"><a href=\"#sec-numeric-types-bigint-tostring\">BigInt::toString</a></emu-xref>\n            </td>\n          </tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <p>The above <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> are not a part of the ECMAScript language; they are defined here solely to aid the specification of the semantics of the ECMAScript language.</p>\n      <p>Because the numeric types are in general not convertible without loss of precision or truncation, the ECMAScript language provides no implicit conversion among these types. Programmers must explicitly call <code>Number</code> and <code>BigInt</code> functions to convert among types when calling a function which requires another type.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The first and subsequent editions of ECMAScript have provided, for certain operators, implicit numeric conversions that could lose precision or truncate. These legacy implicit conversions are maintained for backward compatibility, but not provided for BigInt in order to minimize opportunity for programmer error, and to leave open the option of generalized <em>value types</em> in a future edition.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-ecmascript-language-types-number-type\"><h1><span class=\"secnum\">6.1.6.1</span>#sec-ecmascript-language-types-number-type The Number Type</h1>...</div><div id=\"excluded-sec-ecmascript-language-types-bigint-type\"><h1><span class=\"secnum\">6.1.6.2</span>#sec-ecmascript-language-types-bigint-type The BigInt Type</h1>...</div></emu-clause>\n\n    "}, "sec-bigintbitwiseop": {"num": "6.1.6.2.19", "title": "#sec-bigintbitwiseop BigIntBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-bigintbitwiseop\" type=\"abstract operation\" aoid=\"BigIntBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bigintbitwiseop\">#sec-bigintbitwiseop</span> BigIntBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigIntBitwiseOp takes arguments <var>op</var> (<code>&amp;</code>, <code>^</code>, or <code>|</code>), <var>x</var> (a BigInt), and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Set <var>x</var> to <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>).</li><li>Set <var>y</var> to <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>).</li><li>Let <var>result</var> be 0.</li><li>Let <var>shift</var> be 0.</li><li>Repeat, until (<var>x</var> = 0 or <var>x</var> = -1) and (<var>y</var> = 0 or <var>y</var> = -1),<ol><li>Let <var>xDigit</var> be <var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>Let <var>yDigit</var> be <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2.</li><li>If <var>op</var> is <code>&amp;</code>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else if <var>op</var> is <code>|</code>, set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>^</code>.</li><li>Set <var>result</var> to <var>result</var> + 2<sup><var>shift</var></sup> &#215; <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>xDigit</var>, <var>yDigit</var>).</li></ol></li><li>Set <var>shift</var> to <var>shift</var> + 1.</li><li>Set <var>x</var> to (<var>x</var> - <var>xDigit</var>) / 2.</li><li>Set <var>y</var> to (<var>y</var> - <var>yDigit</var>) / 2.</li></ol></li><li>If <var>op</var> is <code>&amp;</code>, let <var>tmp</var> be <emu-xref aoid=\"BinaryAnd\"><a href=\"#sec-binaryand\">BinaryAnd</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else if <var>op</var> is <code>|</code>, let <var>tmp</var> be <emu-xref aoid=\"BinaryOr\"><a href=\"#sec-binaryor\">BinaryOr</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>op</var> is <code>^</code>.</li><li>Let <var>tmp</var> be <emu-xref aoid=\"BinaryXor\"><a href=\"#sec-binaryxor\">BinaryXor</a></emu-xref>(<var>x</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2, <var>y</var> <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 2).</li></ol></li><li>If <var>tmp</var> &#8800; 0, then<ol><li>Set <var>result</var> to <var>result</var> - 2<sup><var>shift</var></sup>.</li><li>NOTE: This extends the sign.</li></ol></li><li>Return the BigInt value for <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-remainder": {"num": "6.1.6.2.6", "title": "#sec-numeric-types-bigint-remainder BigInt::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-bigint-remainder\" type=\"numeric method\" aoid=\"BigInt::remainder\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-remainder\">#sec-numeric-types-bigint-remainder</span> BigInt::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The abstract operation BigInt::remainder takes arguments <var>n</var> (a BigInt) and <var>d</var> (a BigInt) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>d</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>n</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>0</emu-val><sub>&#8484;</sub>).</li><li>Let <var>r</var> be the BigInt defined by the mathematical relation <var>r</var> = <var>n</var> - (<var>d</var> &#215; <var>q</var>) where <var>q</var> is a BigInt that is negative only if <var>n</var>/<var>d</var> is negative and positive only if <var>n</var>/<var>d</var> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <var>n</var> and <var>d</var>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>r</var>).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">The sign of the result equals the sign of the dividend.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-unsignedRightShift": {"num": "6.1.6.2.11", "title": "#sec-numeric-types-bigint-unsignedRightShift BigInt::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-unsignedRightShift\" type=\"numeric method\" aoid=\"BigInt::unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-unsignedRightShift\">#sec-numeric-types-bigint-unsignedRightShift</span> BigInt::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::unsignedRightShift takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">throw completion</a></emu-xref>. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-issuperreference": {"num": "6.2.4.3", "title": "#sec-issuperreference IsSuperReference ( V )", "html": "<emu-clause id=\"sec-issuperreference\" type=\"abstract operation\" oldids=\"ao-issuperreference\" aoid=\"IsSuperReference\"><span id=\"ao-issuperreference\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-issuperreference\">#sec-issuperreference</span> IsSuperReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsSuperReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[ThisValue]] is not <emu-const>empty</emu-const>, return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-prefix-decrement-operator-runtime-semantics-evaluation": {"num": "13.4.5.1", "title": "#sec-prefix-decrement-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-prefix-decrement-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-prefix-decrement-operator-runtime-semantics-evaluation\">#sec-prefix-decrement-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"onrvwudi\">\n        <emu-t>--</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is Number, then<ol><li>Let <var>newValue</var> be ! <emu-xref aoid=\"Number::subtract\"><a href=\"#sec-numeric-types-number-subtract\">Number::subtract</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#120125;</sub>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is BigInt.</li><li>Let <var>newValue</var> be ! <emu-xref aoid=\"BigInt::subtract\"><a href=\"#sec-numeric-types-bigint-subtract\">BigInt::subtract</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#8484;</sub>).</li></ol></li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>expr</var>, <var>newValue</var>).</li><li>Return <var>newValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-unaryMinus": {"num": "6.1.6.2.1", "title": "#sec-numeric-types-bigint-unaryMinus BigInt::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-unaryMinus\" type=\"numeric method\" aoid=\"BigInt::unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-unaryMinus\">#sec-numeric-types-bigint-unaryMinus</span> BigInt::unaryMinus ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::unaryMinus takes argument <var>x</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, return <emu-val>0</emu-val><sub>&#8484;</sub>.</li><li>Return the BigInt value that represents the negation of <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numberbitwiseop": {"num": "6.1.6.1.16", "title": "#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )", "html": "<emu-clause id=\"sec-numberbitwiseop\" type=\"abstract operation\" aoid=\"NumberBitwiseOp\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numberbitwiseop\">#sec-numberbitwiseop</span> NumberBitwiseOp ( <var>op</var>, <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation NumberBitwiseOp takes arguments <var>op</var> (<code>&amp;</code>, <code>^</code>, or <code>|</code>), <var>x</var> (a Number), and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>y</var>).</li><li>Let <var>lbits</var> be the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>lnum</var>).</li><li>Let <var>rbits</var> be the 32-bit two's complement bit string representing <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>).</li><li>If <var>op</var> is <code>&amp;</code>, let <var>result</var> be the result of applying the bitwise AND operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else if <var>op</var> is <code>^</code>, let <var>result</var> be the result of applying the bitwise exclusive OR (XOR) operation to <var>lbits</var> and <var>rbits</var>.</li><li>Else, <var>op</var> is <code>|</code>. Let <var>result</var> be the result of applying the bitwise inclusive OR operation to <var>lbits</var> and <var>rbits</var>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> represented by the 32-bit two's complement bit string <var>result</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-exponentiate": {"num": "6.1.6.2.3", "title": "#sec-numeric-types-bigint-exponentiate BigInt::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-bigint-exponentiate\" type=\"numeric method\" aoid=\"BigInt::exponentiate\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-exponentiate\">#sec-numeric-types-bigint-exponentiate</span> BigInt::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>The abstract operation BigInt::exponentiate takes arguments <var>base</var> (a BigInt) and <var>exponent</var> (a BigInt) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>exponent</var> &lt; <emu-val>0</emu-val><sub>&#8484;</sub>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>base</var> is <emu-val>0</emu-val><sub>&#8484;</sub> and <var>exponent</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>1</emu-val><sub>&#8484;</sub>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(the BigInt value that represents <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>) raised to the power <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>exponent</var>)).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-add": {"num": "6.1.6.2.7", "title": "#sec-numeric-types-bigint-add BigInt::add ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-add\" type=\"numeric method\" aoid=\"BigInt::add\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-add\">#sec-numeric-types-bigint-add</span> BigInt::add ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::add takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return the BigInt value that represents the sum of <var>x</var> and <var>y</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-makeprivatereference": {"num": "6.2.4.9", "title": "#sec-makeprivatereference MakePrivateReference ( baseValue, privateIdentifier )", "html": "<emu-clause id=\"sec-makeprivatereference\" type=\"abstract operation\" aoid=\"MakePrivateReference\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-makeprivatereference\">#sec-makeprivatereference</span> MakePrivateReference ( <var>baseValue</var>, <var>privateIdentifier</var> )</h1>\n        <p>The abstract operation MakePrivateReference takes arguments <var>baseValue</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>privateIdentifier</var> (a String) and returns a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>privEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>privEnv</var> is not <emu-val>null</emu-val>.</li><li>Let <var>privateName</var> be !&#160;<emu-xref aoid=\"ResolvePrivateIdentifier\"><a href=\"#sec-resolve-private-identifier\">ResolvePrivateIdentifier</a></emu-xref>(<var>privEnv</var>, <var>privateIdentifier</var>).</li><li>Return the <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref> { [[Base]]: <var>baseValue</var>, [[ReferencedName]]: <var>privateName</var>, [[Strict]]: <emu-val>true</emu-val>, [[ThisValue]]: <emu-const>empty</emu-const> }.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-number-sameValue": {"num": "6.1.6.1.14", "title": "#sec-numeric-types-number-sameValue Number::sameValue ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValue\" type=\"numeric method\" aoid=\"Number::sameValue\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValue\">#sec-numeric-types-number-sameValue</span> Number::sameValue ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::sameValue takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-ecmascript-language-types-number-type": {"num": "6.1.6.1", "title": "#sec-ecmascript-language-types-number-type The Number Type", "html": "<emu-clause id=\"sec-ecmascript-language-types-number-type\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-language-types-number-type\">#sec-ecmascript-language-types-number-type</span> The Number Type</h1>\n        <p>The Number type has exactly 18,437,736,874,454,810,627 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> + 3</emu-eqn>) values, representing the double-precision 64-bit format <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) distinct &#8220;Not-a-Number&#8221; values of the IEEE Standard are represented in ECMAScript as a single special <emu-val>NaN</emu-val> value. (Note that the <emu-val>NaN</emu-val> value is produced by the program expression <code>NaN</code>.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>; to ECMAScript code, all <emu-val>NaN</emu-val> values are indistinguishable from each other.</p>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The bit pattern that might be observed in an ArrayBuffer (see <emu-xref href=\"#sec-arraybuffer-objects\"><a href=\"#sec-arraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-arraybuffer-objects\">#sec-arraybuffer-objects</a></emu-xref>) or a SharedArrayBuffer (see <emu-xref href=\"#sec-sharedarraybuffer-objects\"><a href=\"#sec-sharedarraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-sharedarraybuffer-objects\">#sec-sharedarraybuffer-objects</a></emu-xref>) after a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> has been stored into it is not necessarily the same as the internal representation of that <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> used by the ECMAScript implementation.</p>\n        </div></emu-note>\n        <p>There are two other special values, called <emu-val>positive Infinity</emu-val> and <emu-val>negative Infinity</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> and <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, respectively. (Note that these two infinite Number values are produced by the program expressions <code>+Infinity</code> (or simply <code>Infinity</code>) and <code>-Infinity</code>.)</p>\n        <p>The other 18,437,736,874,454,810,624 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup></emu-eqn>) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> there is a corresponding negative value having the same magnitude.</p>\n        <p>Note that there is both a <emu-val>positive zero</emu-val> and a <emu-val>negative zero</emu-val>. For brevity, these values are also referred to for expository purposes by the symbols <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>, respectively. (Note that these two different zero Number values are produced by the program expressions <code>+0</code> (or simply <code>0</code>) and <code>-0</code>.)</p>\n        <p>The 18,437,736,874,454,810,622 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>53</sup> - 2</emu-eqn>) finite non-zero values are of two kinds:</p>\n        <p>18,428,729,675,200,069,632 (that is, <emu-eqn class=\"inline\">2<sup>64</sup> - 2<sup>54</sup></emu-eqn>) of them are normalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 2<sup>52</sup> &#8804; <var>m</var> &lt; 2<sup>53</sup>, and <var>e</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that -1074 &#8804; <var>e</var> &#8804; 971.</p>\n        <p>The remaining 9,007,199,254,740,990 (that is, <emu-eqn class=\"inline\">2<sup>53</sup> - 2</emu-eqn>) values are denormalized, having the form</p>\n        <div class=\"math-display\">\n          <var>s</var> &#215; <var>m</var> &#215; 2<sup><var>e</var></sup>\n        </div>\n        <p>where <var>s</var> is 1 or -1, <var>m</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that 0 &lt; <var>m</var> &lt; 2<sup>52</sup>, and <var>e</var> is -1074.</p>\n        <p>Note that all the positive and negative <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> whose magnitude is no greater than 2<sup>53</sup> are representable in the Number type. The <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> 0 has two representations in the Number type: <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n        <p>A finite number has an <em>odd significand</em> if it is non-zero and the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>m</var> used to express it (in one of the two forms shown above) is odd. Otherwise, it has an <em>even significand</em>.</p>\n        <p>In this specification, the phrase &#8220;the <dfn id=\"number-value\">Number value</dfn> for <var>x</var>&#8221; where <var>x</var> represents an exact real mathematical quantity (which might even be an irrational number such as &#960;) means a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> chosen in the following manner. Consider the set of all finite values of the Number type, with <emu-val>-0</emu-val><sub>&#120125;</sub> removed and with two additional values added to it that are not representable in the Number type, namely 2<sup>1024</sup> (which is <emu-eqn class=\"inline\">+1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>) and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> (which is <emu-eqn class=\"inline\">-1 &#215; 2<sup>53</sup> &#215; 2<sup>971</sup></emu-eqn>). Choose the member of this set that is closest in value to <var>x</var>. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 2<sup>1024</sup> and <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> are considered to have even significands. Finally, if 2<sup>1024</sup> was chosen, replace it with <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>; if <emu-eqn class=\"inline\">-2<sup>1024</sup></emu-eqn> was chosen, replace it with <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>; if <emu-val>+0</emu-val><sub>&#120125;</sub> was chosen, replace it with <emu-val>-0</emu-val><sub>&#120125;</sub> if and only if <var>x</var> &lt; 0; any other chosen value is used unchanged. The result is the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for <var>x</var>. (This procedure corresponds exactly to the behaviour of the <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode.)</p>\n        <p>The <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for +&#8734; is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, and the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for -&#8734; is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>.</p>\n        <p>Some ECMAScript operators deal only with <emu-xref href=\"#integer\"><a href=\"#integer\">integers</a></emu-xref> in specific ranges such as <emu-eqn class=\"inline\">-2<sup>31</sup></emu-eqn> through <emu-eqn class=\"inline\">2<sup>31</sup> - 1</emu-eqn>, inclusive, or in the range 0 through <emu-eqn class=\"inline\">2<sup>16</sup> - 1</emu-eqn>, inclusive. These operators accept any value of the Number type but first convert each such value to an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value in the expected range. See the descriptions of the numeric conversion operations in <emu-xref href=\"#sec-type-conversion\"><a href=\"#sec-type-conversion\" class=\"excluded-xref\" excluded-id=\"sec-type-conversion\">#sec-type-conversion</a></emu-xref>.</p>\n\n        <div id=\"excluded-sec-numeric-types-number-unaryMinus\"><h1><span class=\"secnum\">6.1.6.1.1</span>#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseNOT\"><h1><span class=\"secnum\">6.1.6.1.2</span>#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )</h1>...</div><div id=\"excluded-sec-numeric-types-number-exponentiate\"><h1><span class=\"secnum\">6.1.6.1.3</span>#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )</h1>...</div><div id=\"excluded-sec-numeric-types-number-multiply\"><h1><span class=\"secnum\">6.1.6.1.4</span>#sec-numeric-types-number-multiply Number::multiply ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-divide\"><h1><span class=\"secnum\">6.1.6.1.5</span>#sec-numeric-types-number-divide Number::divide ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-remainder\"><h1><span class=\"secnum\">6.1.6.1.6</span>#sec-numeric-types-number-remainder Number::remainder ( n, d )</h1>...</div><div id=\"excluded-sec-numeric-types-number-add\"><h1><span class=\"secnum\">6.1.6.1.7</span>#sec-numeric-types-number-add Number::add ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-subtract\"><h1><span class=\"secnum\">6.1.6.1.8</span>#sec-numeric-types-number-subtract Number::subtract ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-leftShift\"><h1><span class=\"secnum\">6.1.6.1.9</span>#sec-numeric-types-number-leftShift Number::leftShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-signedRightShift\"><h1><span class=\"secnum\">6.1.6.1.10</span>#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-unsignedRightShift\"><h1><span class=\"secnum\">6.1.6.1.11</span>#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-lessThan\"><h1><span class=\"secnum\">6.1.6.1.12</span>#sec-numeric-types-number-lessThan Number::lessThan ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-equal\"><h1><span class=\"secnum\">6.1.6.1.13</span>#sec-numeric-types-number-equal Number::equal ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValue\"><h1><span class=\"secnum\">6.1.6.1.14</span>#sec-numeric-types-number-sameValue Number::sameValue ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-sameValueZero\"><h1><span class=\"secnum\">6.1.6.1.15</span>#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )</h1>...</div><div id=\"excluded-sec-numberbitwiseop\"><h1><span class=\"secnum\">6.1.6.1.16</span>#sec-numberbitwiseop NumberBitwiseOp ( op, x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseAND\"><h1><span class=\"secnum\">6.1.6.1.17</span>#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseXOR\"><h1><span class=\"secnum\">6.1.6.1.18</span>#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-bitwiseOR\"><h1><span class=\"secnum\">6.1.6.1.19</span>#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )</h1>...</div><div id=\"excluded-sec-numeric-types-number-tostring\"><h1><span class=\"secnum\">6.1.6.1.20</span>#sec-numeric-types-number-tostring Number::toString ( x )</h1>...</div></emu-clause>\n\n      "}, "sec-completion-ao": {"num": "5.2.3.1", "title": "#sec-completion-ao Completion ( completionRecord )", "html": "<emu-clause id=\"sec-completion-ao\" type=\"abstract operation\" aoid=\"Completion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completion-ao\">#sec-completion-ao</span> Completion ( <var>completionRecord</var> )</h1>\n        <p>The abstract operation Completion takes argument <var>completionRecord</var> (a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>. It is used to emphasize that a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> is being returned. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completionRecord</var> is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>.</li><li>Return <var>completionRecord</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-bitwise-not-operator-runtime-semantics-evaluation": {"num": "13.5.6.1", "title": "#sec-bitwise-not-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-bitwise-not-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-bitwise-not-operator-runtime-semantics-evaluation\">#sec-bitwise-not-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UnaryExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"b9nqec7b\">\n        <emu-t>~</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is Number, then<ol><li>Return ! <emu-xref aoid=\"Number::bitwiseNOT\"><a href=\"#sec-numeric-types-number-bitwiseNOT\">Number::bitwiseNOT</a></emu-xref>(<var>oldValue</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is BigInt.</li><li>Return ! <emu-xref aoid=\"BigInt::bitwiseNOT\"><a href=\"#sec-numeric-types-bigint-bitwiseNOT\">BigInt::bitwiseNOT</a></emu-xref>(<var>oldValue</var>).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-topropertydescriptor": {"num": "6.2.5.5", "title": "#sec-topropertydescriptor ToPropertyDescriptor ( Obj )", "html": "<emu-clause id=\"sec-topropertydescriptor\" type=\"abstract operation\" aoid=\"ToPropertyDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-topropertydescriptor\">#sec-topropertydescriptor</span> ToPropertyDescriptor ( <var>Obj</var> )</h1>\n        <p>The abstract operation ToPropertyDescriptor takes argument <var>Obj</var> and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>Obj</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>desc</var> be a new <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> that initially has no fields.</li><li>Let <var>hasEnumerable</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"enumerable\"</emu-val>).</li><li>If <var>hasEnumerable</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>enumerable</var> be !&#160;<emu-xref aoid=\"ToBoolean\"><a href=\"#sec-toboolean\">ToBoolean</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"enumerable\"</emu-val>)).</li><li>Set <var>desc</var>.[[Enumerable]] to <var>enumerable</var>.</li></ol></li><li>Let <var>hasConfigurable</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"configurable\"</emu-val>).</li><li>If <var>hasConfigurable</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>configurable</var> be !&#160;<emu-xref aoid=\"ToBoolean\"><a href=\"#sec-toboolean\">ToBoolean</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"configurable\"</emu-val>)).</li><li>Set <var>desc</var>.[[Configurable]] to <var>configurable</var>.</li></ol></li><li>Let <var>hasValue</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"value\"</emu-val>).</li><li>If <var>hasValue</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"value\"</emu-val>).</li><li>Set <var>desc</var>.[[Value]] to <var>value</var>.</li></ol></li><li>Let <var>hasWritable</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"writable\"</emu-val>).</li><li>If <var>hasWritable</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>writable</var> be !&#160;<emu-xref aoid=\"ToBoolean\"><a href=\"#sec-toboolean\">ToBoolean</a></emu-xref>(? <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"writable\"</emu-val>)).</li><li>Set <var>desc</var>.[[Writable]] to <var>writable</var>.</li></ol></li><li>Let <var>hasGet</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"get\"</emu-val>).</li><li>If <var>hasGet</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>getter</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"get\"</emu-val>).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>getter</var>) is <emu-val>false</emu-val> and <var>getter</var> is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>desc</var>.[[Get]] to <var>getter</var>.</li></ol></li><li>Let <var>hasSet</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>Obj</var>, <emu-val>\"set\"</emu-val>).</li><li>If <var>hasSet</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>setter</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>Obj</var>, <emu-val>\"set\"</emu-val>).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>setter</var>) is <emu-val>false</emu-val> and <var>setter</var> is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>desc</var>.[[Set]] to <var>setter</var>.</li></ol></li><li>If <var>desc</var>.[[Get]] is present or <var>desc</var>.[[Set]] is present, then<ol><li>If <var>desc</var>.[[Value]] is present or <var>desc</var>.[[Writable]] is present, throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Return <var>desc</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isaccessordescriptor": {"num": "6.2.5.1", "title": "#sec-isaccessordescriptor IsAccessorDescriptor ( Desc )", "html": "<emu-clause id=\"sec-isaccessordescriptor\" type=\"abstract operation\" aoid=\"IsAccessorDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isaccessordescriptor\">#sec-isaccessordescriptor</span> IsAccessorDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation IsAccessorDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>false</emu-val>.</li><li>If both <var>Desc</var>.[[Get]] and <var>Desc</var>.[[Set]] are absent, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-islessthan": {"num": "7.2.13", "title": "#sec-islessthan IsLessThan ( x, y, LeftFirst )", "html": "<emu-clause id=\"sec-islessthan\" type=\"abstract operation\" oldids=\"sec-abstract-relational-comparison\" aoid=\"IsLessThan\"><span id=\"sec-abstract-relational-comparison\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-islessthan\">#sec-islessthan</span> IsLessThan ( <var>x</var>, <var>y</var>, <var>LeftFirst</var> )</h1>\n      <p>The abstract operation IsLessThan takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), and <var>LeftFirst</var> (a Boolean). It provides the semantics for the comparison <var>x</var> &lt; <var>y</var>, returning <emu-val>true</emu-val>, <emu-val>false</emu-val>, or <emu-val>undefined</emu-val> (which indicates that at least one operand is <emu-val>NaN</emu-val>). The <var>LeftFirst</var> flag is used to control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. If <var>LeftFirst</var> is <emu-val>true</emu-val>, the <var>x</var> parameter corresponds to an expression that occurs to the left of the <var>y</var> parameter's corresponding expression. If <var>LeftFirst</var> is <emu-val>false</emu-val>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If the <var>LeftFirst</var> flag is <emu-val>true</emu-val>, then<ol><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li></ol></li><li>Else,<ol><li>NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li></ol></li><li id=\"step-arc-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>py</var>, <var>px</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>px</var>, <var>py</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>k</var> be the smallest non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that the code unit at index <var>k</var> within <var>px</var> is different from the code unit at index <var>k</var> within <var>py</var>. (There must be such a <var>k</var>, for neither String is a prefix of the other.)</li><li>Let <var>m</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>px</var>.</li><li>Let <var>n</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>py</var>.</li><li>If <var>m</var> &lt; <var>n</var>, return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>py</var>).</li><li>If <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return <emu-xref aoid=\"BigInt::lessThan\"><a href=\"#sec-numeric-types-bigint-lessThan\">BigInt::lessThan</a></emu-xref>(<var>px</var>, <var>ny</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is BigInt, then<ol><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>px</var>).</li><li>If <var>nx</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return <emu-xref aoid=\"BigInt::lessThan\"><a href=\"#sec-numeric-types-bigint-lessThan\">BigInt::lessThan</a></emu-xref>(<var>nx</var>, <var>py</var>).</li></ol></li><li>NOTE: Because <var>px</var> and <var>py</var> are primitive values, evaluation order is not important.</li><li>Let <var>nx</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>px</var>).</li><li>Let <var>ny</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>py</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is the same as <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>), then<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number, then<ol><li>Return <emu-xref aoid=\"Number::lessThan\"><a href=\"#sec-numeric-types-number-lessThan\">Number::lessThan</a></emu-xref>(<var>nx</var>, <var>ny</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt.</li><li>Return <emu-xref aoid=\"BigInt::lessThan\"><a href=\"#sec-numeric-types-bigint-lessThan\">BigInt::lessThan</a></emu-xref>(<var>nx</var>, <var>ny</var>).</li></ol></li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is Number, or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is BigInt.</li><li>If <var>nx</var> or <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>nx</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>nx</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>nx</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>ny</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> differs from step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">1.c</a></emu-xref> in the algorithm that handles the addition operator <code>+</code> (<emu-xref href=\"#sec-applystringornumericbinaryoperator\"><a href=\"#sec-applystringornumericbinaryoperator\" class=\"excluded-xref\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</a></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-frompropertydescriptor": {"num": "6.2.5.4", "title": "#sec-frompropertydescriptor FromPropertyDescriptor ( Desc )", "html": "<emu-clause id=\"sec-frompropertydescriptor\" type=\"abstract operation\" aoid=\"FromPropertyDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-frompropertydescriptor\">#sec-frompropertydescriptor</span> FromPropertyDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation FromPropertyDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>) and returns an Object. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-object-prototype-object\"><a href=\"#sec-properties-of-the-object-prototype-object\">%Object.prototype%</a></emu-xref>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>obj</var> is an extensible <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> with no own properties.</li><li>If <var>Desc</var> has a [[Value]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"value\"</emu-val>, <var>Desc</var>.[[Value]]).</li></ol></li><li>If <var>Desc</var> has a [[Writable]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"writable\"</emu-val>, <var>Desc</var>.[[Writable]]).</li></ol></li><li>If <var>Desc</var> has a [[Get]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"get\"</emu-val>, <var>Desc</var>.[[Get]]).</li></ol></li><li>If <var>Desc</var> has a [[Set]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"set\"</emu-val>, <var>Desc</var>.[[Set]]).</li></ol></li><li>If <var>Desc</var> has an [[Enumerable]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"enumerable\"</emu-val>, <var>Desc</var>.[[Enumerable]]).</li></ol></li><li>If <var>Desc</var> has a [[Configurable]] field, then<ol><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"configurable\"</emu-val>, <var>Desc</var>.[[Configurable]]).</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-gather-available-ancestors": {"num": "16.2.1.5.2.3", "title": "#sec-gather-available-ancestors GatherAvailableAncestors ( module, execList )", "html": "<emu-clause id=\"sec-gather-available-ancestors\" type=\"abstract operation\" aoid=\"GatherAvailableAncestors\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-gather-available-ancestors\">#sec-gather-available-ancestors</span> GatherAvailableAncestors ( <var>module</var>, <var>execList</var> )</h1>\n            <p>The abstract operation GatherAvailableAncestors takes arguments <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>) and <var>execList</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Records</a></emu-xref>) and returns <emu-const>unused</emu-const>. It performs the following steps when called:</p>\n            <emu-alg><ol><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> of <var>module</var>.[[AsyncParentModules]], do<ol><li>If <var>execList</var> does not contain <var>m</var> and <var>m</var>.[[CycleRoot]].[[EvaluationError]] is <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[Status]] is <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[EvaluationError]] is <emu-const>empty</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[AsyncEvaluation]] is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[PendingAsyncDependencies]] &gt; 0.</li><li>Set <var>m</var>.[[PendingAsyncDependencies]] to <var>m</var>.[[PendingAsyncDependencies]] - 1.</li><li>If <var>m</var>.[[PendingAsyncDependencies]] = 0, then<ol><li>Append <var>m</var> to <var>execList</var>.</li><li>If <var>m</var>.[[HasTLA]] is <emu-val>false</emu-val>, perform !&#160;<emu-xref aoid=\"GatherAvailableAncestors\"><a href=\"#sec-gather-available-ancestors\">GatherAvailableAncestors</a></emu-xref>(<var>m</var>, <var>execList</var>).</li></ol></li></ol></li></ol></li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n            <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n              <p>When an asynchronous execution for a root <var>module</var> is fulfilled, this function determines the list of modules which are able to synchronously execute together on this completion, populating them in <var>execList</var>.</p>\n            </div></emu-note>\n          </emu-clause>\n\n          "}, "sec-numeric-types-bigint-multiply": {"num": "6.1.6.2.4", "title": "#sec-numeric-types-bigint-multiply BigInt::multiply ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-multiply\" type=\"numeric method\" aoid=\"BigInt::multiply\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-multiply\">#sec-numeric-types-bigint-multiply</span> BigInt::multiply ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::multiply takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return the BigInt value that represents the product of <var>x</var> and <var>y</var>.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">Even if the result has a much larger bit width than the input, the exact mathematical answer is given.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-signedRightShift": {"num": "6.1.6.2.10", "title": "#sec-numeric-types-bigint-signedRightShift BigInt::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-signedRightShift\" type=\"numeric method\" aoid=\"BigInt::signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-signedRightShift\">#sec-numeric-types-bigint-signedRightShift</span> BigInt::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::signedRightShift takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigInt::leftShift\"><a href=\"#sec-numeric-types-bigint-leftShift\">BigInt::leftShift</a></emu-xref>(<var>x</var>, -<var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseAND": {"num": "6.1.6.1.17", "title": "#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseAND\" type=\"numeric method\" aoid=\"Number::bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseAND\">#sec-numeric-types-number-bitwiseAND</span> Number::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseAND takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-createsharedbytedatablock": {"num": "6.2.8.2", "title": "#sec-createsharedbytedatablock CreateSharedByteDataBlock ( size )", "html": "<emu-clause id=\"sec-createsharedbytedatablock\" type=\"abstract operation\" aoid=\"CreateSharedByteDataBlock\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-createsharedbytedatablock\">#sec-createsharedbytedatablock</span> CreateSharedByteDataBlock ( <var>size</var> )</h1>\n        <p>The abstract operation CreateSharedByteDataBlock takes argument <var>size</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>db</var> be a new <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>zero</var> be &#171; 0 &#187;.</li><li>For each index <var>i</var> of <var>db</var>, do<ol><li>Append <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">WriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>Init</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>db</var>, [[ByteIndex]]: <var>i</var>, [[ElementSize]]: 1, [[Payload]]: <var>zero</var> } to <var>eventList</var>.</li></ol></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>db</var>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-binaryor": {"num": "6.1.6.2.17", "title": "#sec-binaryor BinaryOr ( x, y )", "html": "<emu-clause id=\"sec-binaryor\" type=\"abstract operation\" aoid=\"BinaryOr\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-binaryor\">#sec-binaryor</span> BinaryOr ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BinaryOr takes arguments <var>x</var> (0 or 1) and <var>y</var> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is 1 or <var>y</var> is 1, return 1.</li><li>Else, return 0.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-prefix-increment-operator-runtime-semantics-evaluation": {"num": "13.4.4.1", "title": "#sec-prefix-increment-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-prefix-increment-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-prefix-increment-operator-runtime-semantics-evaluation\">#sec-prefix-increment-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"vwgxygda\">\n        <emu-t>++</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is Number, then<ol><li>Let <var>newValue</var> be ! <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#120125;</sub>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is BigInt.</li><li>Let <var>newValue</var> be ! <emu-xref aoid=\"BigInt::add\"><a href=\"#sec-numeric-types-bigint-add\">BigInt::add</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#8484;</sub>).</li></ol></li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>expr</var>, <var>newValue</var>).</li><li>Return <var>newValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-atomics.sub": {"num": "25.4.11", "title": "#sec-atomics.sub Atomics.sub ( typedArray, index, value )", "html": "<emu-clause id=\"sec-atomics.sub\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atomics.sub\">#sec-atomics.sub</span> Atomics.sub ( <var>typedArray</var>, <var>index</var>, <var>value</var> )</h1>\n      <p>The following steps are taken:</p>\n      <emu-alg><ol><li>Let <var>type</var> be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>subtract</var> be a new <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> with parameters (<var>xBytes</var>, <var>yBytes</var>) that captures <var>type</var> and <var>isLittleEndian</var> and performs the following steps atomically when called:<ol><li>Let <var>x</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>xBytes</var>, <var>isLittleEndian</var>).</li><li>Let <var>y</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>yBytes</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>Let <var>difference</var> be <emu-xref aoid=\"Number::subtract\"><a href=\"#sec-numeric-types-number-subtract\">Number::subtract</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is BigInt.</li><li>Let <var>difference</var> be <emu-xref aoid=\"BigInt::subtract\"><a href=\"#sec-numeric-types-bigint-subtract\">BigInt::subtract</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Let <var>differenceBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>difference</var>, <var>isLittleEndian</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>differenceBytes</var>, <var>xBytes</var>, and <var>yBytes</var> have the same number of elements.</li><li>Return <var>differenceBytes</var>.</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"AtomicReadModifyWrite\"><a href=\"#sec-atomicreadmodifywrite\">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <var>subtract</var>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-updateempty": {"num": "6.2.3.4", "title": "#sec-updateempty UpdateEmpty ( completionRecord, value )", "html": "<emu-clause id=\"sec-updateempty\" type=\"abstract operation\" aoid=\"UpdateEmpty\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-updateempty\">#sec-updateempty</span> UpdateEmpty ( <var>completionRecord</var>, <var>value</var> )</h1>\n        <p>The abstract operation UpdateEmpty takes arguments <var>completionRecord</var> (a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>) and <var>value</var> and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>completionRecord</var>.[[Type]] is either <emu-const>return</emu-const> or <emu-const>throw</emu-const>, then <var>completionRecord</var>.[[Value]] is not <emu-const>empty</emu-const>.</li><li>If <var>completionRecord</var>.[[Value]] is not <emu-const>empty</emu-const>, return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref>(<var>completionRecord</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref> { [[Type]]: <var>completionRecord</var>.[[Type]], [[Value]]: <var>value</var>, [[Target]]: <var>completionRecord</var>.[[Target]] }.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-number-unsignedRightShift": {"num": "6.1.6.1.11", "title": "#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-unsignedRightShift\" type=\"numeric method\" aoid=\"Number::unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unsignedRightShift\">#sec-numeric-types-number-unsignedRightShift</span> Number::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::unsignedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of performing a zero-filling right shift of <var>lnum</var> by <var>shiftCount</var> bits. Vacated bits are filled with zero. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit unsigned bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-execute-async-module": {"num": "16.2.1.5.2.2", "title": "#sec-execute-async-module ExecuteAsyncModule ( module )", "html": "<emu-clause id=\"sec-execute-async-module\" type=\"abstract operation\" aoid=\"ExecuteAsyncModule\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-execute-async-module\">#sec-execute-async-module</span> ExecuteAsyncModule ( <var>module</var> )</h1>\n            <p>The abstract operation ExecuteAsyncModule takes argument <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>) and returns <emu-const>unused</emu-const>. It performs the following steps when called:</p>\n\n            <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluating</emu-const> or <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[HasTLA]] is <emu-val>true</emu-val>.</li><li>Let <var>capability</var> be !&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>).</li><li>Let <var>fulfilledClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>module</var> and performs the following steps when called:<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionFulfilled\"><a href=\"#sec-async-module-execution-fulfilled\">AsyncModuleExecutionFulfilled</a></emu-xref>(<var>module</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>fulfilledClosure</var>, 0, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Let <var>rejectedClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>error</var>) that captures <var>module</var> and performs the following steps when called:<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionRejected\"><a href=\"#sec-async-module-execution-rejected\">AsyncModuleExecutionRejected</a></emu-xref>(<var>module</var>, <var>error</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectedClosure</var>, 0, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>capability</var>.[[Promise]], <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Perform ! <var>module</var>.ExecuteModule(<var>capability</var>).</li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n          </emu-clause>\n\n          "}, "sec-copydatablockbytes": {"num": "6.2.8.3", "title": "#sec-copydatablockbytes CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )", "html": "<emu-clause id=\"sec-copydatablockbytes\" type=\"abstract operation\" aoid=\"CopyDataBlockBytes\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-copydatablockbytes\">#sec-copydatablockbytes</span> CopyDataBlockBytes ( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> )</h1>\n        <p>The abstract operation CopyDataBlockBytes takes arguments <var>toBlock</var> (a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref> or a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>), <var>toIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>fromBlock</var> (a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref> or a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>), <var>fromIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), and <var>count</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and returns <emu-const>unused</emu-const>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>fromBlock</var> and <var>toBlock</var> are distinct values.</li><li>Let <var>fromSize</var> be the number of bytes in <var>fromBlock</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>fromIndex</var> + <var>count</var> &#8804; <var>fromSize</var>.</li><li>Let <var>toSize</var> be the number of bytes in <var>toBlock</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>toIndex</var> + <var>count</var> &#8804; <var>toSize</var>.</li><li>Repeat, while <var>count</var> &gt; 0,<ol><li>If <var>fromBlock</var> is a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>bytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose sole element is a nondeterministically chosen <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">byte value</a></emu-xref>.</li><li>NOTE: In implementations, <var>bytes</var> is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>readEvent</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadSharedMemory</a></emu-xref> { [[Order]]: <emu-const>Unordered</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>fromBlock</var>, [[ByteIndex]]: <var>fromIndex</var>, [[ElementSize]]: 1 }.</li><li>Append <var>readEvent</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>readEvent</var>, [[ChosenValue]]: <var>bytes</var> } to <var>execution</var>.[[ChosenValues]].</li><li>If <var>toBlock</var> is a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>, then<ol><li>Append <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">WriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>Unordered</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>toBlock</var>, [[ByteIndex]]: <var>toIndex</var>, [[ElementSize]]: 1, [[Payload]]: <var>bytes</var> } to <var>eventList</var>.</li></ol></li><li>Else,<ol><li>Set <var>toBlock</var>[<var>toIndex</var>] to <var>bytes</var>[0].</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>toBlock</var> is not a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Shared Data Block</a></emu-xref>.</li><li>Set <var>toBlock</var>[<var>toIndex</var>] to <var>fromBlock</var>[<var>fromIndex</var>].</li></ol></li><li>Set <var>toIndex</var> to <var>toIndex</var> + 1.</li><li>Set <var>fromIndex</var> to <var>fromIndex</var> + 1.</li><li>Set <var>count</var> to <var>count</var> - 1.</li></ol></li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-number-lessThan": {"num": "6.1.6.1.12", "title": "#sec-numeric-types-number-lessThan Number::lessThan ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-lessThan\" type=\"numeric method\" aoid=\"Number::lessThan\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-lessThan\">#sec-numeric-types-number-lessThan</span> Number::lessThan ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::lessThan takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>x</var> and <var>y</var> are the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> and <var>y</var> are finite and non-zero.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>), return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-subtract": {"num": "6.1.6.2.8", "title": "#sec-numeric-types-bigint-subtract BigInt::subtract ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-subtract\" type=\"numeric method\" aoid=\"BigInt::subtract\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-subtract\">#sec-numeric-types-bigint-subtract</span> BigInt::subtract ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::subtract takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return the BigInt value that represents the difference <var>x</var> minus <var>y</var>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-throwcompletion": {"num": "6.2.3.3", "title": "#sec-throwcompletion ThrowCompletion ( value )", "html": "<emu-clause id=\"sec-throwcompletion\" type=\"abstract operation\" aoid=\"ThrowCompletion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-throwcompletion\">#sec-throwcompletion</span> ThrowCompletion ( <var>value</var> )</h1>\n        <p>The abstract operation ThrowCompletion takes argument <var>value</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">throw completion</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref> { [[Type]]: <emu-const>throw</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-add": {"num": "6.1.6.1.7", "title": "#sec-numeric-types-number-add Number::add ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-add\" type=\"numeric method\" oldids=\"sec-applying-the-additive-operators-to-numbers\" aoid=\"Number::add\"><span id=\"sec-applying-the-additive-operators-to-numbers\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-add\">#sec-numeric-types-number-add</span> Number::add ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::add takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs addition according to the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic, producing the sum of its arguments. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> or <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <var>y</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> and <var>y</var> are both finite.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>-0</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) + <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>Finite-precision addition is commutative, but not always associative.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-equal": {"num": "6.1.6.1.13", "title": "#sec-numeric-types-number-equal Number::equal ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-equal\" type=\"numeric method\" aoid=\"Number::equal\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-equal\">#sec-numeric-types-number-equal</span> Number::equal ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::equal takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-initializereferencedbinding": {"num": "6.2.4.8", "title": "#sec-initializereferencedbinding InitializeReferencedBinding ( V, W )", "html": "<emu-clause id=\"sec-initializereferencedbinding\" type=\"abstract operation\" aoid=\"InitializeReferencedBinding\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-initializereferencedbinding\">#sec-initializereferencedbinding</span> InitializeReferencedBinding ( <var>V</var>, <var>W</var> )</h1>\n        <p>The abstract operation InitializeReferencedBinding takes arguments <var>V</var> and <var>W</var> and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>V</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>W</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>V</var> is a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsUnresolvableReference\"><a href=\"#sec-isunresolvablereference\">IsUnresolvableReference</a></emu-xref>(<var>V</var>) is <emu-val>false</emu-val>.</li><li>Let <var>base</var> be <var>V</var>.[[Base]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Return <var>base</var>.InitializeBinding(<var>V</var>.[[ReferencedName]], <var>W</var>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-binaryxor": {"num": "6.1.6.2.18", "title": "#sec-binaryxor BinaryXor ( x, y )", "html": "<emu-clause id=\"sec-binaryxor\" type=\"abstract operation\" aoid=\"BinaryXor\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-binaryxor\">#sec-binaryxor</span> BinaryXor ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BinaryXor takes arguments <var>x</var> (0 or 1) and <var>y</var> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is 1 and <var>y</var> is 0, return 1.</li><li>Else if <var>x</var> is 0 and <var>y</var> is 1, return 1.</li><li>Else, return 0.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseXOR": {"num": "6.1.6.2.21", "title": "#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseXOR\" type=\"numeric method\" aoid=\"BigInt::bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseXOR\">#sec-numeric-types-bigint-bitwiseXOR</span> BigInt::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseXOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-completion-record-specification-type": {"num": "6.2.3", "title": "#sec-completion-record-specification-type The Completion Record Specification Type", "html": "<emu-clause id=\"sec-completion-record-specification-type\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completion-record-specification-type\">#sec-completion-record-specification-type</span> The Completion Record Specification Type</h1>\n      <p>The <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref> type is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> used to explain the runtime propagation of values and control flow such as the behaviour of statements (<code>break</code>, <code>continue</code>, <code>return</code> and <code>throw</code>) that perform nonlocal transfers of control.</p>\n      <p>Values of the <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref> type are <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> values whose fields are defined by <emu-xref href=\"#table-completion-record-fields\"><a href=\"#table-completion-record-fields\" class=\"excluded-xref\" excluded-id=\"table-completion-record-fields\">#table-completion-record-fields</a></emu-xref>. Such values are referred to as <dfn variants=\"Completion Record\">Completion Records</dfn>.</p>\n      <emu-table id=\"table-completion-record-fields\" caption=\"Completion Record Fields\" oldids=\"table-8\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-completion-record-fields\">#table-completion-record-fields</span>: <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> Fields</figcaption><span id=\"table-8\"></span>\n        <table>\n          <tbody>\n          <tr>\n            <th>\n              Field Name\n            </th>\n            <th>\n              Value\n            </th>\n            <th>\n              Meaning\n            </th>\n          </tr>\n          <tr>\n            <td>\n              [[Type]]\n            </td>\n            <td>\n              One of <emu-const>normal</emu-const>, <emu-const>break</emu-const>, <emu-const>continue</emu-const>, <emu-const>return</emu-const>, or <emu-const>throw</emu-const>\n            </td>\n            <td>\n              The type of completion that occurred.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Value]]\n            </td>\n            <td>\n              any <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref> or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The value that was produced.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Target]]\n            </td>\n            <td>\n              any ECMAScript string or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The target label for directed control transfers.\n            </td>\n          </tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <p>The following shorthand terms are sometimes used to refer to completions.</p>\n      <ul>\n        <li><dfn variants=\"normal completions\">normal completion</dfn> refers to any completion with a [[Type]] value of <emu-const>normal</emu-const>.</li>\n        <li><dfn variants=\"break completions\">break completion</dfn> refers to any completion with a [[Type]] value of <emu-const>break</emu-const>.</li>\n        <li><dfn variants=\"continue completions\">continue completion</dfn> refers to any completion with a [[Type]] value of <emu-const>continue</emu-const>.</li>\n        <li><dfn variants=\"return completions\">return completion</dfn> refers to any completion with a [[Type]] value of <emu-const>return</emu-const>.</li>\n        <li><dfn variants=\"throw completions\">throw completion</dfn> refers to any completion with a [[Type]] value of <emu-const>throw</emu-const>.</li>\n        <li><dfn variants=\"abrupt completions\">abrupt completion</dfn> refers to any completion with a [[Type]] value other than <emu-const>normal</emu-const>.</li>\n      </ul>\n      <p>Callable objects that are defined in this specification only return a normal completion or a throw completion. Returning any other kind of completion is considered an editorial error.</p>\n      <p><emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">Implementation-defined</a></emu-xref> callable objects must return either a normal completion or a throw completion.</p>\n\n      <emu-clause id=\"await\" oldids=\"await-fulfilled,await-rejected\" aoid=\"Await\"><span id=\"await-rejected\"></span><span id=\"await-fulfilled\"></span>\n        <h1><span class=\"secnum\">6.2.3.1</span> Await</h1>\n\n        <p>Algorithm steps that say</p>\n\n        <emu-alg><ol><li>Let <var>completion</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n        <p>mean the same thing as:</p>\n\n        <emu-alg><ol><li>Let <var>asyncContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li>Let <var>fulfilledClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>value</var>) that captures <var>asyncContext</var> and performs the following steps when called:<ol><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Suspend <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>value</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>fulfilledClosure</var>, 1, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Let <var>rejectedClosure</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>reason</var>) that captures <var>asyncContext</var> and performs the following steps when called:<ol><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Suspend <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>reason</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectedClosure</var>, 1, <emu-val>\"\"</emu-val>, &#171; &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed with a <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref> <var>completion</var>, the following steps of the algorithm that invoked <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> will be performed, with <var>completion</var> available.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>unused</emu-const>).</li><li>NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of <var>asyncContext</var>.</li></ol></emu-alg>\n\n        <p>where all aliases in the above steps, with the exception of <var>completion</var>, are ephemeral and visible only in the steps pertaining to Await.</p>\n\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Await can be combined with the <code>?</code> and <code>!</code> prefixes, so that for example</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n          <p>means the same thing as:</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </div></emu-note>\n      </emu-clause>\n\n      <div id=\"excluded-sec-normalcompletion\"><h1><span class=\"secnum\">6.2.3.2</span>#sec-normalcompletion NormalCompletion ( value )</h1>...</div><div id=\"excluded-sec-throwcompletion\"><h1><span class=\"secnum\">6.2.3.3</span>#sec-throwcompletion ThrowCompletion ( value )</h1>...</div><div id=\"excluded-sec-updateempty\"><h1><span class=\"secnum\">6.2.3.4</span>#sec-updateempty UpdateEmpty ( completionRecord, value )</h1>...</div></emu-clause>\n\n    "}, "sec-ispropertyreference": {"num": "6.2.4.1", "title": "#sec-ispropertyreference IsPropertyReference ( V )", "html": "<emu-clause id=\"sec-ispropertyreference\" type=\"abstract operation\" oldids=\"ao-ispropertyreference\" aoid=\"IsPropertyReference\"><span id=\"ao-ispropertyreference\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ispropertyreference\">#sec-ispropertyreference</span> IsPropertyReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsPropertyReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[Base]] is <emu-const>unresolvable</emu-const>, return <emu-val>false</emu-val>.</li><li>If <var>V</var>.[[Base]] is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, return <emu-val>false</emu-val>; otherwise return <emu-val>true</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isdatadescriptor": {"num": "6.2.5.2", "title": "#sec-isdatadescriptor IsDataDescriptor ( Desc )", "html": "<emu-clause id=\"sec-isdatadescriptor\" type=\"abstract operation\" aoid=\"IsDataDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isdatadescriptor\">#sec-isdatadescriptor</span> IsDataDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation IsDataDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>false</emu-val>.</li><li>If both <var>Desc</var>.[[Value]] and <var>Desc</var>.[[Writable]] are absent, return <emu-val>false</emu-val>.</li><li>Return <emu-val>true</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-bitwiseNOT": {"num": "6.1.6.1.2", "title": "#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseNOT\" type=\"numeric method\" aoid=\"Number::bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseNOT\">#sec-numeric-types-number-bitwiseNOT</span> Number::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation Number::bitwiseNOT takes argument <var>x</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>oldValue</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Return the result of applying bitwise complement to <var>oldValue</var>. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-getvalue": {"num": "6.2.4.5", "title": "#sec-getvalue GetValue ( V )", "html": "<emu-clause id=\"sec-getvalue\" type=\"abstract operation\" aoid=\"GetValue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getvalue\">#sec-getvalue</span> GetValue ( <var>V</var> )</h1>\n        <p>The abstract operation GetValue takes argument <var>V</var> and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>V</var>).</li><li>If <var>V</var> is not a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>, return <var>V</var>.</li><li>If <emu-xref aoid=\"IsUnresolvableReference\"><a href=\"#sec-isunresolvablereference\">IsUnresolvableReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>If <emu-xref aoid=\"IsPropertyReference\"><a href=\"#sec-ispropertyreference\">IsPropertyReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li id=\"step-getvalue-toobject\">Let <var>baseObj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>V</var>.[[Base]]).</li><li>If <emu-xref aoid=\"IsPrivateReference\"><a href=\"#sec-isprivatereference\">IsPrivateReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"PrivateGet\"><a href=\"#sec-privateget\">PrivateGet</a></emu-xref>(<var>baseObj</var>, <var>V</var>.[[ReferencedName]]).</li></ol></li><li>Return ? <var>baseObj</var>.[[Get]](<var>V</var>.[[ReferencedName]], <emu-xref aoid=\"GetThisValue\"><a href=\"#sec-getthisvalue\">GetThisValue</a></emu-xref>(<var>V</var>)).</li></ol></li><li>Else,<ol><li>Let <var>base</var> be <var>V</var>.[[Base]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Return ? <var>base</var>.GetBindingValue(<var>V</var>.[[ReferencedName]], <var>V</var>.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\" class=\"excluded-xref\" excluded-id=\"sec-environment-records\">#sec-environment-records</a></emu-xref>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The object that may be created in step <emu-xref href=\"#step-getvalue-toobject\"><a href=\"#step-getvalue-toobject\">4.a</a></emu-xref> is not accessible outside of the above abstract operation and the <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-normalcompletion": {"num": "6.2.3.2", "title": "#sec-normalcompletion NormalCompletion ( value )", "html": "<emu-clause id=\"sec-normalcompletion\" type=\"abstract operation\" aoid=\"NormalCompletion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-normalcompletion\">#sec-normalcompletion</span> NormalCompletion ( <var>value</var> )</h1>\n        <p>The abstract operation NormalCompletion takes argument <var>value</var> and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">normal completion</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-ao\">Completion</a></emu-xref> { [[Type]]: <emu-const>normal</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncblockstart": {"num": "27.7.5.2", "title": "#sec-asyncblockstart AsyncBlockStart ( promiseCapability, asyncBody, asyncContext )", "html": "<emu-clause id=\"sec-asyncblockstart\" type=\"abstract operation\" aoid=\"AsyncBlockStart\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncblockstart\">#sec-asyncblockstart</span> AsyncBlockStart ( <var>promiseCapability</var>, <var>asyncBody</var>, <var>asyncContext</var> )</h1>\n        <p>The abstract operation AsyncBlockStart takes arguments <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), <var>asyncBody</var> (a <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">Parse Node</a></emu-xref>), and <var>asyncContext</var> (an <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>) and returns <emu-const>unused</emu-const>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>.</li><li>Let <var>runningContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncBody</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li id=\"step-asyncblockstart-return-undefined\">Return <emu-const>unused</emu-const>.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">normal completion</a></emu-xref> with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"><a href=\"#step-asyncblockstart-return-undefined\">3.g</a></emu-xref> above.</li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-stringindexof": {"num": "6.1.4.1", "title": "#sec-stringindexof StringIndexOf ( string, searchValue, fromIndex )", "html": "<emu-clause id=\"sec-stringindexof\" type=\"abstract operation\" aoid=\"StringIndexOf\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-stringindexof\">#sec-stringindexof</span> StringIndexOf ( <var>string</var>, <var>searchValue</var>, <var>fromIndex</var> )</h1>\n        <p>The abstract operation StringIndexOf takes arguments <var>string</var> (a String), <var>searchValue</var> (a String), and <var>fromIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and returns an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>len</var> be the length of <var>string</var>.</li><li>If <var>searchValue</var> is the empty String and <var>fromIndex</var> &#8804; <var>len</var>, return <var>fromIndex</var>.</li><li>Let <var>searchLen</var> be the length of <var>searchValue</var>.</li><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> starting with <var>fromIndex</var> such that <var>i</var> &#8804; <var>len</var> - <var>searchLen</var>, in ascending order, do<ol><li>Let <var>candidate</var> be the <emu-xref href=\"#substring\"><a href=\"#substring\">substring</a></emu-xref> of <var>string</var> from <var>i</var> to <var>i</var> + <var>searchLen</var>.</li><li>If <var>candidate</var> is the same sequence of code units as <var>searchValue</var>, return <var>i</var>.</li></ol></li><li>Return -1.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>If <var>searchValue</var> is the empty String and <var>fromIndex</var> is less than or equal to the length of <var>string</var>, this algorithm returns <var>fromIndex</var>. The empty String is effectively found at every position within a string, including after the last code unit.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>This algorithm always returns -1 if <var>fromIndex</var> &gt; the length of <var>string</var>.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-completepropertydescriptor": {"num": "6.2.5.6", "title": "#sec-completepropertydescriptor CompletePropertyDescriptor ( Desc )", "html": "<emu-clause id=\"sec-completepropertydescriptor\" type=\"abstract operation\" aoid=\"CompletePropertyDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completepropertydescriptor\">#sec-completepropertydescriptor</span> CompletePropertyDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation CompletePropertyDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref>) and returns a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>like</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>undefined</emu-val>, [[Writable]]: <emu-val>false</emu-val>, [[Get]]: <emu-val>undefined</emu-val>, [[Set]]: <emu-val>undefined</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</li><li>If <emu-xref aoid=\"IsGenericDescriptor\"><a href=\"#sec-isgenericdescriptor\">IsGenericDescriptor</a></emu-xref>(<var>Desc</var>) is <emu-val>true</emu-val> or <emu-xref aoid=\"IsDataDescriptor\"><a href=\"#sec-isdatadescriptor\">IsDataDescriptor</a></emu-xref>(<var>Desc</var>) is <emu-val>true</emu-val>, then<ol><li>If <var>Desc</var> does not have a [[Value]] field, set <var>Desc</var>.[[Value]] to <var>like</var>.[[Value]].</li><li>If <var>Desc</var> does not have a [[Writable]] field, set <var>Desc</var>.[[Writable]] to <var>like</var>.[[Writable]].</li></ol></li><li>Else,<ol><li>If <var>Desc</var> does not have a [[Get]] field, set <var>Desc</var>.[[Get]] to <var>like</var>.[[Get]].</li><li>If <var>Desc</var> does not have a [[Set]] field, set <var>Desc</var>.[[Set]] to <var>like</var>.[[Set]].</li></ol></li><li>If <var>Desc</var> does not have an [[Enumerable]] field, set <var>Desc</var>.[[Enumerable]] to <var>like</var>.[[Enumerable]].</li><li>If <var>Desc</var> does not have a [[Configurable]] field, set <var>Desc</var>.[[Configurable]] to <var>like</var>.[[Configurable]].</li><li>Return <var>Desc</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-divide": {"num": "6.1.6.2.5", "title": "#sec-numeric-types-bigint-divide BigInt::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-divide\" type=\"numeric method\" aoid=\"BigInt::divide\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-divide\">#sec-numeric-types-bigint-divide</span> BigInt::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::divide takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>y</var> is <emu-val>0</emu-val><sub>&#8484;</sub>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>quotient</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) / <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(the BigInt value that represents <var>quotient</var> rounded towards 0 to the next <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> value).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseOR": {"num": "6.1.6.1.19", "title": "#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseOR\" type=\"numeric method\" aoid=\"Number::bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseOR\">#sec-numeric-types-number-bitwiseOR</span> Number::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseOR takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-postfix-increment-operator-runtime-semantics-evaluation": {"num": "13.4.2.1", "title": "#sec-postfix-increment-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-postfix-increment-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-postfix-increment-operator-runtime-semantics-evaluation\">#sec-postfix-increment-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"i_jjg0ex\">\n        <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>\n        <emu-t>++</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>lhs</var> be the result of evaluating <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>lhs</var>)).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is Number, then<ol><li>Let <var>newValue</var> be ! <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#120125;</sub>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is BigInt.</li><li>Let <var>newValue</var> be ! <emu-xref aoid=\"BigInt::add\"><a href=\"#sec-numeric-types-bigint-add\">BigInt::add</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#8484;</sub>).</li></ol></li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhs</var>, <var>newValue</var>).</li><li>Return <var>oldValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-leftShift": {"num": "6.1.6.2.9", "title": "#sec-numeric-types-bigint-leftShift BigInt::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-leftShift\" type=\"numeric method\" aoid=\"BigInt::leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-leftShift\">#sec-numeric-types-bigint-leftShift</span> BigInt::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::leftShift takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>y</var> &lt; <emu-val>0</emu-val><sub>&#8484;</sub>, then<ol><li>Return the BigInt value that represents <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) / 2<sup>-<var>y</var></sup>, rounding down to the nearest <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, including for negative numbers.</li></ol></li><li>Return the BigInt value that represents <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &#215; 2<sup><var>y</var></sup>.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">Semantics here should be equivalent to a bitwise shift, treating the BigInt as an infinite length string of binary two's complement digits.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-multiply": {"num": "6.1.6.1.4", "title": "#sec-numeric-types-number-multiply Number::multiply ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-multiply\" type=\"numeric method\" oldids=\"sec-applying-the-mul-operator\" aoid=\"Number::multiply\"><span id=\"sec-applying-the-mul-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-multiply\">#sec-numeric-types-number-multiply</span> Number::multiply ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::multiply takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs multiplication according to the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic, producing the product of <var>x</var> and <var>y</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> or <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>y</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>Return -<var>x</var>.</li></ol></li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>y</var>.</li><li>Return -<var>y</var>.</li></ol></li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &#215; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>Finite-precision multiplication is commutative, but not always associative.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-samevalue": {"num": "7.2.10", "title": "#sec-samevalue SameValue ( x, y )", "html": "<emu-clause id=\"sec-samevalue\" type=\"abstract operation\" aoid=\"SameValue\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-samevalue\">#sec-samevalue</span> SameValue ( <var>x</var>, <var>y</var> )</h1>\n      <p>The abstract operation SameValue takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It returns a completion record whose [[Type]] is <emu-const>normal</emu-const> and whose [[Value]] is a Boolean indicating whether or not the two arguments are the same value. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>Return ! <emu-xref aoid=\"Number::sameValue\"><a href=\"#sec-numeric-types-number-sameValue\">Number::sameValue</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is BigInt, then<ol><li>Return ! <emu-xref aoid=\"BigInt::sameValue\"><a href=\"#sec-numeric-types-bigint-sameValue\">BigInt::sameValue</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Return !&#160;<emu-xref aoid=\"SameValueNonNumeric\"><a href=\"#sec-samevaluenonnumeric\">SameValueNonNumeric</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>This algorithm differs from the <emu-xref aoid=\"IsStrictlyEqual\"><a href=\"#sec-isstrictlyequal\">IsStrictlyEqual</a></emu-xref> Algorithm by treating all <emu-val>NaN</emu-val> values as equivalent and by differentiating <emu-val>+0</emu-val><sub>&#120125;</sub> from <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-numeric-types-bigint-lessThan": {"num": "6.1.6.2.12", "title": "#sec-numeric-types-bigint-lessThan BigInt::lessThan ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-lessThan\" type=\"numeric method\" aoid=\"BigInt::lessThan\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-lessThan\">#sec-numeric-types-bigint-lessThan</span> BigInt::lessThan ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::lessThan takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-isgenericdescriptor": {"num": "6.2.5.3", "title": "#sec-isgenericdescriptor IsGenericDescriptor ( Desc )", "html": "<emu-clause id=\"sec-isgenericdescriptor\" type=\"abstract operation\" aoid=\"IsGenericDescriptor\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isgenericdescriptor\">#sec-isgenericdescriptor</span> IsGenericDescriptor ( <var>Desc</var> )</h1>\n        <p>The abstract operation IsGenericDescriptor takes argument <var>Desc</var> (a <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref> or <emu-val>undefined</emu-val>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>Desc</var> is <emu-val>undefined</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsAccessorDescriptor\"><a href=\"#sec-isaccessordescriptor\">IsAccessorDescriptor</a></emu-xref>(<var>Desc</var>) and <emu-xref aoid=\"IsDataDescriptor\"><a href=\"#sec-isdatadescriptor\">IsDataDescriptor</a></emu-xref>(<var>Desc</var>) are both <emu-val>false</emu-val>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-runtime-semantics": {"num": "5.2.3", "title": "#sec-runtime-semantics Runtime Semantics", "html": "<emu-clause id=\"sec-runtime-semantics\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics\">#sec-runtime-semantics</span> Runtime Semantics</h1>\n      <p>Algorithms which specify semantics that must be called at runtime are called <dfn>runtime semantics</dfn>. Runtime semantics are defined by <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> or syntax-directed operations.</p>\n      <div id=\"excluded-sec-completion-ao\"><h1><span class=\"secnum\">5.2.3.1</span>#sec-completion-ao Completion ( completionRecord )</h1>...</div><div id=\"excluded-sec-throw-an-exception\"><h1><span class=\"secnum\">5.2.3.2</span>#sec-throw-an-exception Throw an Exception</h1>...</div><div id=\"excluded-sec-returnifabrupt\"><h1><span class=\"secnum\">5.2.3.3</span>#sec-returnifabrupt ReturnIfAbrupt</h1>...</div><div id=\"excluded-sec-returnifabrupt-shorthands\"><h1><span class=\"secnum\">5.2.3.4</span>#sec-returnifabrupt-shorthands ReturnIfAbrupt Shorthands</h1>...</div></emu-clause>\n    "}, "sec-async-module-execution-rejected": {"num": "16.2.1.5.2.5", "title": "#sec-async-module-execution-rejected AsyncModuleExecutionRejected ( module, error )", "html": "<emu-clause id=\"sec-async-module-execution-rejected\" type=\"abstract operation\" aoid=\"AsyncModuleExecutionRejected\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-module-execution-rejected\">#sec-async-module-execution-rejected</span> AsyncModuleExecutionRejected ( <var>module</var>, <var>error</var> )</h1>\n            <p>The abstract operation AsyncModuleExecutionRejected takes arguments <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>) and <var>error</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and returns <emu-const>unused</emu-const>. It performs the following steps when called:</p>\n            <emu-alg><ol><li>If <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is not <emu-const>empty</emu-const>.</li><li>Return <emu-const>unused</emu-const>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[AsyncEvaluation]] is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is <emu-const>empty</emu-const>.</li><li>Set <var>module</var>.[[EvaluationError]] to <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>error</var>).</li><li>Set <var>module</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> of <var>module</var>.[[AsyncParentModules]], do<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionRejected\"><a href=\"#sec-async-module-execution-rejected\">AsyncModuleExecutionRejected</a></emu-xref>(<var>m</var>, <var>error</var>).</li></ol></li><li>If <var>module</var>.[[TopLevelCapability]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[CycleRoot]] is <var>module</var>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>module</var>.[[TopLevelCapability]].[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>error</var> &#187;).</li></ol></li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n          </emu-clause>\n        "}, "sec-createbytedatablock": {"num": "6.2.8.1", "title": "#sec-createbytedatablock CreateByteDataBlock ( size )", "html": "<emu-clause id=\"sec-createbytedatablock\" type=\"abstract operation\" aoid=\"CreateByteDataBlock\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-createbytedatablock\">#sec-createbytedatablock</span> CreateByteDataBlock ( <var>size</var> )</h1>\n        <p>The abstract operation CreateByteDataBlock takes argument <var>size</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>db</var> be a new <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Set all of the bytes of <var>db</var> to 0.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>db</var>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-getthisvalue": {"num": "6.2.4.7", "title": "#sec-getthisvalue GetThisValue ( V )", "html": "<emu-clause id=\"sec-getthisvalue\" type=\"abstract operation\" aoid=\"GetThisValue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getthisvalue\">#sec-getthisvalue</span> GetThisValue ( <var>V</var> )</h1>\n        <p>The abstract operation GetThisValue takes argument <var>V</var> and returns an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsPropertyReference\"><a href=\"#sec-ispropertyreference\">IsPropertyReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>.</li><li>If <emu-xref aoid=\"IsSuperReference\"><a href=\"#sec-issuperreference\">IsSuperReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, return <var>V</var>.[[ThisValue]]; otherwise return <var>V</var>.[[Base]].</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-bigint-bitwiseAND": {"num": "6.1.6.2.20", "title": "#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseAND\" type=\"numeric method\" aoid=\"BigInt::bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseAND\">#sec-numeric-types-bigint-bitwiseAND</span> BigInt::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseAND takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-sameValueZero": {"num": "6.1.6.2.15", "title": "#sec-numeric-types-bigint-sameValueZero BigInt::sameValueZero ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-sameValueZero\" type=\"numeric method\" aoid=\"BigInt::sameValueZero\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-sameValueZero\">#sec-numeric-types-bigint-sameValueZero</span> BigInt::sameValueZero ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::sameValueZero takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigInt::equal\"><a href=\"#sec-numeric-types-bigint-equal\">BigInt::equal</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-async-module-execution-fulfilled": {"num": "16.2.1.5.2.4", "title": "#sec-async-module-execution-fulfilled AsyncModuleExecutionFulfilled ( module )", "html": "<emu-clause id=\"sec-async-module-execution-fulfilled\" type=\"abstract operation\" aoid=\"AsyncModuleExecutionFulfilled\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-module-execution-fulfilled\">#sec-async-module-execution-fulfilled</span> AsyncModuleExecutionFulfilled ( <var>module</var> )</h1>\n            <p>The abstract operation AsyncModuleExecutionFulfilled takes argument <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>) and returns <emu-const>unused</emu-const>. It performs the following steps when called:</p>\n            <emu-alg><ol><li>If <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is not <emu-const>empty</emu-const>.</li><li>Return <emu-const>unused</emu-const>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluating-async</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[AsyncEvaluation]] is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[EvaluationError]] is <emu-const>empty</emu-const>.</li><li>Set <var>module</var>.[[AsyncEvaluation]] to <emu-val>false</emu-val>.</li><li>Set <var>module</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>If <var>module</var>.[[TopLevelCapability]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[CycleRoot]] is <var>module</var>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>module</var>.[[TopLevelCapability]].[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Let <var>execList</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Perform !&#160;<emu-xref aoid=\"GatherAvailableAncestors\"><a href=\"#sec-gather-available-ancestors\">GatherAvailableAncestors</a></emu-xref>(<var>module</var>, <var>execList</var>).</li><li>Let <var>sortedExecList</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the elements of <var>execList</var>, in the order in which they had their [[AsyncEvaluation]] fields set to <emu-val>true</emu-val> in <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: All elements of <var>sortedExecList</var> have their [[AsyncEvaluation]] field set to <emu-val>true</emu-val>, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to <emu-const>empty</emu-const>.</li><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> of <var>sortedExecList</var>, do<ol><li>If <var>m</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[EvaluationError]] is not <emu-const>empty</emu-const>.</li></ol></li><li>Else if <var>m</var>.[[HasTLA]] is <emu-val>true</emu-val>, then<ol><li>Perform !&#160;<emu-xref aoid=\"ExecuteAsyncModule\"><a href=\"#sec-execute-async-module\">ExecuteAsyncModule</a></emu-xref>(<var>m</var>).</li></ol></li><li>Else,<ol><li>Let <var>result</var> be <var>m</var>.ExecuteModule().</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Perform !&#160;<emu-xref aoid=\"AsyncModuleExecutionRejected\"><a href=\"#sec-async-module-execution-rejected\">AsyncModuleExecutionRejected</a></emu-xref>(<var>m</var>, <var>result</var>.[[Value]]).</li></ol></li><li>Else,<ol><li>Set <var>m</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>If <var>m</var>.[[TopLevelCapability]] is not <emu-const>empty</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[CycleRoot]] is <var>m</var>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>m</var>.[[TopLevelCapability]].[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li></ol></li></ol></li></ol></li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n          </emu-clause>\n\n          "}, "sec-static-semantics-classelementevaluation": {"num": "15.7.13", "title": "#sec-static-semantics-classelementevaluation Runtime Semantics: ClassElementEvaluation", "html": "<emu-clause id=\"sec-static-semantics-classelementevaluation\" type=\"sdo\" aoid=\"ClassElementEvaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-static-semantics-classelementevaluation\">#sec-static-semantics-classelementevaluation</span> Runtime Semantics: ClassElementEvaluation</h1>\n      <p>The syntax-directed operation ClassElementEvaluation takes argument <var>object</var>. It is defined piecewise over the following productions:</p>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"bwbyf1-5\" id=\"prod-tPq9hD-G\">\n        <emu-nt><a href=\"#prod-FieldDefinition\">FieldDefinition</a></emu-nt>\n        <emu-t>;</emu-t>\n    </emu-rhs>\n</emu-production>\n<emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"cpyv1xvc\" id=\"prod-Cn1oLmsN\">\n        <emu-t>static</emu-t>\n        <emu-nt><a href=\"#prod-FieldDefinition\">FieldDefinition</a></emu-nt>\n        <emu-t>;</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"ClassFieldDefinitionEvaluation\"><a href=\"#sec-runtime-semantics-classfielddefinitionevaluation\">ClassFieldDefinitionEvaluation</a></emu-xref> of <emu-nt><a href=\"#prod-FieldDefinition\">FieldDefinition</a></emu-nt> with argument <var>object</var>.</li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"s8ilfl9g\" id=\"prod-Qe_eKZ3f\"><emu-nt><a href=\"#prod-MethodDefinition\">MethodDefinition</a></emu-nt></emu-rhs>\n</emu-production>\n<emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"-ljgtrpo\" id=\"prod-DNhqQKHO\">\n        <emu-t>static</emu-t>\n        <emu-nt><a href=\"#prod-MethodDefinition\">MethodDefinition</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"MethodDefinitionEvaluation\"><a href=\"#sec-runtime-semantics-methoddefinitionevaluation\">MethodDefinitionEvaluation</a></emu-xref> of <emu-nt><a href=\"#prod-MethodDefinition\">MethodDefinition</a></emu-nt> with arguments <var>object</var> and <emu-val>false</emu-val>.</li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"2ui-f2qn\" id=\"prod-Hb23PvBK\"><emu-nt><a href=\"#prod-ClassStaticBlock\">ClassStaticBlock</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"ClassStaticBlockDefinitionEvaluation\"><a href=\"#sec-runtime-semantics-classstaticblockdefinitionevaluation\">ClassStaticBlockDefinitionEvaluation</a></emu-xref> of <emu-nt><a href=\"#prod-ClassStaticBlock\">ClassStaticBlock</a></emu-nt> with argument <var>object</var>.</li></ol></emu-alg>\n\n      <emu-grammar><emu-production name=\"ClassElement\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"sg2sawim\" id=\"prod-V88LvFxI\"><emu-t>;</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-putvalue": {"num": "6.2.4.6", "title": "#sec-putvalue PutValue ( V, W )", "html": "<emu-clause id=\"sec-putvalue\" type=\"abstract operation\" aoid=\"PutValue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-putvalue\">#sec-putvalue</span> PutValue ( <var>V</var>, <var>W</var> )</h1>\n        <p>The abstract operation PutValue takes arguments <var>V</var> and <var>W</var> and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>V</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>W</var>).</li><li>If <var>V</var> is not a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>If <emu-xref aoid=\"IsUnresolvableReference\"><a href=\"#sec-isunresolvablereference\">IsUnresolvableReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li>If <var>V</var>.[[Strict]] is <emu-val>true</emu-val>, throw a <emu-val>ReferenceError</emu-val> exception.</li><li>Let <var>globalObj</var> be <emu-xref aoid=\"GetGlobalObject\"><a href=\"#sec-getglobalobject\">GetGlobalObject</a></emu-xref>().</li><li>Return ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>globalObj</var>, <var>V</var>.[[ReferencedName]], <var>W</var>, <emu-val>false</emu-val>).</li></ol></li><li>If <emu-xref aoid=\"IsPropertyReference\"><a href=\"#sec-ispropertyreference\">IsPropertyReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li id=\"step-putvalue-toobject\">Let <var>baseObj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>V</var>.[[Base]]).</li><li>If <emu-xref aoid=\"IsPrivateReference\"><a href=\"#sec-isprivatereference\">IsPrivateReference</a></emu-xref>(<var>V</var>) is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"PrivateSet\"><a href=\"#sec-privateset\">PrivateSet</a></emu-xref>(<var>baseObj</var>, <var>V</var>.[[ReferencedName]], <var>W</var>).</li></ol></li><li>Let <var>succeeded</var> be ? <var>baseObj</var>.[[Set]](<var>V</var>.[[ReferencedName]], <var>W</var>, <emu-xref aoid=\"GetThisValue\"><a href=\"#sec-getthisvalue\">GetThisValue</a></emu-xref>(<var>V</var>)).</li><li>If <var>succeeded</var> is <emu-val>false</emu-val> and <var>V</var>.[[Strict]] is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>unused</emu-const>).</li></ol></li><li>Else,<ol><li>Let <var>base</var> be <var>V</var>.[[Base]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is an <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>.</li><li>Return ? <var>base</var>.SetMutableBinding(<var>V</var>.[[ReferencedName]], <var>W</var>, <var>V</var>.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\" class=\"excluded-xref\" excluded-id=\"sec-environment-records\">#sec-environment-records</a></emu-xref>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The object that may be created in step <emu-xref href=\"#step-putvalue-toobject\"><a href=\"#step-putvalue-toobject\">5.a</a></emu-xref> is not accessible outside of the above abstract operation and the <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-subtract": {"num": "6.1.6.1.8", "title": "#sec-numeric-types-number-subtract Number::subtract ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-subtract\" type=\"numeric method\" aoid=\"Number::subtract\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-subtract\">#sec-numeric-types-number-subtract</span> Number::subtract ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::subtract takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs subtraction, producing the difference of its operands; <var>x</var> is the minuend and <var>y</var> is the subtrahend. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>(<var>x</var>, <emu-xref aoid=\"Number::unaryMinus\"><a href=\"#sec-numeric-types-number-unaryMinus\">Number::unaryMinus</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>It is always the case that <code>x - y</code> produces the same result as <code>x + (-y)</code>.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-importedlocalnames": {"num": "16.2.1.2", "title": "#sec-importedlocalnames Static Semantics: ImportedLocalNames ( importEntries )", "html": "<emu-clause id=\"sec-importedlocalnames\" type=\"abstract operation\" aoid=\"ImportedLocalNames\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-importedlocalnames\">#sec-importedlocalnames</span> Static Semantics: ImportedLocalNames ( <var>importEntries</var> )</h1>\n        <p>The abstract operation ImportedLocalNames takes argument <var>importEntries</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Records</a></emu-xref>). It creates a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of all of the local name bindings defined by <var>importEntries</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>localNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Record</a></emu-xref> <var>i</var> of <var>importEntries</var>, do<ol><li>Append <var>i</var>.[[LocalName]] to <var>localNames</var>.</li></ol></li><li>Return <var>localNames</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isstrictlyequal": {"num": "7.2.15", "title": "#sec-isstrictlyequal IsStrictlyEqual ( x, y )", "html": "<emu-clause id=\"sec-isstrictlyequal\" type=\"abstract operation\" oldids=\"sec-strict-equality-comparison\" aoid=\"IsStrictlyEqual\"><span id=\"sec-strict-equality-comparison\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isstrictlyequal\">#sec-isstrictlyequal</span> IsStrictlyEqual ( <var>x</var>, <var>y</var> )</h1>\n      <p>The abstract operation IsStrictlyEqual takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It provides the semantics for the comparison <var>x</var> === <var>y</var>, returning <emu-val>true</emu-val> or <emu-val>false</emu-val>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>Return ! <emu-xref aoid=\"Number::equal\"><a href=\"#sec-numeric-types-number-equal\">Number::equal</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is BigInt, then<ol><li>Return ! <emu-xref aoid=\"BigInt::equal\"><a href=\"#sec-numeric-types-bigint-equal\">BigInt::equal</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Return !&#160;<emu-xref aoid=\"SameValueNonNumeric\"><a href=\"#sec-samevaluenonnumeric\">SameValueNonNumeric</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>This algorithm differs from the <emu-xref aoid=\"SameValue\"><a href=\"#sec-samevalue\">SameValue</a></emu-xref> Algorithm in its treatment of signed zeroes and NaNs.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-applystringornumericbinaryoperator": {"num": "13.15.3", "title": "#sec-applystringornumericbinaryoperator ApplyStringOrNumericBinaryOperator ( lval, opText, rval )", "html": "<emu-clause id=\"sec-applystringornumericbinaryoperator\" type=\"abstract operation\" aoid=\"ApplyStringOrNumericBinaryOperator\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</span> ApplyStringOrNumericBinaryOperator ( <var>lval</var>, <var>opText</var>, <var>rval</var> )</h1>\n      <p>The abstract operation ApplyStringOrNumericBinaryOperator takes arguments <var>lval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>opText</var> (<code>**</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>+</code>, <code>-</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, or <code>|</code>), and <var>rval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <var>opText</var> is <code>+</code>, then<ol><li id=\"step-binary-op-toprimitive-lval\">Let <var>lprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>lval</var>).</li><li id=\"step-binary-op-toprimitive-rval\">Let <var>rprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>rval</var>).</li><li id=\"step-binary-op-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lprim</var>) is String or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rprim</var>) is String, then<ol><li>Let <var>lstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>lprim</var>).</li><li>Let <var>rstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>rprim</var>).</li><li>Return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of <var>lstr</var> and <var>rstr</var>.</li></ol></li><li>Set <var>lval</var> to <var>lprim</var>.</li><li>Set <var>rval</var> to <var>rprim</var>.</li></ol></li><li>NOTE: At this point, it must be a numeric operation.</li><li>Let <var>lnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>lval</var>).</li><li>Let <var>rnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>rval</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rnum</var>), throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) is BigInt, then<ol><li>If <var>opText</var> is <code>**</code>, return ? <emu-xref aoid=\"BigInt::exponentiate\"><a href=\"#sec-numeric-types-bigint-exponentiate\">BigInt::exponentiate</a></emu-xref>(<var>lnum</var>, <var>rnum</var>).</li><li>If <var>opText</var> is <code>/</code>, return ? <emu-xref aoid=\"BigInt::divide\"><a href=\"#sec-numeric-types-bigint-divide\">BigInt::divide</a></emu-xref>(<var>lnum</var>, <var>rnum</var>).</li><li>If <var>opText</var> is <code>%</code>, return ? <emu-xref aoid=\"BigInt::remainder\"><a href=\"#sec-numeric-types-bigint-remainder\">BigInt::remainder</a></emu-xref>(<var>lnum</var>, <var>rnum</var>).</li><li>If <var>opText</var> is <code>&gt;&gt;&gt;</code>, return ? <emu-xref aoid=\"BigInt::unsignedRightShift\"><a href=\"#sec-numeric-types-bigint-unsignedRightShift\">BigInt::unsignedRightShift</a></emu-xref>(<var>lnum</var>, <var>rnum</var>).</li></ol></li><li>Let <var>operation</var> be the abstract operation associated with <var>opText</var> and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) in the following table:\n          <figure>\n            <table class=\"lightweight-table\">\n              <tbody>\n                <tr><th> <var>opText</var>       </th><th> <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) </th><th> <var>operation</var>                </th></tr>\n                <tr><td> <code>**</code>           </td><td> Number       </td><td> <emu-xref aoid=\"Number::exponentiate\"><a href=\"#sec-numeric-types-number-exponentiate\">Number::exponentiate</a></emu-xref>       </td></tr>\n                <tr><td> <code>*</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::multiply\"><a href=\"#sec-numeric-types-number-multiply\">Number::multiply</a></emu-xref>           </td></tr>\n                <tr><td> <code>*</code>            </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::multiply\"><a href=\"#sec-numeric-types-bigint-multiply\">BigInt::multiply</a></emu-xref>           </td></tr>\n                <tr><td> <code>/</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::divide\"><a href=\"#sec-numeric-types-number-divide\">Number::divide</a></emu-xref>             </td></tr>\n                <tr><td> <code>%</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::remainder\"><a href=\"#sec-numeric-types-number-remainder\">Number::remainder</a></emu-xref>          </td></tr>\n                <tr><td> <code>+</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>                </td></tr>\n                <tr><td> <code>+</code>            </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::add\"><a href=\"#sec-numeric-types-bigint-add\">BigInt::add</a></emu-xref>                </td></tr>\n                <tr><td> <code>-</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::subtract\"><a href=\"#sec-numeric-types-number-subtract\">Number::subtract</a></emu-xref>           </td></tr>\n                <tr><td> <code>-</code>            </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::subtract\"><a href=\"#sec-numeric-types-bigint-subtract\">BigInt::subtract</a></emu-xref>           </td></tr>\n                <tr><td> <code>&lt;&lt;</code>     </td><td> Number       </td><td> <emu-xref aoid=\"Number::leftShift\"><a href=\"#sec-numeric-types-number-leftShift\">Number::leftShift</a></emu-xref>          </td></tr>\n                <tr><td> <code>&lt;&lt;</code>     </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::leftShift\"><a href=\"#sec-numeric-types-bigint-leftShift\">BigInt::leftShift</a></emu-xref>          </td></tr>\n                <tr><td> <code>&gt;&gt;</code>     </td><td> Number       </td><td> <emu-xref aoid=\"Number::signedRightShift\"><a href=\"#sec-numeric-types-number-signedRightShift\">Number::signedRightShift</a></emu-xref>   </td></tr>\n                <tr><td> <code>&gt;&gt;</code>     </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::signedRightShift\"><a href=\"#sec-numeric-types-bigint-signedRightShift\">BigInt::signedRightShift</a></emu-xref>   </td></tr>\n                <tr><td> <code>&gt;&gt;&gt;</code> </td><td> Number       </td><td> <emu-xref aoid=\"Number::unsignedRightShift\"><a href=\"#sec-numeric-types-number-unsignedRightShift\">Number::unsignedRightShift</a></emu-xref> </td></tr>\n                <tr><td> <code>&amp;</code>        </td><td> Number       </td><td> <emu-xref aoid=\"Number::bitwiseAND\"><a href=\"#sec-numeric-types-number-bitwiseAND\">Number::bitwiseAND</a></emu-xref>         </td></tr>\n                <tr><td> <code>&amp;</code>        </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::bitwiseAND\"><a href=\"#sec-numeric-types-bigint-bitwiseAND\">BigInt::bitwiseAND</a></emu-xref>         </td></tr>\n                <tr><td> <code>^</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::bitwiseXOR\"><a href=\"#sec-numeric-types-number-bitwiseXOR\">Number::bitwiseXOR</a></emu-xref>         </td></tr>\n                <tr><td> <code>^</code>            </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::bitwiseXOR\"><a href=\"#sec-numeric-types-bigint-bitwiseXOR\">BigInt::bitwiseXOR</a></emu-xref>         </td></tr>\n                <tr><td> <code>|</code>            </td><td> Number       </td><td> <emu-xref aoid=\"Number::bitwiseOR\"><a href=\"#sec-numeric-types-number-bitwiseOR\">Number::bitwiseOR</a></emu-xref>          </td></tr>\n                <tr><td> <code>|</code>            </td><td> BigInt       </td><td> <emu-xref aoid=\"BigInt::bitwiseOR\"><a href=\"#sec-numeric-types-bigint-bitwiseOR\">BigInt::bitwiseOR</a></emu-xref>          </td></tr>\n              </tbody>\n            </table>\n          </figure></li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>operation</var>(<var>lnum</var>, <var>rnum</var>)).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>No hint is provided in the calls to <emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref> in steps <emu-xref href=\"#step-binary-op-toprimitive-lval\"><a href=\"#step-binary-op-toprimitive-lval\">1.a</a></emu-xref> and <emu-xref href=\"#step-binary-op-toprimitive-rval\"><a href=\"#step-binary-op-toprimitive-rval\">1.b</a></emu-xref>. All standard objects except Dates handle the absence of a hint as if <emu-const>number</emu-const> were given; Dates handle the absence of a hint as if <emu-const>string</emu-const> were given. <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">Exotic objects</a></emu-xref> may handle the absence of a hint in some other manner.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">1.c</a></emu-xref> differs from step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> of the <emu-xref aoid=\"IsLessThan\"><a href=\"#sec-islessthan\">IsLessThan</a></emu-xref> algorithm, by using the logical-or operation instead of the logical-and operation.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-isunresolvablereference": {"num": "6.2.4.2", "title": "#sec-isunresolvablereference IsUnresolvableReference ( V )", "html": "<emu-clause id=\"sec-isunresolvablereference\" type=\"abstract operation\" oldids=\"ao-isunresolvablereference\" aoid=\"IsUnresolvableReference\"><span id=\"ao-isunresolvablereference\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isunresolvablereference\">#sec-isunresolvablereference</span> IsUnresolvableReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsUnresolvableReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[Base]] is <emu-const>unresolvable</emu-const>, return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numeric-types-number-sameValueZero": {"num": "6.1.6.1.15", "title": "#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValueZero\" type=\"numeric method\" aoid=\"Number::sameValueZero\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValueZero\">#sec-numeric-types-number-sameValueZero</span> Number::sameValueZero ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::sameValueZero takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-toprimitive": {"num": "7.1.1", "title": "#sec-toprimitive ToPrimitive ( input [ , preferredType ] )", "html": "<emu-clause id=\"sec-toprimitive\" type=\"abstract operation\" oldids=\"table-9\" aoid=\"ToPrimitive\"><span id=\"table-9\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-toprimitive\">#sec-toprimitive</span> ToPrimitive ( <var>input</var> [ , <var>preferredType</var> ] )</h1>\n      <p>The abstract operation ToPrimitive takes argument <var>input</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and optional argument <var>preferredType</var> (<emu-const>string</emu-const> or <emu-const>number</emu-const>) and returns a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> normally containing an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>. It converts its <var>input</var> argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint <var>preferredType</var> to favour that type. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>input</var>) is Object, then<ol><li>Let <var>exoticToPrim</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>input</var>, <emu-xref href=\"#sec-well-known-symbols\"><a href=\"#sec-well-known-symbols\">@@toPrimitive</a></emu-xref>).</li><li>If <var>exoticToPrim</var> is not <emu-val>undefined</emu-val>, then<ol><li>If <var>preferredType</var> is not present, let <var>hint</var> be <emu-val>\"default\"</emu-val>.</li><li>Else if <var>preferredType</var> is <emu-const>string</emu-const>, let <var>hint</var> be <emu-val>\"string\"</emu-val>.</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>preferredType</var> is <emu-const>number</emu-const>.</li><li>Let <var>hint</var> be <emu-val>\"number\"</emu-val>.</li></ol></li><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>exoticToPrim</var>, <var>input</var>, &#171; <var>hint</var> &#187;).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>result</var>) is not Object, return <var>result</var>.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>If <var>preferredType</var> is not present, let <var>preferredType</var> be <emu-const>number</emu-const>.</li><li>Return ?&#160;<emu-xref aoid=\"OrdinaryToPrimitive\"><a href=\"#sec-ordinarytoprimitive\">OrdinaryToPrimitive</a></emu-xref>(<var>input</var>, <var>preferredType</var>).</li></ol></li><li>Return <var>input</var>.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>When ToPrimitive is called without a hint, then it generally behaves as if the hint were <emu-const>number</emu-const>. However, objects may over-ride this behaviour by defining a <emu-xref href=\"#sec-well-known-symbols\"><a href=\"#sec-well-known-symbols\">@@toPrimitive</a></emu-xref> method. Of the objects defined in this specification only Dates (see <emu-xref href=\"#sec-date.prototype-@@toprimitive\"><a href=\"#sec-date.prototype-@@toprimitive\" class=\"excluded-xref\" excluded-id=\"sec-date.prototype-@@toprimitive\">#sec-date.prototype-@@toprimitive</a></emu-xref>) and Symbol objects (see <emu-xref href=\"#sec-symbol.prototype-@@toprimitive\"><a href=\"#sec-symbol.prototype-@@toprimitive\" class=\"excluded-xref\" excluded-id=\"sec-symbol.prototype-@@toprimitive\">#sec-symbol.prototype-@@toprimitive</a></emu-xref>) over-ride the default ToPrimitive behaviour. Dates treat the absence of a hint as if the hint were <emu-const>string</emu-const>.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-ordinarytoprimitive\"><h1><span class=\"secnum\">7.1.1.1</span>#sec-ordinarytoprimitive OrdinaryToPrimitive ( O, hint )</h1>...</div></emu-clause>\n\n    "}, "sec-binaryand": {"num": "6.1.6.2.16", "title": "#sec-binaryand BinaryAnd ( x, y )", "html": "<emu-clause id=\"sec-binaryand\" type=\"abstract operation\" aoid=\"BinaryAnd\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-binaryand\">#sec-binaryand</span> BinaryAnd ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BinaryAnd takes arguments <var>x</var> (0 or 1) and <var>y</var> (0 or 1) and returns 0 or 1. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is 1 and <var>y</var> is 1, return 1.</li><li>Else, return 0.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-leftShift": {"num": "6.1.6.1.9", "title": "#sec-numeric-types-number-leftShift Number::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-leftShift\" type=\"numeric method\" aoid=\"Number::leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-leftShift\">#sec-numeric-types-number-leftShift</span> Number::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::leftShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of left shifting <var>lnum</var> by <var>shiftCount</var> bits. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-unaryMinus": {"num": "6.1.6.1.1", "title": "#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-unaryMinus\" type=\"numeric method\" aoid=\"Number::unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unaryMinus\">#sec-numeric-types-number-unaryMinus</span> Number::unaryMinus ( <var>x</var> )</h1>\n          <p>The abstract operation Number::unaryMinus takes argument <var>x</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>Return the result of negating <var>x</var>; that is, compute a Number with the same magnitude but opposite sign.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-atomics.add": {"num": "25.4.3", "title": "#sec-atomics.add Atomics.add ( typedArray, index, value )", "html": "<emu-clause id=\"sec-atomics.add\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atomics.add\">#sec-atomics.add</span> Atomics.add ( <var>typedArray</var>, <var>index</var>, <var>value</var> )</h1>\n      <p>The following steps are taken:</p>\n      <emu-alg><ol><li>Let <var>type</var> be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>add</var> be a new <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> with parameters (<var>xBytes</var>, <var>yBytes</var>) that captures <var>type</var> and <var>isLittleEndian</var> and performs the following steps atomically when called:<ol><li>Let <var>x</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>xBytes</var>, <var>isLittleEndian</var>).</li><li>Let <var>y</var> be <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>yBytes</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>Let <var>sum</var> be <emu-xref aoid=\"Number::add\"><a href=\"#sec-numeric-types-number-add\">Number::add</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is BigInt.</li><li>Let <var>sum</var> be <emu-xref aoid=\"BigInt::add\"><a href=\"#sec-numeric-types-bigint-add\">BigInt::add</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Let <var>sumBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>sum</var>, <var>isLittleEndian</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>sumBytes</var>, <var>xBytes</var>, and <var>yBytes</var> have the same number of elements.</li><li>Return <var>sumBytes</var>.</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"AtomicReadModifyWrite\"><a href=\"#sec-atomicreadmodifywrite\">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <var>add</var>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}, "sec-numeric-types-number-divide": {"num": "6.1.6.1.5", "title": "#sec-numeric-types-number-divide Number::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-divide\" type=\"numeric method\" oldids=\"sec-applying-the-div-operator\" aoid=\"Number::divide\"><span id=\"sec-applying-the-div-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-divide\">#sec-numeric-types-number-divide</span> Number::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::divide takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs division according to the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic, producing the quotient of <var>x</var> and <var>y</var> where <var>x</var> is the dividend and <var>y</var> is the divisor. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> or <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>y</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>Return -<var>x</var>.</li></ol></li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>-0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>y</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>y</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <var>x</var>.</li><li>Return -<var>x</var>.</li></ol></li><li>If <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>x</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) / <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>)).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-asyncgeneratordrainqueue": {"num": "27.6.3.10", "title": "#sec-asyncgeneratordrainqueue AsyncGeneratorDrainQueue ( generator )", "html": "<emu-clause id=\"sec-asyncgeneratordrainqueue\" type=\"abstract operation\" aoid=\"AsyncGeneratorDrainQueue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratordrainqueue\">#sec-asyncgeneratordrainqueue</span> AsyncGeneratorDrainQueue ( <var>generator</var> )</h1>\n        <p>The abstract operation AsyncGeneratorDrainQueue takes argument <var>generator</var> (an AsyncGenerator) and returns <emu-const>unused</emu-const>. It drains the generator's AsyncGeneratorQueue until it encounters an <emu-xref href=\"#sec-asyncgeneratorrequest-records\"><a href=\"#sec-asyncgeneratorrequest-records\">AsyncGeneratorRequest</a></emu-xref> which holds a completion whose type is <emu-const>return</emu-const>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var>.[[AsyncGeneratorState]] is <emu-const>completed</emu-const>.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li>If <var>queue</var> is empty, return <emu-const>unused</emu-const>.</li><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>next</var> be the first element of <var>queue</var>.</li><li>Let <var>completion</var> be <var>next</var>.[[Completion]].</li><li>If <var>completion</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>awaiting-return</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorAwaitReturn\"><a href=\"#sec-asyncgeneratorawaitreturn\">AsyncGeneratorAwaitReturn</a></emu-xref>(<var>generator</var>).</li><li>Set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li><li>Else,<ol><li>If <var>completion</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Set <var>completion</var> to <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorCompleteStep\"><a href=\"#sec-asyncgeneratorcompletestep\">AsyncGeneratorCompleteStep</a></emu-xref>(<var>generator</var>, <var>completion</var>, <emu-val>true</emu-val>).</li><li>If <var>queue</var> is empty, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <emu-const>unused</emu-const>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-postfix-decrement-operator-runtime-semantics-evaluation": {"num": "13.4.3.1", "title": "#sec-postfix-decrement-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-postfix-decrement-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-postfix-decrement-operator-runtime-semantics-evaluation\">#sec-postfix-decrement-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UpdateExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UpdateExpression\">UpdateExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"jr0tcoqg\">\n        <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>\n        <emu-t>--</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>lhs</var> be the result of evaluating <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>lhs</var>)).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is Number, then<ol><li>Let <var>newValue</var> be ! <emu-xref aoid=\"Number::subtract\"><a href=\"#sec-numeric-types-number-subtract\">Number::subtract</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#120125;</sub>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is BigInt.</li><li>Let <var>newValue</var> be ! <emu-xref aoid=\"BigInt::subtract\"><a href=\"#sec-numeric-types-bigint-subtract\">BigInt::subtract</a></emu-xref>(<var>oldValue</var>, <emu-val>1</emu-val><sub>&#8484;</sub>).</li></ol></li><li>Perform ?&#160;<emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhs</var>, <var>newValue</var>).</li><li>Return <var>oldValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-bitwiseNOT": {"num": "6.1.6.2.2", "title": "#sec-numeric-types-bigint-bitwiseNOT BigInt::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseNOT\" type=\"numeric method\" aoid=\"BigInt::bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseNOT\">#sec-numeric-types-bigint-bitwiseNOT</span> BigInt::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseNOT takes argument <var>x</var> (a BigInt) and returns a BigInt. It returns the one's complement of <var>x</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return -<var>x</var> - <emu-val>1</emu-val><sub>&#8484;</sub>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-remainder": {"num": "6.1.6.1.6", "title": "#sec-numeric-types-number-remainder Number::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-number-remainder\" type=\"numeric method\" oldids=\"sec-applying-the-mod-operator\" aoid=\"Number::remainder\"><span id=\"sec-applying-the-mod-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-remainder\">#sec-numeric-types-number-remainder</span> Number::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The abstract operation Number::remainder takes arguments <var>n</var> (a Number) and <var>d</var> (a Number) and returns a Number. It yields the remainder from an implied division of its operands where <var>n</var> is the dividend and <var>d</var> is the divisor. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>n</var> is <emu-val>NaN</emu-val> or <var>d</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>n</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>n</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>d</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>d</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <var>n</var>.</li><li>If <var>d</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>d</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>NaN</emu-val>.</li><li>If <var>n</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>n</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <var>n</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>n</var> and <var>d</var> are finite and non-zero.</li><li>Let <var>r</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>n</var>) - (<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>d</var>) &#215; <var>q</var>) where <var>q</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is negative if and only if <var>n</var> and <var>d</var> have opposite sign, and whose magnitude is as large as possible without exceeding the magnitude of <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>n</var>) / <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>d</var>).</li><li>Return <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>r</var>).</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">The result of a floating-point remainder operation as computed by the <code>%</code> operator is not the same as the &#8220;remainder&#8221; operation defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> &#8220;remainder&#8221; operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual <emu-not-ref>integer</emu-not-ref> remainder operator. Instead the ECMAScript language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the Java <emu-not-ref>integer</emu-not-ref> remainder operator; this may be compared with the C library function fmod.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-signedRightShift": {"num": "6.1.6.1.10", "title": "#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-signedRightShift\" type=\"numeric method\" aoid=\"Number::signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-signedRightShift\">#sec-numeric-types-number-signedRightShift</span> Number::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::signedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>rnum</var>) <emu-xref aoid=\"modulo\"><a href=\"#eqn-modulo\">modulo</a></emu-xref> 32.</li><li>Return the result of performing a sign-extending right shift of <var>lnum</var> by <var>shiftCount</var> bits. The most significant bit is propagated. The <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of the result is exactly representable as a 32-bit two's complement bit string.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-isprivatereference": {"num": "6.2.4.4", "title": "#sec-isprivatereference IsPrivateReference ( V )", "html": "<emu-clause id=\"sec-isprivatereference\" type=\"abstract operation\" aoid=\"IsPrivateReference\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isprivatereference\">#sec-isprivatereference</span> IsPrivateReference ( <var>V</var> )</h1>\n        <p>The abstract operation IsPrivateReference takes argument <var>V</var> (a <emu-xref href=\"#sec-reference-record-specification-type\"><a href=\"#sec-reference-record-specification-type\">Reference Record</a></emu-xref>) and returns a Boolean. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>V</var>.[[ReferencedName]] is a <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref>, return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-samevaluezero": {"num": "7.2.11", "title": "#sec-samevaluezero SameValueZero ( x, y )", "html": "<emu-clause id=\"sec-samevaluezero\" type=\"abstract operation\" aoid=\"SameValueZero\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-samevaluezero\">#sec-samevaluezero</span> SameValueZero ( <var>x</var>, <var>y</var> )</h1>\n      <p>The abstract operation SameValueZero takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>) and <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It returns a completion record whose [[Type]] is <emu-const>normal</emu-const> and whose [[Value]] is a Boolean indicating whether or not the two arguments are the same value (ignoring the difference between <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub>). It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>), return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is Number, then<ol><li>Return ! <emu-xref aoid=\"Number::sameValueZero\"><a href=\"#sec-numeric-types-number-sameValueZero\">Number::sameValueZero</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) is BigInt, then<ol><li>Return ! <emu-xref aoid=\"BigInt::sameValueZero\"><a href=\"#sec-numeric-types-bigint-sameValueZero\">BigInt::sameValueZero</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></li><li>Return !&#160;<emu-xref aoid=\"SameValueNonNumeric\"><a href=\"#sec-samevaluenonnumeric\">SameValueNonNumeric</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>SameValueZero differs from <emu-xref aoid=\"SameValue\"><a href=\"#sec-samevalue\">SameValue</a></emu-xref> only in that it treats <emu-val>+0</emu-val><sub>&#120125;</sub> and <emu-val>-0</emu-val><sub>&#120125;</sub> as equivalent.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-numeric-types-number-exponentiate": {"num": "6.1.6.1.3", "title": "#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-number-exponentiate\" type=\"numeric method\" oldids=\"sec-applying-the-exp-operator\" aoid=\"Number::exponentiate\"><span id=\"sec-applying-the-exp-operator\"></span>\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-exponentiate\">#sec-numeric-types-number-exponentiate</span> Number::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>The abstract operation Number::exponentiate takes arguments <var>base</var> (a Number) and <var>exponent</var> (a Number) and returns a Number. It returns an <emu-xref href=\"#implementation-approximated\"><a href=\"#implementation-approximated\">implementation-approximated</a></emu-xref> value representing the result of raising <var>base</var> to the <var>exponent</var> power. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>exponent</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>exponent</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> or <var>exponent</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>base</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>If <var>base</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>base</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Else,<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li></ol></li><li>If <var>base</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>+0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>base</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> &gt; <emu-val>+0</emu-val><sub>&#120125;</sub>, then<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-0</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Else,<ol><li>If <var>exponent</var> is an odd <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>. Otherwise, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>base</var> is finite and is neither <emu-val>+0</emu-val><sub>&#120125;</sub> nor <emu-val>-0</emu-val><sub>&#120125;</sub>.</li><li>If <var>exponent</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &gt; 1, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) is 1, return <emu-val>NaN</emu-val>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &lt; 1, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>If <var>exponent</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, then<ol><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &gt; 1, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) is 1, return <emu-val>NaN</emu-val>.</li><li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>)) &lt; 1, return <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>exponent</var> is finite and is neither <emu-val>+0</emu-val><sub>&#120125;</sub> nor <emu-val>-0</emu-val><sub>&#120125;</sub>.</li><li>If <var>base</var> &lt; <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>exponent</var> is not an <emu-xref href=\"#integral-number\"><a href=\"#integral-number\">integral Number</a></emu-xref>, return <emu-val>NaN</emu-val>.</li><li>Return an <emu-xref href=\"#implementation-approximated\"><a href=\"#implementation-approximated\">implementation-approximated</a></emu-xref> <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> representing the result of raising <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>base</var>) to the <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>exponent</var>) power.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>The result of <var>base</var> <code>**</code> <var>exponent</var> when <var>base</var> is <emu-val>1</emu-val><sub>&#120125;</sub> or <emu-val>-1</emu-val><sub>&#120125;</sub> and <var>exponent</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, or when <var>base</var> is <emu-val>1</emu-val><sub>&#120125;</sub> and <var>exponent</var> is <emu-val>NaN</emu-val>, differs from <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The first edition of ECMAScript specified a result of <emu-val>NaN</emu-val> for this operation, whereas later versions of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> specified <emu-val>1</emu-val><sub>&#120125;</sub>. The historical ECMAScript behaviour is preserved for compatibility reasons.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-unary-minus-operator-runtime-semantics-evaluation": {"num": "13.5.5.1", "title": "#sec-unary-minus-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-unary-minus-operator-runtime-semantics-evaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-unary-minus-operator-runtime-semantics-evaluation\">#sec-unary-minus-operator-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n        <emu-grammar><emu-production name=\"UnaryExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"odzkxnu5\">\n        <emu-t>-</emu-t>\n        <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>expr</var> be the result of evaluating <emu-nt><a href=\"#prod-UnaryExpression\">UnaryExpression</a></emu-nt>.</li><li>Let <var>oldValue</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(? <emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>expr</var>)).</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is Number, then<ol><li>Return ! <emu-xref aoid=\"Number::unaryMinus\"><a href=\"#sec-numeric-types-number-unaryMinus\">Number::unaryMinus</a></emu-xref>(<var>oldValue</var>).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>oldValue</var>) is BigInt.</li><li>Return ! <emu-xref aoid=\"BigInt::unaryMinus\"><a href=\"#sec-numeric-types-bigint-unaryMinus\">BigInt::unaryMinus</a></emu-xref>(<var>oldValue</var>).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-numeric-types-bigint-sameValue": {"num": "6.1.6.2.14", "title": "#sec-numeric-types-bigint-sameValue BigInt::sameValue ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-sameValue\" type=\"numeric method\" aoid=\"BigInt::sameValue\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-sameValue\">#sec-numeric-types-bigint-sameValue</span> BigInt::sameValue ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::sameValue takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigInt::equal\"><a href=\"#sec-numeric-types-bigint-equal\">BigInt::equal</a></emu-xref>(<var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseXOR": {"num": "6.1.6.1.18", "title": "#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseXOR\" type=\"numeric method\" aoid=\"Number::bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseXOR\">#sec-numeric-types-number-bitwiseXOR</span> Number::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseXOR takes arguments <var>x</var> (a Number) and <var>y</var> (a Number) and returns a Number. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseOR": {"num": "6.1.6.2.22", "title": "#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseOR\" type=\"numeric method\" aoid=\"BigInt::bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseOR\">#sec-numeric-types-bigint-bitwiseOR</span> BigInt::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a BigInt. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-tostring": {"num": "6.1.6.2.23", "title": "#sec-numeric-types-bigint-tostring BigInt::toString ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-tostring\" type=\"numeric method\" aoid=\"BigInt::toString\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-tostring\">#sec-numeric-types-bigint-tostring</span> BigInt::toString ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::toString takes argument <var>x</var> (a BigInt) and returns a String. It converts <var>x</var> to String format. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> &lt; <emu-val>0</emu-val><sub>&#8484;</sub>, return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of the String <emu-val>\"-\"</emu-val> and ! <emu-xref aoid=\"BigInt::toString\"><a href=\"#sec-numeric-types-bigint-tostring\">BigInt::toString</a></emu-xref>(-<var>x</var>).</li><li>Return the String value consisting of the code units of the digits of the decimal representation of <var>x</var>.</li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-numeric-types-bigint-equal": {"num": "6.1.6.2.13", "title": "#sec-numeric-types-bigint-equal BigInt::equal ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-equal\" type=\"numeric method\" aoid=\"BigInt::equal\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-equal\">#sec-numeric-types-bigint-equal</span> BigInt::equal ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::equal takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt) and returns a Boolean. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>x</var>) = <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>y</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {"table-numeric-type-ops": "Table 2", "table-completion-record-fields": "Table 9", "table-the-typedarray-constructors": "Table 72"}}}