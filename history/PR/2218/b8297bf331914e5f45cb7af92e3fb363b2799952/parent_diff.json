{"from": {"secList": ["sec-generator-function-definitions-runtime-semantics-evaluation", "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset", "sec-makebasicobject", "sec-newpromiseresolvethenablejob", "sec-finishdynamicimport", "sec-function.prototype.tostring", "sec-newpromisereactionjob"], "secData": {"sec-generator-function-definitions-runtime-semantics-evaluation": {"num": "14.4.14", "title": "#sec-generator-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">#sec-generator-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"0d271960\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.</li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"7dbc99b6\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform <var>funcEnv</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>sourceText</var> be the source text matched by <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</li><li>Let <var>closure</var> be <emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-generatorfunction-prototype-object\"><a href=\"#sec-properties-of-the-generatorfunction-prototype-object\">%GeneratorFunction.prototype%</a></emu-xref>, <var>sourceText</var>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Let <var>prototype</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-generator-prototype\"><a href=\"#sec-properties-of-generator-prototype\">%GeneratorFunction.prototype.prototype%</a></emu-xref>).</li><li>Perform <emu-xref aoid=\"DefinePropertyOrThrow\"><a href=\"#sec-definepropertyorthrow\">DefinePropertyOrThrow</a></emu-xref>(<var>closure</var>, <emu-val>\"prototype\"</emu-val>, PropertyDescriptor { [[Value]]: <var>prototype</var>, [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }).</li><li>Perform <var>funcEnv</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Return <var>closure</var>.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt> to allow the generator code to call itself recursively. However, unlike in a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d1df3360\"><emu-t>yield</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<emu-val>undefined</emu-val>, <emu-val>false</emu-val>)).</li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e741ede8\"><emu-t>yield</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<var>value</var>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <emu-val>false</emu-val>)).</li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"47a33813\"><emu-t>yield</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>, <var>generatorKind</var>).</li><li>Let <var>iterator</var> be <var>iteratorRecord</var>.[[Iterator]].</li><li>Let <var>received</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Repeat,<ol><li>If <var>received</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>iteratorRecord</var>.[[NextMethod]], <var>iteratorRecord</var>.[[Iterator]], &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else if <var>received</var>.[[Type]] is <emu-const>throw</emu-const>, then<ol><li>Let <var>throw</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"throw\"</emu-val>).</li><li>If <var>throw</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>throw</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>NOTE: Exceptions from the inner iterator <code>throw</code> method are propagated. Normal completions from an inner <code>throw</code> method are processed similarly to an inner <code>next</code>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else,<ol><li>NOTE: If <var>iterator</var> does not have a <code>throw</code> method, this throw is going to terminate the <code>yield*</code> loop. But first we need to give <var>iterator</var> a chance to clean up.</li><li>Let <var>closeCompletion</var> be <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>normal</emu-const>, [[Value]]: <emu-const>empty</emu-const>, [[Target]]: <emu-const>empty</emu-const> }.</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, perform ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>Else, perform ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>NOTE: The next step throws a <emu-val>TypeError</emu-val> to indicate that there was a <code>yield*</code> protocol violation: <var>iterator</var> does not have a <code>throw</code> method.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>received</var>.[[Type]] is <emu-const>return</emu-const>.</li><li>Let <var>return</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"return\"</emu-val>).</li><li>If <var>return</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var>.[[Value]] to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>received</var>.[[Value]]).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>received</var>).</li></ol></li><li>Let <var>innerReturnResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>return</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>innerReturnResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerReturnResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>return</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, then set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerReturnResult</var>).</li></ol></li></ol></li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset": {"num": "13.7.5.13", "title": "#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] )", "html": "<emu-clause id=\"sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset\" aoid=\"ForIn/OfBodyEvaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset\">#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset</span> ForIn/OfBodyEvaluation ( <var>lhs</var>, <var>stmt</var>, <var>iteratorRecord</var>, <var>iterationKind</var>, <var>lhsKind</var>, <var>labelSet</var> [ , <var>iteratorKind</var> ] )</h1>\n        <p>The abstract operation ForIn/OfBodyEvaluation takes arguments <var>lhs</var>, <var>stmt</var>, <var>iteratorRecord</var>, <var>iterationKind</var>, <var>lhsKind</var> (either <emu-const>assignment</emu-const>, <emu-const>varBinding</emu-const> or <emu-const>lexicalBinding</emu-const>), and <var>labelSet</var> and optional argument <var>iteratorKind</var> (either <emu-const>sync</emu-const> or <emu-const>async</emu-const>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>iteratorKind</var> is not present, set <var>iteratorKind</var> to <emu-const>sync</emu-const>.</li><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>V</var> be <emu-val>undefined</emu-val>.</li><li>Let <var>destructuring</var> be IsDestructuring of <var>lhs</var>.</li><li>If <var>destructuring</var> is <emu-val>true</emu-val> and if <var>lhsKind</var> is <emu-const>assignment</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>.</li><li>Let <var>assignmentPattern</var> be the <emu-nt><a href=\"#prod-AssignmentPattern\">AssignmentPattern</a></emu-nt> that is <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">covered</a></emu-xref> by <var>lhs</var>.</li></ol></li><li>Repeat,<ol><li>Let <var>nextResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>iteratorRecord</var>.[[NextMethod]], <var>iteratorRecord</var>.[[Iterator]]).</li><li>If <var>iteratorKind</var> is <emu-const>async</emu-const>, then set <var>nextResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>nextResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nextResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>nextResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>V</var>).</li><li>Let <var>nextValue</var> be ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>nextResult</var>).</li><li>If <var>lhsKind</var> is either <emu-const>assignment</emu-const> or <emu-const>varBinding</emu-const>, then<ol><li>If <var>destructuring</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>lhsRef</var> be the result of evaluating <var>lhs</var>. (It may be evaluated repeatedly.)</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhsKind</var> is <emu-const>lexicalBinding</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-ForDeclaration\">ForDeclaration</a></emu-nt>.</li><li>Let <var>iterationEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>Perform BindingInstantiation for <var>lhs</var> passing <var>iterationEnv</var> as the argument.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>iterationEnv</var>.</li><li>If <var>destructuring</var> is <emu-val>false</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> binds a single name.</li><li>Let <var>lhsName</var> be the sole element of BoundNames of <var>lhs</var>.</li><li>Let <var>lhsRef</var> be !&#160;<emu-xref aoid=\"ResolveBinding\"><a href=\"#sec-resolvebinding\">ResolveBinding</a></emu-xref>(<var>lhsName</var>).</li></ol></li></ol></li><li>If <var>destructuring</var> is <emu-val>false</emu-val>, then<ol><li>If <var>lhsRef</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <var>lhsRef</var>.</li></ol></li><li>Else if <var>lhsKind</var> is <emu-const>lexicalBinding</emu-const>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"InitializeReferencedBinding\"><a href=\"#sec-initializereferencedbinding\">InitializeReferencedBinding</a></emu-xref>(<var>lhsRef</var>, <var>nextValue</var>).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhsRef</var>, <var>nextValue</var>).</li></ol></li></ol></li><li>Else,<ol><li>If <var>lhsKind</var> is <emu-const>assignment</emu-const>, then<ol><li>Let <var>status</var> be DestructuringAssignmentEvaluation of <var>assignmentPattern</var> with argument <var>nextValue</var>.</li></ol></li><li>Else if <var>lhsKind</var> is <emu-const>varBinding</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>.</li><li>Let <var>status</var> be BindingInitialization of <var>lhs</var> with arguments <var>nextValue</var> and <emu-val>undefined</emu-val>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhsKind</var> is <emu-const>lexicalBinding</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-ForDeclaration\">ForDeclaration</a></emu-nt>.</li><li>Let <var>status</var> be BindingInitialization of <var>lhs</var> with arguments <var>nextValue</var> and <var>iterationEnv</var>.</li></ol></li></ol></li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>If <var>iteratorKind</var> is <emu-const>async</emu-const>, return ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>If <var>iterationKind</var> is <emu-const>enumerate</emu-const>, then<ol><li>Return <var>status</var>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iterationKind</var> is <emu-const>iterate</emu-const>.</li><li>Return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li></ol></li></ol></li><li>Let <var>result</var> be the result of evaluating <var>stmt</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>If <emu-xref aoid=\"LoopContinues\"><a href=\"#sec-loopcontinues\">LoopContinues</a></emu-xref>(<var>result</var>, <var>labelSet</var>) is <emu-val>false</emu-val>, then<ol><li>If <var>iterationKind</var> is <emu-const>enumerate</emu-const>, then<ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<emu-xref aoid=\"UpdateEmpty\"><a href=\"#sec-updateempty\">UpdateEmpty</a></emu-xref>(<var>result</var>, <var>V</var>)).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iterationKind</var> is <emu-const>iterate</emu-const>.</li><li>Set <var>status</var> to <emu-xref aoid=\"UpdateEmpty\"><a href=\"#sec-updateempty\">UpdateEmpty</a></emu-xref>(<var>result</var>, <var>V</var>).</li><li>If <var>iteratorKind</var> is <emu-const>async</emu-const>, return ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>Return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li></ol></li></ol></li><li>If <var>result</var>.[[Value]] is not <emu-const>empty</emu-const>, set <var>V</var> to <var>result</var>.[[Value]].</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-makebasicobject": {"num": "7.3.1", "title": "#sec-makebasicobject MakeBasicObject ( internalSlotsList )", "html": "<emu-clause id=\"sec-makebasicobject\" aoid=\"MakeBasicObject\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-makebasicobject\">#sec-makebasicobject</span> MakeBasicObject ( <var>internalSlotsList</var> )</h1>\n      <p>The abstract operation MakeBasicObject takes argument <var>internalSlotsList</var>. It is the source of all ECMAScript objects that are created algorithmically, including both ordinary objects and exotic objects. It factors out common steps used in creating all objects, and centralizes object creation. It performs the following steps when called:</p>\n\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>internalSlotsList</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of internal slot names.</li><li>Let <var>obj</var> be a newly created object with an internal slot for each name in <var>internalSlotsList</var>.</li><li>Set <var>obj</var>'s essential internal methods to the default <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"><a href=\"#sec-ordinary-object-internal-methods-and-internal-slots\" class=\"excluded-xref\" excluded-id=\"sec-ordinary-object-internal-methods-and-internal-slots\">#sec-ordinary-object-internal-methods-and-internal-slots</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If the caller will not be overriding both <var>obj</var>'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then <var>internalSlotsList</var> contains [[Prototype]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If the caller will not be overriding all of <var>obj</var>'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then <var>internalSlotsList</var> contains [[Extensible]].</li><li>If <var>internalSlotsList</var> contains [[Extensible]], then set <var>obj</var>.[[Extensible]] to <emu-val>true</emu-val>.</li><li>Return <var>obj</var>.</li></ol></emu-alg>\n\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>Within this specification, exotic objects are created in <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> such as <emu-xref aoid=\"ArrayCreate\"><a href=\"#sec-arraycreate\">ArrayCreate</a></emu-xref> and <emu-xref aoid=\"BoundFunctionCreate\"><a href=\"#sec-boundfunctioncreate\">BoundFunctionCreate</a></emu-xref> by first calling MakeBasicObject to obtain a basic, foundational object, and then overriding some or all of that object's internal methods. In order to encapsulate <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">exotic object</a></emu-xref> creation, the object's essential internal methods are never modified outside those operations.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-newpromiseresolvethenablejob": {"num": "26.6.2.2", "title": "#sec-newpromiseresolvethenablejob NewPromiseResolveThenableJob ( promiseToResolve, thenable, then )", "html": "<emu-clause id=\"sec-newpromiseresolvethenablejob\" aoid=\"NewPromiseResolveThenableJob\" oldids=\"sec-promiseresolvethenablejob\"><span id=\"sec-promiseresolvethenablejob\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromiseresolvethenablejob\">#sec-newpromiseresolvethenablejob</span> NewPromiseResolveThenableJob ( <var>promiseToResolve</var>, <var>thenable</var>, <var>then</var> )</h1>\n        <p>The abstract operation NewPromiseResolveThenableJob takes arguments <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var> and performs the following steps when called:<ol><li>Let <var>resolvingFunctions</var> be <emu-xref aoid=\"CreateResolvingFunctions\"><a href=\"#sec-createresolvingfunctions\">CreateResolvingFunctions</a></emu-xref>(<var>promiseToResolve</var>).</li><li>Let <var>thenCallResult</var> be <emu-xref aoid=\"HostCallJobCallback\"><a href=\"#sec-hostcalljobcallback\">HostCallJobCallback</a></emu-xref>(<var>then</var>, <var>thenable</var>, &#171; <var>resolvingFunctions</var>.[[Resolve]], <var>resolvingFunctions</var>.[[Reject]] &#187;).</li><li>If <var>thenCallResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resolvingFunctions</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>thenCallResult</var>.[[Value]] &#187;).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>thenCallResult</var>).</li></ol></li><li>Let <var>getThenRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>then</var>.[[Callback]]).</li><li>If <var>getThenRealmResult</var> is a normal completion, then let <var>thenRealm</var> be <var>getThenRealmResult</var>.[[Value]].</li><li>Else, let <var>thenRealm</var> be <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>.</li><li>NOTE: <var>thenRealm</var> is never <emu-val>null</emu-val>. When <var>then</var>.[[Callback]] is a revoked Proxy and no code runs, <var>thenRealm</var> is used to create error objects.</li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>thenRealm</var> }.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>This <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> uses the supplied thenable and its <code>then</code> method to resolve the given promise. This process must take place as a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> to ensure that the evaluation of the <code>then</code> method occurs after evaluation of any surrounding code has completed.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by <emu-xref href=\"#host\"><a href=\"#host\">host</a></emu-xref> environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-function.prototype.tostring": {"num": "19.2.3.5", "title": "#sec-function.prototype.tostring Function.prototype.toString ( )", "html": "<emu-clause id=\"sec-function.prototype.tostring\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-function.prototype.tostring\">#sec-function.prototype.tostring</span> Function.prototype.toString ( )</h1>\n        <p>When the <code>toString</code> method is called, the following steps are taken:</p>\n        <emu-alg><ol><li>Let <var>func</var> be the <emu-val>this</emu-val> value.</li><li>If <var>func</var> is a <emu-xref href=\"#sec-built-in-function-objects\"><a href=\"#sec-built-in-function-objects\">built-in function object</a></emu-xref>, then return an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> String source code representation of <var>func</var>. The representation must have the syntax of a <emu-nt><a href=\"#prod-NativeFunction\">NativeFunction</a></emu-nt>. Additionally, if <var>func</var> has an [[InitialName]] internal slot and <var>func</var>.[[InitialName]] is a String, the portion of the returned String that would be matched by <emu-nt optional=\"\"><a href=\"#prod-NativeFunctionAccessor\">NativeFunctionAccessor</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> <emu-nt><a href=\"#prod-PropertyName\">PropertyName</a></emu-nt> must be the value of <var>func</var>.[[InitialName]].</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>func</var>) is Object and <var>func</var> has a [[SourceText]] internal slot and <var>func</var>.[[SourceText]] is a sequence of Unicode code points and !&#160;<emu-xref aoid=\"HostHasSourceTextAvailable\"><a href=\"#sec-hosthassourcetextavailable\">HostHasSourceTextAvailable</a></emu-xref>(<var>func</var>) is <emu-val>true</emu-val>, then<ol><li>Return !&#160;<emu-xref aoid=\"CodePointsToString\"><a href=\"#sec-codepointstostring\">CodePointsToString</a></emu-xref>(<var>func</var>.[[SourceText]]).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>func</var>) is Object and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>func</var>) is <emu-val>true</emu-val>, then return an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> String source code representation of <var>func</var>. The representation must have the syntax of a <emu-nt><a href=\"#prod-NativeFunction\">NativeFunction</a></emu-nt>.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></emu-alg>\n\n        <emu-grammar type=\"definition\"><emu-production name=\"NativeFunction\" id=\"prod-NativeFunction\">\n    <emu-nt><a href=\"#prod-NativeFunction\">NativeFunction</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"959625bf\"><emu-t>function</emu-t><emu-nt optional=\"\"><a href=\"#prod-NativeFunctionAccessor\">NativeFunctionAccessor</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-nt params=\"~Yield, ~Await\" optional=\"\"><a href=\"#prod-PropertyName\">PropertyName</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params=\"~Yield, ~Await\"><a href=\"#prod-FormalParameters\">FormalParameters</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-t>[</emu-t><emu-t>native</emu-t><emu-t>code</emu-t><emu-t>]</emu-t><emu-t>}</emu-t></emu-rhs>\n</emu-production>\n<emu-production name=\"NativeFunctionAccessor\" id=\"prod-NativeFunctionAccessor\">\n    <emu-nt><a href=\"#prod-NativeFunctionAccessor\">NativeFunctionAccessor</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"3d88de52\"><emu-t>get</emu-t></emu-rhs>\n    <emu-rhs a=\"c9970c11\"><emu-t>set</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      </emu-clause>\n\n      "}, "sec-newpromisereactionjob": {"num": "26.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\"><span id=\"sec-promisereactionjob\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-const>empty</emu-const>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"HostCallJobCallback\"><a href=\"#sec-hostcalljobcallback\">HostCallJobCallback</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>.</li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-const>empty</emu-const>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]].[[Callback]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li><li>Else, set <var>handlerRealm</var> to <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>.</li><li>NOTE: <var>handlerRealm</var> is never <emu-val>null</emu-val> unless the handler is <emu-val>undefined</emu-val>. When the handler is a revoked Proxy and no ECMAScript code runs, <var>handlerRealm</var> is used to create error objects.</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-generator-function-definitions-runtime-semantics-evaluation", "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset", "sec-makebasicobject", "sec-newpromiseresolvethenablejob", "sec-finishdynamicimport", "sec-function.prototype.tostring", "sec-newpromisereactionjob"], "secData": {"sec-generator-function-definitions-runtime-semantics-evaluation": {"num": "14.4.14", "title": "#sec-generator-function-definitions-runtime-semantics-evaluation Runtime Semantics: Evaluation", "html": "<emu-clause id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-generator-function-definitions-runtime-semantics-evaluation\">#sec-generator-function-definitions-runtime-semantics-evaluation</span> Runtime Semantics: Evaluation</h1>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"0d271960\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Return the result of performing NamedEvaluation for this <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> with argument <emu-val>\"\"</emu-val>.</li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"GeneratorExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"7dbc99b6\"><emu-t>function</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt><emu-t>(</emu-t><emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>scope</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>funcEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>scope</var>).</li><li>Let <var>name</var> be StringValue of <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt>.</li><li>Perform <var>funcEnv</var>.CreateImmutableBinding(<var>name</var>, <emu-val>false</emu-val>).</li><li>Let <var>sourceText</var> be the source text matched by <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</li><li>Let <var>closure</var> be <emu-xref aoid=\"OrdinaryFunctionCreate\"><a href=\"#sec-ordinaryfunctioncreate\">OrdinaryFunctionCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-the-generatorfunction-prototype-object\"><a href=\"#sec-properties-of-the-generatorfunction-prototype-object\">%GeneratorFunction.prototype%</a></emu-xref>, <var>sourceText</var>, <emu-nt><a href=\"#prod-FormalParameters\">FormalParameters</a></emu-nt>, <emu-nt><a href=\"#prod-GeneratorBody\">GeneratorBody</a></emu-nt>, <emu-const>non-lexical-this</emu-const>, <var>funcEnv</var>).</li><li>Perform <emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>closure</var>, <var>name</var>).</li><li>Let <var>prototype</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<emu-xref href=\"#sec-properties-of-generator-prototype\"><a href=\"#sec-properties-of-generator-prototype\">%GeneratorFunction.prototype.prototype%</a></emu-xref>).</li><li>Perform <emu-xref aoid=\"DefinePropertyOrThrow\"><a href=\"#sec-definepropertyorthrow\">DefinePropertyOrThrow</a></emu-xref>(<var>closure</var>, <emu-val>\"prototype\"</emu-val>, PropertyDescriptor { [[Value]]: <var>prototype</var>, [[Writable]]: <emu-val>true</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }).</li><li>Perform <var>funcEnv</var>.InitializeBinding(<var>name</var>, <var>closure</var>).</li><li>Return <var>closure</var>.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> can be referenced from inside the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>'s <emu-nt><a href=\"#prod-FunctionBody\">FunctionBody</a></emu-nt> to allow the generator code to call itself recursively. However, unlike in a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, the <emu-nt><a href=\"#prod-BindingIdentifier\">BindingIdentifier</a></emu-nt> in a <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt> cannot be referenced from and does not affect the scope enclosing the <emu-nt><a href=\"#prod-GeneratorExpression\">GeneratorExpression</a></emu-nt>.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d1df3360\"><emu-t>yield</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<emu-val>undefined</emu-val>, <emu-val>false</emu-val>)).</li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"e741ede8\"><emu-t>yield</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, return ?&#160;<emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(<var>value</var>).</li><li>Otherwise, return ?&#160;<emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <emu-val>false</emu-val>)).</li></ol></emu-alg>\n      <emu-grammar><emu-production name=\"YieldExpression\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-YieldExpression\">YieldExpression</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"47a33813\"><emu-t>yield</emu-t><emu-t>*</emu-t><emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n      <emu-alg><ol><li>Let <var>generatorKind</var> be !&#160;<emu-xref aoid=\"GetGeneratorKind\"><a href=\"#sec-getgeneratorkind\">GetGeneratorKind</a></emu-xref>().</li><li>Let <var>exprRef</var> be the result of evaluating <emu-nt><a href=\"#prod-AssignmentExpression\">AssignmentExpression</a></emu-nt>.</li><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>exprRef</var>).</li><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>, <var>generatorKind</var>).</li><li>Let <var>iterator</var> be <var>iteratorRecord</var>.[[Iterator]].</li><li>Let <var>received</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li><li>Repeat,<ol><li>If <var>received</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>iteratorRecord</var>.[[NextMethod]], <var>iteratorRecord</var>.[[Iterator]], &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else if <var>received</var>.[[Type]] is <emu-const>throw</emu-const>, then<ol><li>Let <var>throw</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"throw\"</emu-val>).</li><li>If <var>throw</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>innerResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>throw</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>innerResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerResult</var>).</li><li>NOTE: Exceptions from the inner iterator <code>throw</code> method are propagated. Normal completions from an inner <code>throw</code> method are processed similarly to an inner <code>next</code>.</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Return ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerResult</var>).</li></ol></li><li>Else,<ol><li>NOTE: If <var>iterator</var> does not have a <code>throw</code> method, this throw is going to terminate the <code>yield*</code> loop. But first we need to give <var>iterator</var> a chance to clean up.</li><li>Let <var>closeCompletion</var> be <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>normal</emu-const>, [[Value]]: <emu-const>empty</emu-const>, [[Target]]: <emu-const>empty</emu-const> }.</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, perform ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>Else, perform ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>closeCompletion</var>).</li><li>NOTE: The next step throws a <emu-val>TypeError</emu-val> to indicate that there was a <code>yield*</code> protocol violation: <var>iterator</var> does not have a <code>throw</code> method.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>received</var>.[[Type]] is <emu-const>return</emu-const>.</li><li>Let <var>return</var> be ?&#160;<emu-xref aoid=\"GetMethod\"><a href=\"#sec-getmethod\">GetMethod</a></emu-xref>(<var>iterator</var>, <emu-val>\"return\"</emu-val>).</li><li>If <var>return</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>received</var>.[[Value]] to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>received</var>.[[Value]]).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>received</var>).</li></ol></li><li>Let <var>innerReturnResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>return</var>, <var>iterator</var>, &#171; <var>received</var>.[[Value]] &#187;).</li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>innerReturnResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>innerReturnResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>innerReturnResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>value</var> be ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> { [[Type]]: <emu-const>return</emu-const>, [[Value]]: <var>value</var>, [[Target]]: <emu-const>empty</emu-const> }.</li></ol></li><li>If <var>generatorKind</var> is <emu-const>async</emu-const>, set <var>received</var> to <emu-xref aoid=\"AsyncGeneratorYield\"><a href=\"#sec-asyncgeneratoryield\">AsyncGeneratorYield</a></emu-xref>(? <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>innerReturnResult</var>)).</li><li>Else, set <var>received</var> to <emu-xref aoid=\"GeneratorYield\"><a href=\"#sec-generatoryield\">GeneratorYield</a></emu-xref>(<var>innerReturnResult</var>).</li></ol></li></ol></li></ol></emu-alg>\n    </emu-clause>\n  "}, "sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset": {"num": "13.7.5.13", "title": "#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset ForIn/OfBodyEvaluation ( lhs, stmt, iteratorRecord, iterationKind, lhsKind, labelSet [ , iteratorKind ] )", "html": "<emu-clause id=\"sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset\" aoid=\"ForIn/OfBodyEvaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset\">#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset</span> ForIn/OfBodyEvaluation ( <var>lhs</var>, <var>stmt</var>, <var>iteratorRecord</var>, <var>iterationKind</var>, <var>lhsKind</var>, <var>labelSet</var> [ , <var>iteratorKind</var> ] )</h1>\n        <p>The abstract operation ForIn/OfBodyEvaluation takes arguments <var>lhs</var>, <var>stmt</var>, <var>iteratorRecord</var>, <var>iterationKind</var>, <var>lhsKind</var> (either <emu-const>assignment</emu-const>, <emu-const>varBinding</emu-const> or <emu-const>lexicalBinding</emu-const>), and <var>labelSet</var> and optional argument <var>iteratorKind</var> (either <emu-const>sync</emu-const> or <emu-const>async</emu-const>). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>iteratorKind</var> is not present, set <var>iteratorKind</var> to <emu-const>sync</emu-const>.</li><li>Let <var>oldEnv</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment.</li><li>Let <var>V</var> be <emu-val>undefined</emu-val>.</li><li>Let <var>destructuring</var> be IsDestructuring of <var>lhs</var>.</li><li>If <var>destructuring</var> is <emu-val>true</emu-val> and if <var>lhsKind</var> is <emu-const>assignment</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-LeftHandSideExpression\">LeftHandSideExpression</a></emu-nt>.</li><li>Let <var>assignmentPattern</var> be the <emu-nt><a href=\"#prod-AssignmentPattern\">AssignmentPattern</a></emu-nt> that is <emu-xref href=\"#sec-syntactic-grammar\"><a href=\"#sec-syntactic-grammar\">covered</a></emu-xref> by <var>lhs</var>.</li></ol></li><li>Repeat,<ol><li>Let <var>nextResult</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>iteratorRecord</var>.[[NextMethod]], <var>iteratorRecord</var>.[[Iterator]]).</li><li>If <var>iteratorKind</var> is <emu-const>async</emu-const>, set <var>nextResult</var> to ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>nextResult</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nextResult</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>done</var> be ?&#160;<emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>nextResult</var>).</li><li>If <var>done</var> is <emu-val>true</emu-val>, return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>V</var>).</li><li>Let <var>nextValue</var> be ?&#160;<emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>nextResult</var>).</li><li>If <var>lhsKind</var> is either <emu-const>assignment</emu-const> or <emu-const>varBinding</emu-const>, then<ol><li>If <var>destructuring</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>lhsRef</var> be the result of evaluating <var>lhs</var>. (It may be evaluated repeatedly.)</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhsKind</var> is <emu-const>lexicalBinding</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-ForDeclaration\">ForDeclaration</a></emu-nt>.</li><li>Let <var>iterationEnv</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>oldEnv</var>).</li><li>Perform BindingInstantiation for <var>lhs</var> passing <var>iterationEnv</var> as the argument.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>iterationEnv</var>.</li><li>If <var>destructuring</var> is <emu-val>false</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> binds a single name.</li><li>Let <var>lhsName</var> be the sole element of BoundNames of <var>lhs</var>.</li><li>Let <var>lhsRef</var> be !&#160;<emu-xref aoid=\"ResolveBinding\"><a href=\"#sec-resolvebinding\">ResolveBinding</a></emu-xref>(<var>lhsName</var>).</li></ol></li></ol></li><li>If <var>destructuring</var> is <emu-val>false</emu-val>, then<ol><li>If <var>lhsRef</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <var>lhsRef</var>.</li></ol></li><li>Else if <var>lhsKind</var> is <emu-const>lexicalBinding</emu-const>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"InitializeReferencedBinding\"><a href=\"#sec-initializereferencedbinding\">InitializeReferencedBinding</a></emu-xref>(<var>lhsRef</var>, <var>nextValue</var>).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"PutValue\"><a href=\"#sec-putvalue\">PutValue</a></emu-xref>(<var>lhsRef</var>, <var>nextValue</var>).</li></ol></li></ol></li><li>Else,<ol><li>If <var>lhsKind</var> is <emu-const>assignment</emu-const>, then<ol><li>Let <var>status</var> be DestructuringAssignmentEvaluation of <var>assignmentPattern</var> with argument <var>nextValue</var>.</li></ol></li><li>Else if <var>lhsKind</var> is <emu-const>varBinding</emu-const>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-ForBinding\">ForBinding</a></emu-nt>.</li><li>Let <var>status</var> be BindingInitialization of <var>lhs</var> with arguments <var>nextValue</var> and <emu-val>undefined</emu-val>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhsKind</var> is <emu-const>lexicalBinding</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>lhs</var> is a <emu-nt><a href=\"#prod-ForDeclaration\">ForDeclaration</a></emu-nt>.</li><li>Let <var>status</var> be BindingInitialization of <var>lhs</var> with arguments <var>nextValue</var> and <var>iterationEnv</var>.</li></ol></li></ol></li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>If <var>iteratorKind</var> is <emu-const>async</emu-const>, return ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>If <var>iterationKind</var> is <emu-const>enumerate</emu-const>, then<ol><li>Return <var>status</var>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iterationKind</var> is <emu-const>iterate</emu-const>.</li><li>Return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li></ol></li></ol></li><li>Let <var>result</var> be the result of evaluating <var>stmt</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>oldEnv</var>.</li><li>If <emu-xref aoid=\"LoopContinues\"><a href=\"#sec-loopcontinues\">LoopContinues</a></emu-xref>(<var>result</var>, <var>labelSet</var>) is <emu-val>false</emu-val>, then<ol><li>If <var>iterationKind</var> is <emu-const>enumerate</emu-const>, then<ol><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<emu-xref aoid=\"UpdateEmpty\"><a href=\"#sec-updateempty\">UpdateEmpty</a></emu-xref>(<var>result</var>, <var>V</var>)).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iterationKind</var> is <emu-const>iterate</emu-const>.</li><li>Set <var>status</var> to <emu-xref aoid=\"UpdateEmpty\"><a href=\"#sec-updateempty\">UpdateEmpty</a></emu-xref>(<var>result</var>, <var>V</var>).</li><li>If <var>iteratorKind</var> is <emu-const>async</emu-const>, return ?&#160;<emu-xref aoid=\"AsyncIteratorClose\"><a href=\"#sec-asynciteratorclose\">AsyncIteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>Return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li></ol></li></ol></li><li>If <var>result</var>.[[Value]] is not <emu-const>empty</emu-const>, set <var>V</var> to <var>result</var>.[[Value]].</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-makebasicobject": {"num": "7.3.1", "title": "#sec-makebasicobject MakeBasicObject ( internalSlotsList )", "html": "<emu-clause id=\"sec-makebasicobject\" aoid=\"MakeBasicObject\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-makebasicobject\">#sec-makebasicobject</span> MakeBasicObject ( <var>internalSlotsList</var> )</h1>\n      <p>The abstract operation MakeBasicObject takes argument <var>internalSlotsList</var>. It is the source of all ECMAScript objects that are created algorithmically, including both ordinary objects and exotic objects. It factors out common steps used in creating all objects, and centralizes object creation. It performs the following steps when called:</p>\n\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>internalSlotsList</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of internal slot names.</li><li>Let <var>obj</var> be a newly created object with an internal slot for each name in <var>internalSlotsList</var>.</li><li>Set <var>obj</var>'s essential internal methods to the default <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"><a href=\"#sec-ordinary-object-internal-methods-and-internal-slots\" class=\"excluded-xref\" excluded-id=\"sec-ordinary-object-internal-methods-and-internal-slots\">#sec-ordinary-object-internal-methods-and-internal-slots</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If the caller will not be overriding both <var>obj</var>'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then <var>internalSlotsList</var> contains [[Prototype]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If the caller will not be overriding all of <var>obj</var>'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then <var>internalSlotsList</var> contains [[Extensible]].</li><li>If <var>internalSlotsList</var> contains [[Extensible]], set <var>obj</var>.[[Extensible]] to <emu-val>true</emu-val>.</li><li>Return <var>obj</var>.</li></ol></emu-alg>\n\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>Within this specification, exotic objects are created in <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> such as <emu-xref aoid=\"ArrayCreate\"><a href=\"#sec-arraycreate\">ArrayCreate</a></emu-xref> and <emu-xref aoid=\"BoundFunctionCreate\"><a href=\"#sec-boundfunctioncreate\">BoundFunctionCreate</a></emu-xref> by first calling MakeBasicObject to obtain a basic, foundational object, and then overriding some or all of that object's internal methods. In order to encapsulate <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">exotic object</a></emu-xref> creation, the object's essential internal methods are never modified outside those operations.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-newpromiseresolvethenablejob": {"num": "26.6.2.2", "title": "#sec-newpromiseresolvethenablejob NewPromiseResolveThenableJob ( promiseToResolve, thenable, then )", "html": "<emu-clause id=\"sec-newpromiseresolvethenablejob\" aoid=\"NewPromiseResolveThenableJob\" oldids=\"sec-promiseresolvethenablejob\"><span id=\"sec-promiseresolvethenablejob\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromiseresolvethenablejob\">#sec-newpromiseresolvethenablejob</span> NewPromiseResolveThenableJob ( <var>promiseToResolve</var>, <var>thenable</var>, <var>then</var> )</h1>\n        <p>The abstract operation NewPromiseResolveThenableJob takes arguments <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>promiseToResolve</var>, <var>thenable</var>, and <var>then</var> and performs the following steps when called:<ol><li>Let <var>resolvingFunctions</var> be <emu-xref aoid=\"CreateResolvingFunctions\"><a href=\"#sec-createresolvingfunctions\">CreateResolvingFunctions</a></emu-xref>(<var>promiseToResolve</var>).</li><li>Let <var>thenCallResult</var> be <emu-xref aoid=\"HostCallJobCallback\"><a href=\"#sec-hostcalljobcallback\">HostCallJobCallback</a></emu-xref>(<var>then</var>, <var>thenable</var>, &#171; <var>resolvingFunctions</var>.[[Resolve]], <var>resolvingFunctions</var>.[[Reject]] &#187;).</li><li>If <var>thenCallResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resolvingFunctions</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>thenCallResult</var>.[[Value]] &#187;).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>thenCallResult</var>).</li></ol></li><li>Let <var>getThenRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>then</var>.[[Callback]]).</li><li>If <var>getThenRealmResult</var> is a normal completion, let <var>thenRealm</var> be <var>getThenRealmResult</var>.[[Value]].</li><li>Else, let <var>thenRealm</var> be <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>.</li><li>NOTE: <var>thenRealm</var> is never <emu-val>null</emu-val>. When <var>then</var>.[[Callback]] is a revoked Proxy and no code runs, <var>thenRealm</var> is used to create error objects.</li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>thenRealm</var> }.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>This <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> uses the supplied thenable and its <code>then</code> method to resolve the given promise. This process must take place as a <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> to ensure that the evaluation of the <code>then</code> method occurs after evaluation of any surrounding code has completed.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by <emu-xref href=\"#host\"><a href=\"#host\">host</a></emu-xref> environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-function.prototype.tostring": {"num": "19.2.3.5", "title": "#sec-function.prototype.tostring Function.prototype.toString ( )", "html": "<emu-clause id=\"sec-function.prototype.tostring\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-function.prototype.tostring\">#sec-function.prototype.tostring</span> Function.prototype.toString ( )</h1>\n        <p>When the <code>toString</code> method is called, the following steps are taken:</p>\n        <emu-alg><ol><li>Let <var>func</var> be the <emu-val>this</emu-val> value.</li><li>If <var>func</var> is a <emu-xref href=\"#sec-built-in-function-objects\"><a href=\"#sec-built-in-function-objects\">built-in function object</a></emu-xref>, return an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> String source code representation of <var>func</var>. The representation must have the syntax of a <emu-nt><a href=\"#prod-NativeFunction\">NativeFunction</a></emu-nt>. Additionally, if <var>func</var> has an [[InitialName]] internal slot and <var>func</var>.[[InitialName]] is a String, the portion of the returned String that would be matched by <emu-nt optional=\"\"><a href=\"#prod-NativeFunctionAccessor\">NativeFunctionAccessor</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> <emu-nt><a href=\"#prod-PropertyName\">PropertyName</a></emu-nt> must be the value of <var>func</var>.[[InitialName]].</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>func</var>) is Object and <var>func</var> has a [[SourceText]] internal slot and <var>func</var>.[[SourceText]] is a sequence of Unicode code points and !&#160;<emu-xref aoid=\"HostHasSourceTextAvailable\"><a href=\"#sec-hosthassourcetextavailable\">HostHasSourceTextAvailable</a></emu-xref>(<var>func</var>) is <emu-val>true</emu-val>, then<ol><li>Return !&#160;<emu-xref aoid=\"CodePointsToString\"><a href=\"#sec-codepointstostring\">CodePointsToString</a></emu-xref>(<var>func</var>.[[SourceText]]).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>func</var>) is Object and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>func</var>) is <emu-val>true</emu-val>, return an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> String source code representation of <var>func</var>. The representation must have the syntax of a <emu-nt><a href=\"#prod-NativeFunction\">NativeFunction</a></emu-nt>.</li><li>Throw a <emu-val>TypeError</emu-val> exception.</li></ol></emu-alg>\n\n        <emu-grammar type=\"definition\"><emu-production name=\"NativeFunction\" id=\"prod-NativeFunction\">\n    <emu-nt><a href=\"#prod-NativeFunction\">NativeFunction</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"959625bf\"><emu-t>function</emu-t><emu-nt optional=\"\"><a href=\"#prod-NativeFunctionAccessor\">NativeFunctionAccessor</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-nt params=\"~Yield, ~Await\" optional=\"\"><a href=\"#prod-PropertyName\">PropertyName</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>(</emu-t><emu-nt params=\"~Yield, ~Await\"><a href=\"#prod-FormalParameters\">FormalParameters</a><emu-mods><emu-params>[~Yield, ~Await]</emu-params></emu-mods></emu-nt><emu-t>)</emu-t><emu-t>{</emu-t><emu-t>[</emu-t><emu-t>native</emu-t><emu-t>code</emu-t><emu-t>]</emu-t><emu-t>}</emu-t></emu-rhs>\n</emu-production>\n<emu-production name=\"NativeFunctionAccessor\" id=\"prod-NativeFunctionAccessor\">\n    <emu-nt><a href=\"#prod-NativeFunctionAccessor\">NativeFunctionAccessor</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"3d88de52\"><emu-t>get</emu-t></emu-rhs>\n    <emu-rhs a=\"c9970c11\"><emu-t>set</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n      </emu-clause>\n\n      "}, "sec-newpromisereactionjob": {"num": "26.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\"><span id=\"sec-promisereactionjob\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-const>empty</emu-const>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"HostCallJobCallback\"><a href=\"#sec-hostcalljobcallback\">HostCallJobCallback</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>.</li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-const>empty</emu-const>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]].[[Callback]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li><li>Else, set <var>handlerRealm</var> to <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>.</li><li>NOTE: <var>handlerRealm</var> is never <emu-val>null</emu-val> unless the handler is <emu-val>undefined</emu-val>. When the handler is a revoked Proxy and no ECMAScript code runs, <var>handlerRealm</var> is used to create error objects.</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {}}}