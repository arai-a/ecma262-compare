{"from": {"secList": ["sec-array.prototype.sort", "sec-%typedarray%.prototype.sort"], "secData": {"sec-array.prototype.sort": {"num": "23.1.3.27", "title": "#sec-array.prototype.sort Array.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-array.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</span> Array.prototype.sort ( <var>comparefn</var> )</h1>\n        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If <var>comparefn</var> is not <emu-val>undefined</emu-val>, it should be a function that accepts two arguments <var>x</var> and <var>y</var> and returns a negative value if <var>x</var> &lt; <var>y</var>, zero if <var>x</var> = <var>y</var>, or a positive value if <var>x</var> &gt; <var>y</var>.</p>\n        <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>obj</var>).</li></ol></emu-alg>\n        <p>Within this specification of the <code>sort</code> method, an object, <var>obj</var>, is said to be <em>sparse</em> if the following algorithm returns <emu-val>true</emu-val>:</p>\n        <emu-alg><ol><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> in the range 0 &#8804; <var>i</var> &lt; <var>len</var>, do<ol><li>Let <var>prop</var> be !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>i</var>)).</li><li>Let <var>elem</var> be <var>obj</var>.[[GetOwnProperty]](<var>prop</var>).</li><li>If <var>elem</var> is <emu-val>undefined</emu-val>, return <emu-val>true</emu-val>.</li></ol></li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n        <p>The <em>sort order</em> is the ordering, after completion of this function, of the <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> property values of <var>obj</var> whose <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> indexes are less than <var>len</var>. The result of the <code>sort</code> function is then determined as follows:</p>\n        <p>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and is not a consistent comparison function for the elements of this array (see below), the sort order is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>. The sort order is also <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> if <var>comparefn</var> is <emu-val>undefined</emu-val> and <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> does not act as a consistent comparison function.</p>\n        <p>Let <var>proto</var> be <var>obj</var>.[[GetPrototypeOf]](). If <var>proto</var> is not <emu-val>null</emu-val> and there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> such that all of the conditions below are satisfied then the sort order is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>:</p>\n        <ul>\n          <li>\n            <var>obj</var> is sparse\n          </li>\n          <li>\n            0 &#8804; <var>j</var> &lt; <var>len</var>\n          </li>\n          <li>\n            <emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>proto</var>, <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>))) is <emu-val>true</emu-val>.\n          </li>\n        </ul>\n        <p>The sort order is also <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> if <var>obj</var> is sparse and any of the following conditions are true:</p>\n        <ul>\n          <li>\n            <emu-xref aoid=\"IsExtensible\"><a href=\"#sec-isextensible-o\">IsExtensible</a></emu-xref>(<var>obj</var>) is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            Any <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer index</a></emu-xref> property of <var>obj</var> whose name is a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var> is a <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">data property</a></emu-xref> whose [[Configurable]] attribute is <emu-val>false</emu-val>.\n          </li>\n        </ul>\n        <p>The sort order is also <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> if any of the following conditions are true:</p>\n        <ul>\n          <li>\n            If <var>obj</var> is an <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">exotic object</a></emu-xref> (including Proxy exotic objects) whose behaviour for [[Get]], [[Set]], [[Delete]], and [[GetOwnProperty]] is not the <emu-xref href=\"#ordinary-object\"><a href=\"#ordinary-object\">ordinary object</a></emu-xref> implementation of these internal methods.\n          </li>\n          <li>\n            If any index property of <var>obj</var> whose name is a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var> is an <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">accessor property</a></emu-xref> or is a <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">data property</a></emu-xref> whose [[Writable]] attribute is <emu-val>false</emu-val>.\n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and the application of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> to any value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> modifies <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and all applications of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>, to any specific value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>, do not produce the same result.\n          </li>\n        </ul>\n        <p>The following steps are taken:</p>\n        <emu-alg><ol><li>Perform an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> sequence of calls to the <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>, <emu-xref href=\"#sec-set-o-p-v-throw\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>, <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref>, and <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref> abstract operation with <var>obj</var> as the first argument, and to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> (described below), such that:<ul><li>The property key argument for each call to <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>, <emu-xref href=\"#sec-set-o-p-v-throw\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>, <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref>, or <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> is the string representation of a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var>.</li><li>The <code>Throw</code> argument for every call to <emu-xref href=\"#sec-set-o-p-v-throw\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref> is <emu-val>true</emu-val>.</li><li>The arguments for calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> are values returned by a previous call to the <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref> abstract operation, unless the properties accessed by those previous calls did not exist according to <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref>. If both prospective arguments to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> correspond to non-existent properties, use <emu-val>+0</emu-val><sub>&#120125;</sub> instead of calling <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>. If only the first prospective argument is non-existent, use <emu-val>1</emu-val><sub>&#120125;</sub>. If only the second prospective argument is non-existent, use <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>obj</var> is not sparse then <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> must not be called.</li><li>If an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> is returned from any of these operations, it is immediately returned as the value of this function.</li></ul></li><li>Return <var>obj</var>.</li></ol></emu-alg>\n        <p>Unless the sort order is specified above to be <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>, the returned object must have the following two characteristics:</p>\n        <ul>\n          <li>\n            There must be some mathematical permutation &#960; of the non-negative integers less than <var>len</var>, such that for every non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> less than <var>len</var>, if property <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> existed, then <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn> is exactly the same value as <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn>. But if property <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> did not exist, then <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn> does not exist.\n          </li>\n          <li>\n            Then for all non-negative integers <var>j</var> and <var>k</var>, each less than <var>len</var>, if <emu-eqn class=\"inline\"><emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>(old[<var>j</var>], old[<var>k</var>]) &lt; 0</emu-eqn> (see <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> below), then <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)] &lt; new[&#960;(<var>k</var>)]</emu-eqn>.\n          </li>\n        </ul>\n        <p>Here the notation <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is used to refer to the hypothetical result of calling <emu-eqn class=\"inline\"><emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>j</var>)</emu-eqn> before this function is executed, and the notation <emu-eqn class=\"inline\">new[<var>j</var>]</emu-eqn> to refer to the hypothetical result of calling <emu-eqn class=\"inline\"><emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>j</var>)</emu-eqn> after this function has been executed.</p>\n        <p>A function <var>comparefn</var> is a consistent comparison function for a set of values <var>S</var> if all of the requirements below are met for all values <var>a</var>, <var>b</var>, and <var>c</var> (possibly the same value) in the set <var>S</var>: The notation <emu-eqn class=\"inline\"><var>a</var> &lt;<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &lt; 0</emu-eqn>; <emu-eqn class=\"inline\"><var>a</var> =<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) = 0</emu-eqn> (of either sign); and <emu-eqn class=\"inline\"><var>a</var> &gt;<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &gt; 0</emu-eqn>.</p>\n        <ul>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) always returns the same value <var>v</var> when given a specific pair of values <var>a</var> and <var>b</var> as its two arguments. Furthermore, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>v</var>) is Number, and <var>v</var> is not <emu-val>NaN</emu-val>. Note that this implies that exactly one of <var>a</var> &lt;<sub>CF</sub> <var>b</var>, <var>a</var> =<sub>CF</sub> <var>b</var>, and <var>a</var> &gt;<sub>CF</sub> <var>b</var> will be true for a given pair of <var>a</var> and <var>b</var>.\n          </li>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) does not modify <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          </li>\n          <li>\n            <var>a</var> =<sub>CF</sub> <var>a</var> (reflexivity)\n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var>, then <var>b</var> =<sub>CF</sub> <var>a</var> (symmetry)\n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var> and <var>b</var> =<sub>CF</sub> <var>c</var>, then <var>a</var> =<sub>CF</sub> <var>c</var> (transitivity of =<sub>CF</sub>)\n          </li>\n          <li>\n            If <var>a</var> &lt;<sub>CF</sub> <var>b</var> and <var>b</var> &lt;<sub>CF</sub> <var>c</var>, then <var>a</var> &lt;<sub>CF</sub> <var>c</var> (transitivity of &lt;<sub>CF</sub>)\n          </li>\n          <li>\n            If <var>a</var> &gt;<sub>CF</sub> <var>b</var> and <var>b</var> &gt;<sub>CF</sub> <var>c</var>, then <var>a</var> &gt;<sub>CF</sub> <var>c</var> (transitivity of &gt;<sub>CF</sub>)\n          </li>\n        </ul>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The above conditions are necessary and sufficient to ensure that <var>comparefn</var> divides the set <var>S</var> into equivalence classes and that these equivalence classes are totally ordered.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>sort</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-sortcompare\"><h1><span class=\"secnum\">23.1.3.27.1</span>#sec-sortcompare SortCompare ( x, y )</h1>...</div></emu-clause>\n\n      "}, "sec-%typedarray%.prototype.sort": {"num": "23.2.3.26", "title": "#sec-%typedarray%.prototype.sort %TypedArray%.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-%typedarray%.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-%typedarray%.prototype.sort\">#sec-%typedarray%.prototype.sort</span> %TypedArray%.prototype.sort ( <var>comparefn</var> )</h1>\n        <p><emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> is a distinct function that, except as described below, implements the same requirements as those of <code>Array.prototype.sort</code> as defined in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>. The implementation of the <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> specification may be optimized with the knowledge that the <emu-val>this</emu-val> value is an object that has a fixed length and whose <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> properties are not sparse. The only internal methods of the <emu-val>this</emu-val> value that the algorithm may call are [[Get]] and [[Set]].</p>\n        <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>\n        <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function. These steps are used instead of the entry steps in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>buffer</var> be ?&#160;<emu-xref aoid=\"ValidateTypedArray\"><a href=\"#sec-validatetypedarray\">ValidateTypedArray</a></emu-xref>(<var>obj</var>).</li><li>Let <var>len</var> be <var>obj</var>.[[ArrayLength]].</li></ol></emu-alg>\n        <p>The <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> sort order condition for exotic objects is not applied by <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code>.</p>\n        <p>The following version of <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> is used by <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code>. It performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>.</p>\n        <p>The abstract operation TypedArraySortCompare takes arguments <var>x</var> and <var>y</var>. It also has access to the <var>comparefn</var> and <var>buffer</var> values of the current invocation of the <code>sort</code> method. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Both <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>) are Number or both are BigInt.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&#160;<emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(? <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, &#171; <var>x</var>, <var>y</var> &#187;)).</li><li>If <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>Return <var>v</var>.</li></ol></li><li>If <var>x</var> and <var>y</var> are both <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &lt; <var>y</var>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &gt; <var>y</var>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Because <emu-val>NaN</emu-val> always compares greater than any other value, <emu-val>NaN</emu-val> property values always sort to the end of the result when <var>comparefn</var> is not provided.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-array.prototype.sort", "sec-%typedarray%.prototype.sort"], "secData": {"sec-array.prototype.sort": {"num": "23.1.3.27", "title": "#sec-array.prototype.sort Array.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-array.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</span> Array.prototype.sort ( <var>comparefn</var> )</h1>\n        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If <var>comparefn</var> is not <emu-val>undefined</emu-val>, it should be a function that accepts two arguments <var>x</var> and <var>y</var> and returns a negative value if <var>x</var> &lt; <var>y</var>, zero if <var>x</var> = <var>y</var>, or a positive value if <var>x</var> &gt; <var>y</var>.</p>\n        <p>The following steps are taken:</p>\n        <emu-alg><ol><li id=\"step-array-sort-comparefn\">If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li id=\"step-array-sort-len\">Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>obj</var>).</li><li>Let <var>items</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>k</var> be 0.</li><li>Repeat, while <var>k</var> &lt; <var>len</var>,<ol><li>Let <var>Pk</var> be !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>k</var>)).</li><li>Let <var>kPresent</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>obj</var>, <var>Pk</var>).</li><li>If <var>kPresent</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>kValue</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>Pk</var>).</li><li>Append <var>kValue</var> to <var>items</var>.</li></ol></li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Let <var>itemCount</var> be the length of <var>items</var>.</li><li id=\"step-array-sort\">Sort <var>items</var> using an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> sequence of calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>. If any such call returns an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, stop before performing any further calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> or steps in this algorithm and return that completion.</li><li>Let <var>j</var> be 0.</li><li>Repeat, while <var>j</var> &lt; <var>itemCount</var>,<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>obj</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>)), items[<var>j</var>], <emu-val>true</emu-val>).</li><li>Set <var>j</var> to <var>j</var> + 1.</li></ol></li><li>Repeat, while <var>j</var> &lt; <var>len</var>,<ol><li>Perform ?&#160;<emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref>(<var>obj</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>))).</li><li>Set <var>j</var> to <var>j</var> + 1.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>\n        <p>The <em>sort order</em> is the ordering, after completion of this function, of the <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> property values of <var>obj</var> whose <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> indexes are less than <var>len</var>. The result of the <code>sort</code> function is then determined as follows:</p>\n        <p>The sort order is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> if any of the following conditions is true:</p>\n        <ul>\n          <li>\n            If <var>comparefn</var> is not <emu-val>undefined</emu-val> and is not a consistent comparison function for the elements of <var>items</var> (see below).\n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> does not act as a consistent comparison function.\n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and all applications of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>, to any specific value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>, do not produce the same result.\n          </li>\n        </ul>\n        <p>Unless the sort order is specified above to be <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>, <var>items</var> must satisfy all of the following conditions after executing step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> of the algorithm above:</p>\n        <ul>\n          <li>\n            There must be some mathematical permutation &#960; of the non-negative integers less than <var>itemCount</var>, such that for every non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> less than <var>itemCount</var>, the element <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is exactly the same as <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn>.\n          </li>\n          <li>\n            Then for all non-negative integers <var>j</var> and <var>k</var>, each less than <var>itemCount</var>, if <emu-eqn class=\"inline\"><emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>(old[<var>j</var>], old[<var>k</var>]) &lt; 0</emu-eqn> (see <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> below), then <emu-eqn class=\"inline\">&#960;(<var>j</var>) &lt; &#960;(<var>k</var>)</emu-eqn>.\n          </li>\n        </ul>\n        <p>Here the notation <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is used to refer to <emu-eqn class=\"inline\"><var>items</var>[<var>j</var>]</emu-eqn> before step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> is executed, and the notation <emu-eqn class=\"inline\">new[<var>j</var>]</emu-eqn> to refer to <emu-eqn class=\"inline\"><var>items</var>[<var>j</var>]</emu-eqn> after step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> has been executed.</p>\n        <p>A function <var>comparefn</var> is a consistent comparison function for a set of values <var>S</var> if all of the requirements below are met for all values <var>a</var>, <var>b</var>, and <var>c</var> (possibly the same value) in the set <var>S</var>: The notation <emu-eqn class=\"inline\"><var>a</var> &lt;<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &lt; 0</emu-eqn>; <emu-eqn class=\"inline\"><var>a</var> =<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) = 0</emu-eqn> (of either sign); and <emu-eqn class=\"inline\"><var>a</var> &gt;<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &gt; 0</emu-eqn>.</p>\n        <ul>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) always returns the same value <var>v</var> when given a specific pair of values <var>a</var> and <var>b</var> as its two arguments. Furthermore, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>v</var>) is Number, and <var>v</var> is not <emu-val>NaN</emu-val>. Note that this implies that exactly one of <var>a</var> &lt;<sub>CF</sub> <var>b</var>, <var>a</var> =<sub>CF</sub> <var>b</var>, and <var>a</var> &gt;<sub>CF</sub> <var>b</var> will be true for a given pair of <var>a</var> and <var>b</var>.\n          </li>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) does not modify <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          </li>\n          <li>\n            <var>a</var> =<sub>CF</sub> <var>a</var> (reflexivity)\n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var>, then <var>b</var> =<sub>CF</sub> <var>a</var> (symmetry)\n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var> and <var>b</var> =<sub>CF</sub> <var>c</var>, then <var>a</var> =<sub>CF</sub> <var>c</var> (transitivity of =<sub>CF</sub>)\n          </li>\n          <li>\n            If <var>a</var> &lt;<sub>CF</sub> <var>b</var> and <var>b</var> &lt;<sub>CF</sub> <var>c</var>, then <var>a</var> &lt;<sub>CF</sub> <var>c</var> (transitivity of &lt;<sub>CF</sub>)\n          </li>\n          <li>\n            If <var>a</var> &gt;<sub>CF</sub> <var>b</var> and <var>b</var> &gt;<sub>CF</sub> <var>c</var>, then <var>a</var> &gt;<sub>CF</sub> <var>c</var> (transitivity of &gt;<sub>CF</sub>)\n          </li>\n        </ul>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The above conditions are necessary and sufficient to ensure that <var>comparefn</var> divides the set <var>S</var> into equivalence classes and that these equivalence classes are totally ordered.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>sort</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-sortcompare\"><h1><span class=\"secnum\">23.1.3.27.1</span>#sec-sortcompare SortCompare ( x, y )</h1>...</div></emu-clause>\n\n      "}, "sec-%typedarray%.prototype.sort": {"num": "23.2.3.26", "title": "#sec-%typedarray%.prototype.sort %TypedArray%.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-%typedarray%.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-%typedarray%.prototype.sort\">#sec-%typedarray%.prototype.sort</span> %TypedArray%.prototype.sort ( <var>comparefn</var> )</h1>\n        <p><emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> is a distinct function that, except as described below, implements the same requirements as those of <code>Array.prototype.sort</code> as defined in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>. The implementation of the <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> specification may be optimized with the knowledge that the <emu-val>this</emu-val> value is an object that has a fixed length and whose <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> properties are not sparse. The only internal methods of the <emu-val>this</emu-val> value that the algorithm may call are [[Get]] and [[Set]].</p>\n        <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>\n        <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function. These steps are used instead of steps <emu-xref href=\"#step-array-sort-comparefn\"><a href=\"#step-array-sort-comparefn\" class=\"excluded-xref\" excluded-id=\"step-array-sort-comparefn\">#step-array-sort-comparefn</a></emu-xref>&#8211;<emu-xref href=\"#step-array-sort-len\"><a href=\"#step-array-sort-len\" class=\"excluded-xref\" excluded-id=\"step-array-sort-len\">#step-array-sort-len</a></emu-xref> in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>buffer</var> be ?&#160;<emu-xref aoid=\"ValidateTypedArray\"><a href=\"#sec-validatetypedarray\">ValidateTypedArray</a></emu-xref>(<var>obj</var>).</li><li>Let <var>len</var> be <var>obj</var>.[[ArrayLength]].</li></ol></emu-alg>\n        <p>The following version of <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> is used by <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code>. It performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>.</p>\n        <p>The abstract operation TypedArraySortCompare takes arguments <var>x</var> and <var>y</var>. It also has access to the <var>comparefn</var> and <var>buffer</var> values of the current invocation of the <code>sort</code> method. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Both <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>) are Number or both are BigInt.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&#160;<emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(? <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, &#171; <var>x</var>, <var>y</var> &#187;)).</li><li>If <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>Return <var>v</var>.</li></ol></li><li>If <var>x</var> and <var>y</var> are both <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &lt; <var>y</var>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &gt; <var>y</var>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Because <emu-val>NaN</emu-val> always compares greater than any other value, <emu-val>NaN</emu-val> property values always sort to the end of the result when <var>comparefn</var> is not provided.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}}, "figData": {}}}