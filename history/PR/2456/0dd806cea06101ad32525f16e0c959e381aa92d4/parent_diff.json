{"from": {"secList": ["sec-islessthan"], "secData": {"sec-islessthan": {"num": "7.2.13", "title": "#sec-islessthan IsLessThan ( x, y, LeftFirst )", "html": "<emu-clause id=\"sec-islessthan\" aoid=\"IsLessThan\" oldids=\"sec-abstract-relational-comparison\"><span id=\"sec-abstract-relational-comparison\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-islessthan\">#sec-islessthan</span> IsLessThan ( <var>x</var>, <var>y</var>, <var>LeftFirst</var> )</h1>\n      <p>The abstract operation IsLessThan takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), and <var>LeftFirst</var> (a Boolean). It provides the semantics for the comparison <var>x</var> &lt; <var>y</var>, returning <emu-val>true</emu-val>, <emu-val>false</emu-val>, or <emu-val>undefined</emu-val> (which indicates that at least one operand is <emu-val>NaN</emu-val>). The <var>LeftFirst</var> flag is used to control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. If <var>LeftFirst</var> is <emu-val>true</emu-val>, the <var>x</var> parameter corresponds to an expression that occurs to the left of the <var>y</var> parameter's corresponding expression. If <var>LeftFirst</var> is <emu-val>false</emu-val>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If the <var>LeftFirst</var> flag is <emu-val>true</emu-val>, then<ol><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li></ol></li><li>Else,<ol><li>NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li></ol></li><li id=\"step-arc-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>py</var>, <var>px</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>px</var>, <var>py</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>k</var> be the smallest non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that the code unit at index <var>k</var> within <var>px</var> is different from the code unit at index <var>k</var> within <var>py</var>. (There must be such a <var>k</var>, for neither String is a prefix of the other.)</li><li>Let <var>m</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>px</var>.</li><li>Let <var>n</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>py</var>.</li><li>If <var>m</var> &lt; <var>n</var>, return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>py</var>).</li><li>If <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>px</var>, <var>ny</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is BigInt, then<ol><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>px</var>).</li><li>If <var>nx</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>nx</var>, <var>py</var>).</li></ol></li><li>NOTE: Because <var>px</var> and <var>py</var> are primitive values, evaluation order is not important.</li><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>px</var>).</li><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>py</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is the same as <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>), return <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>)::lessThan(<var>nx</var>, <var>ny</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is Number, or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is BigInt.</li><li>If <var>nx</var> or <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>nx</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>nx</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>nx</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>ny</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> differs from step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">2.c</a></emu-xref> in the algorithm that handles the addition operator <code>+</code> (<emu-xref href=\"#sec-applystringornumericbinaryoperator\"><a href=\"#sec-applystringornumericbinaryoperator\" class=\"excluded-xref\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</a></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}}, "figData": {}}, "to": {"secList": ["sec-islessthan"], "secData": {"sec-islessthan": {"num": "7.2.13", "title": "#sec-islessthan IsLessThan ( x, y, LeftFirst )", "html": "<emu-clause id=\"sec-islessthan\" aoid=\"IsLessThan\" oldids=\"sec-abstract-relational-comparison\"><span id=\"sec-abstract-relational-comparison\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-islessthan\">#sec-islessthan</span> IsLessThan ( <var>x</var>, <var>y</var>, <var>LeftFirst</var> )</h1>\n      <p>The abstract operation IsLessThan takes arguments <var>x</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>y</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), and <var>LeftFirst</var> (a Boolean). It provides the semantics for the comparison <var>x</var> &lt; <var>y</var>, returning <emu-val>true</emu-val>, <emu-val>false</emu-val>, or <emu-val>undefined</emu-val> (which indicates that at least one operand is <emu-val>NaN</emu-val>). The <var>LeftFirst</var> flag is used to control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. If <var>LeftFirst</var> is <emu-val>true</emu-val>, the <var>x</var> parameter corresponds to an expression that occurs to the left of the <var>y</var> parameter's corresponding expression. If <var>LeftFirst</var> is <emu-val>false</emu-val>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. It performs the following steps when called:</p>\n      <emu-alg><ol><li>If the <var>LeftFirst</var> flag is <emu-val>true</emu-val>, then<ol><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li></ol></li><li>Else,<ol><li>NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li></ol></li><li id=\"step-arc-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>py</var>, <var>px</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>px</var>, <var>py</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>k</var> be the smallest non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that the code unit at index <var>k</var> within <var>px</var> is different from the code unit at index <var>k</var> within <var>py</var>. (There must be such a <var>k</var>, for neither String is a prefix of the other.)</li><li>Let <var>m</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>px</var>.</li><li>Let <var>n</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>py</var>.</li><li>If <var>m</var> &lt; <var>n</var>, return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>py</var>).</li><li>If <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>px</var>, <var>ny</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is BigInt, then<ol><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>px</var>).</li><li>If <var>nx</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>nx</var>, <var>py</var>).</li></ol></li><li>NOTE: Because <var>px</var> and <var>py</var> are primitive values, evaluation order is not important.</li><li>Let <var>nx</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>px</var>).</li><li>Let <var>ny</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>py</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is the same as <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>), return <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>)::lessThan(<var>nx</var>, <var>ny</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is Number, or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is BigInt.</li><li>If <var>nx</var> or <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>nx</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>nx</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>nx</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>ny</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> differs from step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">2.c</a></emu-xref> in the algorithm that handles the addition operator <code>+</code> (<emu-xref href=\"#sec-applystringornumericbinaryoperator\"><a href=\"#sec-applystringornumericbinaryoperator\" class=\"excluded-xref\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</a></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}}, "figData": {}}}