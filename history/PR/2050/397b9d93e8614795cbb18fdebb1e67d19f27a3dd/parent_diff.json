{"from": {"secList": ["sec-finishdynamicimport", "sec-performpromiseallsettled", "sec-newpromisecapability", "sec-promisereaction-records", "sec-promisecapability-records", "sec-getcapabilitiesexecutor-functions", "sec-async-functions-abstract-operations-async-function-start", "sec-newpromisereactionjob", "sec-asyncgeneratorrequest-records", "sec-performpromiserace", "sec-asyncfromsynciteratorcontinuation", "sec-performpromisethen", "sec-performpromiseall", "sec-ifabruptrejectpromise"], "secData": {"sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport Runtime Semantics: FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> Runtime Semantics: FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by host environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-performpromiseallsettled": {"num": "25.6.4.2.1", "title": "#sec-performpromiseallsettled Runtime Semantics: PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiseallsettled\" aoid=\"PerformPromiseAllSettled\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseallsettled\">#sec-performpromiseallsettled</span> Runtime Semantics: PerformPromiseAllSettled ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseAllSettled takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: !&#160;<emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-resolve-element-functions\"><code>Promise.allSettled</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Let <var>alreadyCalled</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Let <var>rejectSteps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-reject-element-functions\"><code>Promise.allSettled</code> Reject Element Functions</a></emu-xref>.</li><li>Let <var>rejectElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectSteps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>rejectElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>rejectElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>rejectElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>rejectElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>rejectElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>rejectElement</var> &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-newpromisecapability": {"num": "25.6.1.5", "title": "#sec-newpromisecapability NewPromiseCapability ( C )", "html": "<emu-clause id=\"sec-newpromisecapability\" aoid=\"NewPromiseCapability\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisecapability\">#sec-newpromisecapability</span> NewPromiseCapability ( <var>C</var> )</h1>\n        <p>The abstract operation NewPromiseCapability takes argument <var>C</var>. It attempts to use <var>C</var> as a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> in the fashion of the built-in Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> to create a Promise object and extract its <code>resolve</code> and <code>reject</code> functions. The Promise object plus the <code>resolve</code> and <code>reject</code> functions are used to initialize a new PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>C</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: <var>C</var> is assumed to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> (see <emu-xref href=\"#sec-promise-executor\"><a href=\"#sec-promise-executor\" class=\"excluded-xref\" excluded-id=\"sec-promise-executor\">#sec-promise-executor</a></emu-xref>).</li><li>Let <var>promiseCapability</var> be the PromiseCapability { [[Promise]]: <emu-val>undefined</emu-val>, [[Resolve]]: <emu-val>undefined</emu-val>, [[Reject]]: <emu-val>undefined</emu-val> }.</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-getcapabilitiesexecutor-functions\" title=\"\"><a href=\"#sec-getcapabilitiesexecutor-functions\">GetCapabilitiesExecutor Functions</a></emu-xref>.</li><li>Let <var>executor</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[Capability]] &#187;).</li><li>Set <var>executor</var>.[[Capability]] to <var>promiseCapability</var>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"Construct\"><a href=\"#sec-construct\">Construct</a></emu-xref>(<var>C</var>, &#171; <var>executor</var> &#187;).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]]) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseCapability</var>.[[Reject]]) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>promiseCapability</var>.[[Promise]] to <var>promise</var>.</li><li>Return <var>promiseCapability</var>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>This abstract operation supports Promise subclassing, as it is generic on any <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> that calls a passed executor function argument in the same way as the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>. It is used to generalize static methods of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> to any subclass.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-getcapabilitiesexecutor-functions\"><h1><span class=\"secnum\">25.6.1.5.1</span>#sec-getcapabilitiesexecutor-functions GetCapabilitiesExecutor Functions</h1>...</div></emu-clause>\n\n      "}, "sec-promisereaction-records": {"num": "25.6.1.2", "title": "#sec-promisereaction-records PromiseReaction Records", "html": "<emu-clause id=\"sec-promisereaction-records\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promisereaction-records\">#sec-promisereaction-records</span> PromiseReaction Records</h1>\n        <p>The PromiseReaction is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction records are created by the <emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref> abstract operation, and are used by the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> returned by <emu-xref aoid=\"NewPromiseReactionJob\"><a href=\"#sec-newpromisereactionjob\">NewPromiseReactionJob</a></emu-xref>.</p>\n        <p>PromiseReaction records have the fields listed in <emu-xref href=\"#table-58\"><a href=\"#table-58\" class=\"excluded-xref\" excluded-id=\"table-58\">#table-58</a></emu-xref>.</p>\n        <emu-table id=\"table-58\" caption=\"PromiseReaction Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-58\">#table-58</span>: PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> Fields</figcaption>\n          <table>\n            <tbody>\n            <tr>\n              <th>\n                Field Name\n              </th>\n              <th>\n                Value\n              </th>\n              <th>\n                Meaning\n              </th>\n            </tr>\n            <tr>\n              <td>\n                [[Capability]]\n              </td>\n              <td>\n                A PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>, or <emu-val>undefined</emu-val>\n              </td>\n              <td>\n                The capabilities of the promise for which this record provides a reaction handler.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Type]]\n              </td>\n              <td>\n                <emu-const>Fulfill</emu-const> | <emu-const>Reject</emu-const>\n              </td>\n              <td>\n                The [[Type]] is used when [[Handler]] is <emu-val>undefined</emu-val> to allow for behaviour specific to the settlement type.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Handler]]\n              </td>\n              <td>\n                A <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> or <emu-val>undefined</emu-val>.\n              </td>\n              <td>\n                The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is <emu-val>undefined</emu-val>, a function that depends on the value of [[Type]] will be used instead.\n              </td>\n            </tr>\n            </tbody>\n          </table>\n        </figure></emu-table>\n      </emu-clause>\n\n      "}, "sec-promisecapability-records": {"num": "25.6.1.1", "title": "#sec-promisecapability-records PromiseCapability Records", "html": "<emu-clause id=\"sec-promisecapability-records\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promisecapability-records\">#sec-promisecapability-records</span> PromiseCapability Records</h1>\n        <p>A PromiseCapability is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> value used to encapsulate a promise object along with the functions that are capable of resolving or rejecting that promise object. PromiseCapability Records are produced by the <emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref> abstract operation.</p>\n        <p>PromiseCapability Records have the fields listed in <emu-xref href=\"#table-57\"><a href=\"#table-57\" class=\"excluded-xref\" excluded-id=\"table-57\">#table-57</a></emu-xref>.</p>\n        <emu-table id=\"table-57\" caption=\"PromiseCapability Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-57\">#table-57</span>: PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> Fields</figcaption>\n          <table>\n            <tbody>\n            <tr>\n              <th>\n                Field Name\n              </th>\n              <th>\n                Value\n              </th>\n              <th>\n                Meaning\n              </th>\n            </tr>\n            <tr>\n              <td>\n                [[Promise]]\n              </td>\n              <td>\n                An object\n              </td>\n              <td>\n                An object that is usable as a promise.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Resolve]]\n              </td>\n              <td>\n                A <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>\n              </td>\n              <td>\n                The function that is used to resolve the given promise object.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Reject]]\n              </td>\n              <td>\n                A <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>\n              </td>\n              <td>\n                The function that is used to reject the given promise object.\n              </td>\n            </tr>\n            </tbody>\n          </table>\n        </figure></emu-table>\n\n        <div id=\"excluded-sec-ifabruptrejectpromise\"><h1><span class=\"secnum\">25.6.1.1.1</span>#sec-ifabruptrejectpromise IfAbruptRejectPromise ( value, capability )</h1>...</div></emu-clause>\n\n      "}, "sec-getcapabilitiesexecutor-functions": {"num": "25.6.1.5.1", "title": "#sec-getcapabilitiesexecutor-functions GetCapabilitiesExecutor Functions", "html": "<emu-clause id=\"sec-getcapabilitiesexecutor-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getcapabilitiesexecutor-functions\">#sec-getcapabilitiesexecutor-functions</span> GetCapabilitiesExecutor Functions</h1>\n          <p>A GetCapabilitiesExecutor function is an anonymous built-in function that has a [[Capability]] internal slot.</p>\n          <p>When a GetCapabilitiesExecutor function is called with arguments <var>resolve</var> and <var>reject</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>F</var> has a [[Capability]] internal slot whose value is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li>If <var>promiseCapability</var>.[[Resolve]] is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>promiseCapability</var>.[[Reject]] is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>promiseCapability</var>.[[Resolve]] to <var>resolve</var>.</li><li>Set <var>promiseCapability</var>.[[Reject]] to <var>reject</var>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a GetCapabilitiesExecutor function is 2.</p>\n        </emu-clause>\n      "}, "sec-async-functions-abstract-operations-async-function-start": {"num": "25.7.5.1", "title": "#sec-async-functions-abstract-operations-async-function-start AsyncFunctionStart ( promiseCapability, asyncFunctionBody )", "html": "<emu-clause id=\"sec-async-functions-abstract-operations-async-function-start\" aoid=\"AsyncFunctionStart\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-functions-abstract-operations-async-function-start\">#sec-async-functions-abstract-operations-async-function-start</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>\n        <p>The abstract operation AsyncFunctionStart takes arguments <var>promiseCapability</var> and <var>asyncFunctionBody</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li>NOTE: Copying the execution state is required for the step below to resume its execution. It is ill-defined to resume a currently executing context.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li id=\"step-asyncfunctionstart-return-undefined\">Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncfunctionstart-return-undefined\"><a href=\"#step-asyncfunctionstart-return-undefined\">4.g</a></emu-xref> above.</li><li>Return.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-newpromisereactionjob": {"num": "25.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\">\n        <span id=\"sec-promisereactionjob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncgeneratorrequest-records": {"num": "25.5.3.1", "title": "#sec-asyncgeneratorrequest-records AsyncGeneratorRequest Records", "html": "<emu-clause id=\"sec-asyncgeneratorrequest-records\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorrequest-records\">#sec-asyncgeneratorrequest-records</span> AsyncGeneratorRequest Records</h1>\n        <p>The AsyncGeneratorRequest is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> value used to store information about how an async generator should be resumed and contains capabilities for fulfilling or rejecting the corresponding promise.</p>\n        <p>They have the following fields:</p>\n        <emu-table caption=\"AsyncGeneratorRequest Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-noid-1\">#table-noid-1</span>: AsyncGeneratorRequest <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> Fields</figcaption>\n          <table>\n            <tbody>\n            <tr>\n              <th>Field Name</th>\n              <th>Value</th>\n              <th>Meaning</th>\n            </tr>\n            <tr>\n              <td>[[Completion]]</td>\n              <td>A <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> record</td>\n              <td>The completion which should be used to resume the async generator.</td>\n            </tr>\n            <tr>\n              <td>[[Capability]]</td>\n              <td>A PromiseCapability record</td>\n              <td>The promise capabilities associated with this request.</td>\n            </tr>\n            </tbody>\n          </table>\n        </figure></emu-table>\n      </emu-clause>\n\n      "}, "sec-performpromiserace": {"num": "25.6.4.4.1", "title": "#sec-performpromiserace Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiserace\" aoid=\"PerformPromiseRace\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiserace\">#sec-performpromiserace</span> Runtime Semantics: PerformPromiseRace ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseRace takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resultCapability</var>.[[Resolve]], <var>resultCapability</var>.[[Reject]] &#187;).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-asyncfromsynciteratorcontinuation": {"num": "25.1.4.4", "title": "#sec-asyncfromsynciteratorcontinuation AsyncFromSyncIteratorContinuation ( result, promiseCapability )", "html": "<emu-clause id=\"sec-asyncfromsynciteratorcontinuation\" aoid=\"AsyncFromSyncIteratorContinuation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncfromsynciteratorcontinuation\">#sec-asyncfromsynciteratorcontinuation</span> AsyncFromSyncIteratorContinuation ( <var>result</var>, <var>promiseCapability</var> )</h1>\n        <p>The abstract operation AsyncFromSyncIteratorContinuation takes arguments <var>result</var> and <var>promiseCapability</var>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>Let <var>done</var> be <emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>done</var>, <var>promiseCapability</var>).</li><li>Let <var>value</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>value</var>, <var>promiseCapability</var>).</li><li>Let <var>valueWrapper</var> be <emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>valueWrapper</var>, <var>promiseCapability</var>).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-async-from-sync-iterator-value-unwrap-functions\" title=\"\"><a href=\"#sec-async-from-sync-iterator-value-unwrap-functions\">Async-from-Sync Iterator Value Unwrap Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[Done]] &#187;).</li><li>Set <var>onFulfilled</var>.[[Done]] to <var>done</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>valueWrapper</var>, <var>onFulfilled</var>, <emu-val>undefined</emu-val>, <var>promiseCapability</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-performpromisethen": {"num": "25.6.5.4.1", "title": "#sec-performpromisethen PerformPromiseThen ( promise, onFulfilled, onRejected [ , resultCapability ] )", "html": "<emu-clause id=\"sec-performpromisethen\" aoid=\"PerformPromiseThen\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromisethen\">#sec-performpromisethen</span> PerformPromiseThen ( <var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var> [ , <var>resultCapability</var> ] )</h1>\n          <p>The abstract operation PerformPromiseThen takes arguments <var>promise</var>, <var>onFulfilled</var>, and <var>onRejected</var> and optional argument <var>resultCapability</var>. It performs the &#8220;then&#8221; operation on <var>promise</var> using <var>onFulfilled</var> and <var>onRejected</var> as its settlement actions. If <var>resultCapability</var> is passed, the result is stored by updating <var>resultCapability</var>'s promise. If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsPromise\"><a href=\"#sec-ispromise\">IsPromise</a></emu-xref>(<var>promise</var>) is <emu-val>true</emu-val>.</li><li>If <var>resultCapability</var> is present, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li></ol></li><li>Else,<ol><li>Set <var>resultCapability</var> to <emu-val>undefined</emu-val>.</li></ol></li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>onFulfilled</var>) is <emu-val>false</emu-val>, then<ol><li>Set <var>onFulfilled</var> to <emu-val>undefined</emu-val>.</li></ol></li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>onRejected</var>) is <emu-val>false</emu-val>, then<ol><li>Set <var>onRejected</var> to <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>fulfillReaction</var> be the PromiseReaction { [[Capability]]: <var>resultCapability</var>, [[Type]]: <emu-const>Fulfill</emu-const>, [[Handler]]: <var>onFulfilled</var> }.</li><li>Let <var>rejectReaction</var> be the PromiseReaction { [[Capability]]: <var>resultCapability</var>, [[Type]]: <emu-const>Reject</emu-const>, [[Handler]]: <var>onRejected</var> }.</li><li>If <var>promise</var>.[[PromiseState]] is <emu-const>pending</emu-const>, then<ol><li>Append <var>fulfillReaction</var> as the last element of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that is <var>promise</var>.[[PromiseFulfillReactions]].</li><li>Append <var>rejectReaction</var> as the last element of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that is <var>promise</var>.[[PromiseRejectReactions]].</li></ol></li><li>Else if <var>promise</var>.[[PromiseState]] is <emu-const>fulfilled</emu-const>, then<ol><li>Let <var>value</var> be <var>promise</var>.[[PromiseResult]].</li><li>Let <var>fulfillJob</var> be <emu-xref aoid=\"NewPromiseReactionJob\"><a href=\"#sec-newpromisereactionjob\">NewPromiseReactionJob</a></emu-xref>(<var>fulfillReaction</var>, <var>value</var>).</li><li>Perform <emu-xref aoid=\"HostEnqueuePromiseJob\"><a href=\"#sec-hostenqueuepromisejob\">HostEnqueuePromiseJob</a></emu-xref>(<var>fulfillJob</var>.[[Job]], <var>fulfillJob</var>.[[Realm]]).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The value of <var>promise</var>.[[PromiseState]] is <emu-const>rejected</emu-const>.</li><li>Let <var>reason</var> be <var>promise</var>.[[PromiseResult]].</li><li>If <var>promise</var>.[[PromiseIsHandled]] is <emu-val>false</emu-val>, perform <emu-xref aoid=\"HostPromiseRejectionTracker\"><a href=\"#sec-host-promise-rejection-tracker\">HostPromiseRejectionTracker</a></emu-xref>(<var>promise</var>, <emu-val>\"handle\"</emu-val>).</li><li>Let <var>rejectJob</var> be <emu-xref aoid=\"NewPromiseReactionJob\"><a href=\"#sec-newpromisereactionjob\">NewPromiseReactionJob</a></emu-xref>(<var>rejectReaction</var>, <var>reason</var>).</li><li>Perform <emu-xref aoid=\"HostEnqueuePromiseJob\"><a href=\"#sec-hostenqueuepromisejob\">HostEnqueuePromiseJob</a></emu-xref>(<var>rejectJob</var>.[[Job]], <var>rejectJob</var>.[[Realm]]).</li></ol></li><li>Set <var>promise</var>.[[PromiseIsHandled]] to <emu-val>true</emu-val>.</li><li>If <var>resultCapability</var> is <emu-val>undefined</emu-val>, then<ol><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Else,<ol><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-performpromiseall": {"num": "25.6.4.1.2", "title": "#sec-performpromiseall Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiseall\" aoid=\"PerformPromiseAll\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseall\">#sec-performpromiseall</span> Runtime Semantics: PerformPromiseAll ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseAll takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.all-resolve-element-functions\"><code>Promise.all</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>resultCapability</var>.[[Reject]] &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-ifabruptrejectpromise": {"num": "25.6.1.1.1", "title": "#sec-ifabruptrejectpromise IfAbruptRejectPromise ( value, capability )", "html": "<emu-clause id=\"sec-ifabruptrejectpromise\" aoid=\"IfAbruptRejectPromise\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ifabruptrejectpromise\">#sec-ifabruptrejectpromise</span> IfAbruptRejectPromise ( <var>value</var>, <var>capability</var> )</h1>\n          <p>IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>. An algorithm step of the form:</p>\n          <emu-alg><ol><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>value</var>, <var>capability</var>).</li></ol></emu-alg>\n          <p>means the same thing as:</p>\n          <emu-alg><ol><li>If <var>value</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>capability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>value</var>.[[Value]] &#187;).</li><li>Return <var>capability</var>.[[Promise]].</li></ol></li><li>Else if <var>value</var> is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>, set <var>value</var> to <var>value</var>.[[Value]].</li></ol></emu-alg>\n        </emu-clause>\n      "}}, "figData": {"table-5": "Table 6", "table-noid-1": "Table 75", "table-57": "Table 76", "table-58": "Table 77"}}, "to": {"secList": ["sec-finishdynamicimport", "sec-performpromiseallsettled", "sec-newpromisecapability", "sec-promisereaction-records", "sec-promisecapability-records", "sec-getcapabilitiesexecutor-functions", "sec-async-functions-abstract-operations-async-function-start", "sec-newpromisereactionjob", "sec-asyncgeneratorrequest-records", "sec-performpromiserace", "sec-asyncfromsynciteratorcontinuation", "sec-performpromisethen", "sec-performpromiseall", "sec-ifabruptrejectpromise"], "secData": {"sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport Runtime Semantics: FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> Runtime Semantics: FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by host environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-performpromiseallsettled": {"num": "25.6.4.2.1", "title": "#sec-performpromiseallsettled Runtime Semantics: PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiseallsettled\" aoid=\"PerformPromiseAllSettled\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseallsettled\">#sec-performpromiseallsettled</span> Runtime Semantics: PerformPromiseAllSettled ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseAllSettled takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: !&#160;<emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-resolve-element-functions\"><code>Promise.allSettled</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Let <var>alreadyCalled</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Let <var>rejectSteps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-reject-element-functions\"><code>Promise.allSettled</code> Reject Element Functions</a></emu-xref>.</li><li>Let <var>rejectElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectSteps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>rejectElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>rejectElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>rejectElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>rejectElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>rejectElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>rejectElement</var> &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-newpromisecapability": {"num": "25.6.1.5", "title": "#sec-newpromisecapability NewPromiseCapability ( C )", "html": "<emu-clause id=\"sec-newpromisecapability\" aoid=\"NewPromiseCapability\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisecapability\">#sec-newpromisecapability</span> NewPromiseCapability ( <var>C</var> )</h1>\n        <p>The abstract operation NewPromiseCapability takes argument <var>C</var>. It attempts to use <var>C</var> as a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> in the fashion of the built-in Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> to create a Promise object and extract its <code>resolve</code> and <code>reject</code> functions. The Promise object plus the <code>resolve</code> and <code>reject</code> functions are used to initialize a new <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>C</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: <var>C</var> is assumed to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> (see <emu-xref href=\"#sec-promise-executor\"><a href=\"#sec-promise-executor\" class=\"excluded-xref\" excluded-id=\"sec-promise-executor\">#sec-promise-executor</a></emu-xref>).</li><li>Let <var>promiseCapability</var> be the <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref> { [[Promise]]: <emu-val>undefined</emu-val>, [[Resolve]]: <emu-val>undefined</emu-val>, [[Reject]]: <emu-val>undefined</emu-val> }.</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-getcapabilitiesexecutor-functions\" title=\"\"><a href=\"#sec-getcapabilitiesexecutor-functions\">GetCapabilitiesExecutor Functions</a></emu-xref>.</li><li>Let <var>executor</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[Capability]] &#187;).</li><li>Set <var>executor</var>.[[Capability]] to <var>promiseCapability</var>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"Construct\"><a href=\"#sec-construct\">Construct</a></emu-xref>(<var>C</var>, &#171; <var>executor</var> &#187;).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]]) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseCapability</var>.[[Reject]]) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>promiseCapability</var>.[[Promise]] to <var>promise</var>.</li><li>Return <var>promiseCapability</var>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>This abstract operation supports Promise subclassing, as it is generic on any <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> that calls a passed executor function argument in the same way as the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>. It is used to generalize static methods of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> to any subclass.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-getcapabilitiesexecutor-functions\"><h1><span class=\"secnum\">25.6.1.5.1</span>#sec-getcapabilitiesexecutor-functions GetCapabilitiesExecutor Functions</h1>...</div></emu-clause>\n\n      "}, "sec-promisereaction-records": {"num": "25.6.1.2", "title": "#sec-promisereaction-records PromiseReaction Records", "html": "<emu-clause id=\"sec-promisereaction-records\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promisereaction-records\">#sec-promisereaction-records</span> PromiseReaction Records</h1>\n        <p>The PromiseReaction is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> value used to store information about how a promise should react when it becomes resolved or rejected with a given value. PromiseReaction records are created by the <emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref> abstract operation, and are used by the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> returned by <emu-xref aoid=\"NewPromiseReactionJob\"><a href=\"#sec-newpromisereactionjob\">NewPromiseReactionJob</a></emu-xref>.</p>\n        <p>PromiseReaction records have the fields listed in <emu-xref href=\"#table-58\"><a href=\"#table-58\" class=\"excluded-xref\" excluded-id=\"table-58\">#table-58</a></emu-xref>.</p>\n        <emu-table id=\"table-58\" caption=\"PromiseReaction Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-58\">#table-58</span>: PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> Fields</figcaption>\n          <table>\n            <tbody>\n            <tr>\n              <th>\n                Field Name\n              </th>\n              <th>\n                Value\n              </th>\n              <th>\n                Meaning\n              </th>\n            </tr>\n            <tr>\n              <td>\n                [[Capability]]\n              </td>\n              <td>\n                A <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>, or <emu-val>undefined</emu-val>\n              </td>\n              <td>\n                The capabilities of the promise for which this record provides a reaction handler.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Type]]\n              </td>\n              <td>\n                <emu-const>Fulfill</emu-const> | <emu-const>Reject</emu-const>\n              </td>\n              <td>\n                The [[Type]] is used when [[Handler]] is <emu-val>undefined</emu-val> to allow for behaviour specific to the settlement type.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Handler]]\n              </td>\n              <td>\n                A <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> or <emu-val>undefined</emu-val>.\n              </td>\n              <td>\n                The function that should be applied to the incoming value, and whose return value will govern what happens to the derived promise. If [[Handler]] is <emu-val>undefined</emu-val>, a function that depends on the value of [[Type]] will be used instead.\n              </td>\n            </tr>\n            </tbody>\n          </table>\n        </figure></emu-table>\n      </emu-clause>\n\n      "}, "sec-promisecapability-records": {"num": "25.6.1.1", "title": "#sec-promisecapability-records PromiseCapability Records", "html": "<emu-clause id=\"sec-promisecapability-records\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promisecapability-records\">#sec-promisecapability-records</span> PromiseCapability Records</h1>\n        <p>A <dfn>PromiseCapability Record</dfn> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> value used to encapsulate a promise object along with the functions that are capable of resolving or rejecting that promise object. PromiseCapability Records are produced by the <emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref> abstract operation.</p>\n        <p>PromiseCapability Records have the fields listed in <emu-xref href=\"#table-57\"><a href=\"#table-57\" class=\"excluded-xref\" excluded-id=\"table-57\">#table-57</a></emu-xref>.</p>\n        <emu-table id=\"table-57\" caption=\"PromiseCapability Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-57\">#table-57</span>: <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref> Fields</figcaption>\n          <table>\n            <tbody>\n            <tr>\n              <th>\n                Field Name\n              </th>\n              <th>\n                Value\n              </th>\n              <th>\n                Meaning\n              </th>\n            </tr>\n            <tr>\n              <td>\n                [[Promise]]\n              </td>\n              <td>\n                An object\n              </td>\n              <td>\n                An object that is usable as a promise.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Resolve]]\n              </td>\n              <td>\n                A <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>\n              </td>\n              <td>\n                The function that is used to resolve the given promise object.\n              </td>\n            </tr>\n            <tr>\n              <td>\n                [[Reject]]\n              </td>\n              <td>\n                A <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref>\n              </td>\n              <td>\n                The function that is used to reject the given promise object.\n              </td>\n            </tr>\n            </tbody>\n          </table>\n        </figure></emu-table>\n\n        <div id=\"excluded-sec-ifabruptrejectpromise\"><h1><span class=\"secnum\">25.6.1.1.1</span>#sec-ifabruptrejectpromise IfAbruptRejectPromise ( value, capability )</h1>...</div></emu-clause>\n\n      "}, "sec-getcapabilitiesexecutor-functions": {"num": "25.6.1.5.1", "title": "#sec-getcapabilitiesexecutor-functions GetCapabilitiesExecutor Functions", "html": "<emu-clause id=\"sec-getcapabilitiesexecutor-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getcapabilitiesexecutor-functions\">#sec-getcapabilitiesexecutor-functions</span> GetCapabilitiesExecutor Functions</h1>\n          <p>A GetCapabilitiesExecutor function is an anonymous built-in function that has a [[Capability]] internal slot.</p>\n          <p>When a GetCapabilitiesExecutor function is called with arguments <var>resolve</var> and <var>reject</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>F</var> has a [[Capability]] internal slot whose value is a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li>If <var>promiseCapability</var>.[[Resolve]] is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>promiseCapability</var>.[[Reject]] is not <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Set <var>promiseCapability</var>.[[Resolve]] to <var>resolve</var>.</li><li>Set <var>promiseCapability</var>.[[Reject]] to <var>reject</var>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a GetCapabilitiesExecutor function is 2.</p>\n        </emu-clause>\n      "}, "sec-async-functions-abstract-operations-async-function-start": {"num": "25.7.5.1", "title": "#sec-async-functions-abstract-operations-async-function-start AsyncFunctionStart ( promiseCapability, asyncFunctionBody )", "html": "<emu-clause id=\"sec-async-functions-abstract-operations-async-function-start\" aoid=\"AsyncFunctionStart\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-functions-abstract-operations-async-function-start\">#sec-async-functions-abstract-operations-async-function-start</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>\n        <p>The abstract operation AsyncFunctionStart takes arguments <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>) and <var>asyncFunctionBody</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li>NOTE: Copying the execution state is required for the step below to resume its execution. It is ill-defined to resume a currently executing context.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li id=\"step-asyncfunctionstart-return-undefined\">Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncfunctionstart-return-undefined\"><a href=\"#step-asyncfunctionstart-return-undefined\">4.g</a></emu-xref> above.</li><li>Return.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-newpromisereactionjob": {"num": "25.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\">\n        <span id=\"sec-promisereactionjob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>.</li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncgeneratorrequest-records": {"num": "25.5.3.1", "title": "#sec-asyncgeneratorrequest-records AsyncGeneratorRequest Records", "html": "<emu-clause id=\"sec-asyncgeneratorrequest-records\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorrequest-records\">#sec-asyncgeneratorrequest-records</span> AsyncGeneratorRequest Records</h1>\n        <p>The AsyncGeneratorRequest is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> value used to store information about how an async generator should be resumed and contains capabilities for fulfilling or rejecting the corresponding promise.</p>\n        <p>They have the following fields:</p>\n        <emu-table caption=\"AsyncGeneratorRequest Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-noid-1\">#table-noid-1</span>: AsyncGeneratorRequest <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> Fields</figcaption>\n          <table>\n            <tbody>\n            <tr>\n              <th>Field Name</th>\n              <th>Value</th>\n              <th>Meaning</th>\n            </tr>\n            <tr>\n              <td>[[Completion]]</td>\n              <td>A <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> record</td>\n              <td>The completion which should be used to resume the async generator.</td>\n            </tr>\n            <tr>\n              <td>[[Capability]]</td>\n              <td>A <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref></td>\n              <td>The promise capabilities associated with this request.</td>\n            </tr>\n            </tbody>\n          </table>\n        </figure></emu-table>\n      </emu-clause>\n\n      "}, "sec-performpromiserace": {"num": "25.6.4.4.1", "title": "#sec-performpromiserace Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiserace\" aoid=\"PerformPromiseRace\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiserace\">#sec-performpromiserace</span> Runtime Semantics: PerformPromiseRace ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseRace takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resultCapability</var>.[[Resolve]], <var>resultCapability</var>.[[Reject]] &#187;).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-asyncfromsynciteratorcontinuation": {"num": "25.1.4.4", "title": "#sec-asyncfromsynciteratorcontinuation AsyncFromSyncIteratorContinuation ( result, promiseCapability )", "html": "<emu-clause id=\"sec-asyncfromsynciteratorcontinuation\" aoid=\"AsyncFromSyncIteratorContinuation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncfromsynciteratorcontinuation\">#sec-asyncfromsynciteratorcontinuation</span> AsyncFromSyncIteratorContinuation ( <var>result</var>, <var>promiseCapability</var> )</h1>\n        <p>The abstract operation AsyncFromSyncIteratorContinuation takes arguments <var>result</var> and <var>promiseCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>). It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>Let <var>done</var> be <emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>done</var>, <var>promiseCapability</var>).</li><li>Let <var>value</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>value</var>, <var>promiseCapability</var>).</li><li>Let <var>valueWrapper</var> be <emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>valueWrapper</var>, <var>promiseCapability</var>).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-async-from-sync-iterator-value-unwrap-functions\" title=\"\"><a href=\"#sec-async-from-sync-iterator-value-unwrap-functions\">Async-from-Sync Iterator Value Unwrap Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[Done]] &#187;).</li><li>Set <var>onFulfilled</var>.[[Done]] to <var>done</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>valueWrapper</var>, <var>onFulfilled</var>, <emu-val>undefined</emu-val>, <var>promiseCapability</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-performpromisethen": {"num": "25.6.5.4.1", "title": "#sec-performpromisethen PerformPromiseThen ( promise, onFulfilled, onRejected [ , resultCapability ] )", "html": "<emu-clause id=\"sec-performpromisethen\" aoid=\"PerformPromiseThen\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromisethen\">#sec-performpromisethen</span> PerformPromiseThen ( <var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var> [ , <var>resultCapability</var> ] )</h1>\n          <p>The abstract operation PerformPromiseThen takes arguments <var>promise</var>, <var>onFulfilled</var>, and <var>onRejected</var> and optional argument <var>resultCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>). It performs the &#8220;then&#8221; operation on <var>promise</var> using <var>onFulfilled</var> and <var>onRejected</var> as its settlement actions. If <var>resultCapability</var> is passed, the result is stored by updating <var>resultCapability</var>'s promise. If it is not passed, then PerformPromiseThen is being called by a specification-internal operation where the result does not matter. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsPromise\"><a href=\"#sec-ispromise\">IsPromise</a></emu-xref>(<var>promise</var>) is <emu-val>true</emu-val>.</li><li>If <var>resultCapability</var> is not present, then<ol><li>Set <var>resultCapability</var> to <emu-val>undefined</emu-val>.</li></ol></li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>onFulfilled</var>) is <emu-val>false</emu-val>, then<ol><li>Set <var>onFulfilled</var> to <emu-val>undefined</emu-val>.</li></ol></li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>onRejected</var>) is <emu-val>false</emu-val>, then<ol><li>Set <var>onRejected</var> to <emu-val>undefined</emu-val>.</li></ol></li><li>Let <var>fulfillReaction</var> be the PromiseReaction { [[Capability]]: <var>resultCapability</var>, [[Type]]: <emu-const>Fulfill</emu-const>, [[Handler]]: <var>onFulfilled</var> }.</li><li>Let <var>rejectReaction</var> be the PromiseReaction { [[Capability]]: <var>resultCapability</var>, [[Type]]: <emu-const>Reject</emu-const>, [[Handler]]: <var>onRejected</var> }.</li><li>If <var>promise</var>.[[PromiseState]] is <emu-const>pending</emu-const>, then<ol><li>Append <var>fulfillReaction</var> as the last element of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that is <var>promise</var>.[[PromiseFulfillReactions]].</li><li>Append <var>rejectReaction</var> as the last element of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that is <var>promise</var>.[[PromiseRejectReactions]].</li></ol></li><li>Else if <var>promise</var>.[[PromiseState]] is <emu-const>fulfilled</emu-const>, then<ol><li>Let <var>value</var> be <var>promise</var>.[[PromiseResult]].</li><li>Let <var>fulfillJob</var> be <emu-xref aoid=\"NewPromiseReactionJob\"><a href=\"#sec-newpromisereactionjob\">NewPromiseReactionJob</a></emu-xref>(<var>fulfillReaction</var>, <var>value</var>).</li><li>Perform <emu-xref aoid=\"HostEnqueuePromiseJob\"><a href=\"#sec-hostenqueuepromisejob\">HostEnqueuePromiseJob</a></emu-xref>(<var>fulfillJob</var>.[[Job]], <var>fulfillJob</var>.[[Realm]]).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The value of <var>promise</var>.[[PromiseState]] is <emu-const>rejected</emu-const>.</li><li>Let <var>reason</var> be <var>promise</var>.[[PromiseResult]].</li><li>If <var>promise</var>.[[PromiseIsHandled]] is <emu-val>false</emu-val>, perform <emu-xref aoid=\"HostPromiseRejectionTracker\"><a href=\"#sec-host-promise-rejection-tracker\">HostPromiseRejectionTracker</a></emu-xref>(<var>promise</var>, <emu-val>\"handle\"</emu-val>).</li><li>Let <var>rejectJob</var> be <emu-xref aoid=\"NewPromiseReactionJob\"><a href=\"#sec-newpromisereactionjob\">NewPromiseReactionJob</a></emu-xref>(<var>rejectReaction</var>, <var>reason</var>).</li><li>Perform <emu-xref aoid=\"HostEnqueuePromiseJob\"><a href=\"#sec-hostenqueuepromisejob\">HostEnqueuePromiseJob</a></emu-xref>(<var>rejectJob</var>.[[Job]], <var>rejectJob</var>.[[Realm]]).</li></ol></li><li>Set <var>promise</var>.[[PromiseIsHandled]] to <emu-val>true</emu-val>.</li><li>If <var>resultCapability</var> is <emu-val>undefined</emu-val>, then<ol><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Else,<ol><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-performpromiseall": {"num": "25.6.4.1.2", "title": "#sec-performpromiseall Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiseall\" aoid=\"PerformPromiseAll\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseall\">#sec-performpromiseall</span> Runtime Semantics: PerformPromiseAll ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseAll takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var> (a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>), and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.all-resolve-element-functions\"><code>Promise.all</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>resultCapability</var>.[[Reject]] &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-ifabruptrejectpromise": {"num": "25.6.1.1.1", "title": "#sec-ifabruptrejectpromise IfAbruptRejectPromise ( value, capability )", "html": "<emu-clause id=\"sec-ifabruptrejectpromise\" aoid=\"IfAbruptRejectPromise\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ifabruptrejectpromise\">#sec-ifabruptrejectpromise</span> IfAbruptRejectPromise ( <var>value</var>, <var>capability</var> )</h1>\n          <p>IfAbruptRejectPromise is a shorthand for a sequence of algorithm steps that use a <emu-xref href=\"#sec-promisecapability-records\"><a href=\"#sec-promisecapability-records\">PromiseCapability Record</a></emu-xref>. An algorithm step of the form:</p>\n          <emu-alg><ol><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>value</var>, <var>capability</var>).</li></ol></emu-alg>\n          <p>means the same thing as:</p>\n          <emu-alg><ol><li>If <var>value</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>capability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>value</var>.[[Value]] &#187;).</li><li>Return <var>capability</var>.[[Promise]].</li></ol></li><li>Else if <var>value</var> is a <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref>, set <var>value</var> to <var>value</var>.[[Value]].</li></ol></emu-alg>\n        </emu-clause>\n      "}}, "figData": {"table-5": "Table 6", "table-noid-1": "Table 75", "table-57": "Table 76", "table-58": "Table 77"}}}