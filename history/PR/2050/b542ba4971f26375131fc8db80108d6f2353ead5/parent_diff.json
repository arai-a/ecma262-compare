{"from": {"secList": ["sec-newpromisereactionjob", "sec-asyncgeneratorreject", "sec-promise.allsettled-resolve-element-functions", "sec-asyncgeneratorresolve", "sec-asyncfromsynciteratorcontinuation", "sec-promise.all-resolve-element-functions", "sec-promise.allsettled-reject-element-functions", "sec-async-functions-abstract-operations-async-function-start", "sec-finishdynamicimport"], "secData": {"sec-newpromisereactionjob": {"num": "25.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\">\n        <span id=\"sec-promisereactionjob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncgeneratorreject": {"num": "25.5.3.4", "title": "#sec-asyncgeneratorreject AsyncGeneratorReject ( generator, exception )", "html": "<emu-clause id=\"sec-asyncgeneratorreject\" aoid=\"AsyncGeneratorReject\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorreject\">#sec-asyncgeneratorreject</span> AsyncGeneratorReject ( <var>generator</var>, <var>exception</var> )</h1>\n        <p>The abstract operation AsyncGeneratorReject takes arguments <var>generator</var> and <var>exception</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var> is an AsyncGenerator instance.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>queue</var> is not an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Remove the first element from <var>queue</var> and let <var>next</var> be the value of that element.</li><li>Let <var>promiseCapability</var> be <var>next</var>.[[Capability]].</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>exception</var> &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref>(<var>generator</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-promise.allsettled-resolve-element-functions": {"num": "25.6.4.2.2", "title": "#sec-promise.allsettled-resolve-element-functions Promise.allSettled Resolve Element Functions", "html": "<emu-clause id=\"sec-promise.allsettled-resolve-element-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.allsettled-resolve-element-functions\">#sec-promise.allsettled-resolve-element-functions</span> <code>Promise.allSettled</code> Resolve Element Functions</h1>\n          <p>A <code>Promise.allSettled</code> resolve element function is an anonymous built-in function that is used to resolve a specific <code>Promise.allSettled</code> element. Each <code>Promise.allSettled</code> resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>\n          <p>When a <code>Promise.allSettled</code> resolve element function is called with argument <var>x</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>alreadyCalled</var> be <var>F</var>.[[AlreadyCalled]].</li><li>If <var>alreadyCalled</var>.[[Value]] is <emu-val>true</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Set <var>alreadyCalled</var>.[[Value]] to <emu-val>true</emu-val>.</li><li>Let <var>index</var> be <var>F</var>.[[Index]].</li><li>Let <var>values</var> be <var>F</var>.[[Values]].</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li>Let <var>remainingElementsCount</var> be <var>F</var>.[[RemainingElements]].</li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%Object.prototype%).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"status\"</emu-val>, <emu-val>\"fulfilled\"</emu-val>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"value\"</emu-val>, <var>x</var>).</li><li>Set <var>values</var>[<var>index</var>] to <var>obj</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a <code>Promise.allSettled</code> resolve element function is 1.</p>\n        </emu-clause>\n\n        "}, "sec-asyncgeneratorresolve": {"num": "25.5.3.3", "title": "#sec-asyncgeneratorresolve AsyncGeneratorResolve ( generator, value, done )", "html": "<emu-clause id=\"sec-asyncgeneratorresolve\" aoid=\"AsyncGeneratorResolve\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorresolve\">#sec-asyncgeneratorresolve</span> AsyncGeneratorResolve ( <var>generator</var>, <var>value</var>, <var>done</var> )</h1>\n        <p>The abstract operation AsyncGeneratorResolve takes arguments <var>generator</var>, <var>value</var>, and <var>done</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var> is an AsyncGenerator instance.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>queue</var> is not an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Remove the first element from <var>queue</var> and let <var>next</var> be the value of that element.</li><li>Let <var>promiseCapability</var> be <var>next</var>.[[Capability]].</li><li>Let <var>iteratorResult</var> be !&#160;<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <var>done</var>).</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>iteratorResult</var> &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref>(<var>generator</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncfromsynciteratorcontinuation": {"num": "25.1.4.4", "title": "#sec-asyncfromsynciteratorcontinuation AsyncFromSyncIteratorContinuation ( result, promiseCapability )", "html": "<emu-clause id=\"sec-asyncfromsynciteratorcontinuation\" aoid=\"AsyncFromSyncIteratorContinuation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncfromsynciteratorcontinuation\">#sec-asyncfromsynciteratorcontinuation</span> AsyncFromSyncIteratorContinuation ( <var>result</var>, <var>promiseCapability</var> )</h1>\n        <p>The abstract operation AsyncFromSyncIteratorContinuation takes arguments <var>result</var> and <var>promiseCapability</var>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>Let <var>done</var> be <emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>done</var>, <var>promiseCapability</var>).</li><li>Let <var>value</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>value</var>, <var>promiseCapability</var>).</li><li>Let <var>valueWrapper</var> be <emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>valueWrapper</var>, <var>promiseCapability</var>).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-async-from-sync-iterator-value-unwrap-functions\" title=\"\"><a href=\"#sec-async-from-sync-iterator-value-unwrap-functions\">Async-from-Sync Iterator Value Unwrap Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[Done]] &#187;).</li><li>Set <var>onFulfilled</var>.[[Done]] to <var>done</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>valueWrapper</var>, <var>onFulfilled</var>, <emu-val>undefined</emu-val>, <var>promiseCapability</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-promise.all-resolve-element-functions": {"num": "25.6.4.1.3", "title": "#sec-promise.all-resolve-element-functions Promise.all Resolve Element Functions", "html": "<emu-clause id=\"sec-promise.all-resolve-element-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.all-resolve-element-functions\">#sec-promise.all-resolve-element-functions</span> <code>Promise.all</code> Resolve Element Functions</h1>\n          <p>A <code>Promise.all</code> resolve element function is an anonymous built-in function that is used to resolve a specific <code>Promise.all</code> element. Each <code>Promise.all</code> resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>\n          <p>When a <code>Promise.all</code> resolve element function is called with argument <var>x</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>alreadyCalled</var> be <var>F</var>.[[AlreadyCalled]].</li><li>If <var>alreadyCalled</var>.[[Value]] is <emu-val>true</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Set <var>alreadyCalled</var>.[[Value]] to <emu-val>true</emu-val>.</li><li>Let <var>index</var> be <var>F</var>.[[Index]].</li><li>Let <var>values</var> be <var>F</var>.[[Values]].</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li>Let <var>remainingElementsCount</var> be <var>F</var>.[[RemainingElements]].</li><li>Set <var>values</var>[<var>index</var>] to <var>x</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a <code>Promise.all</code> resolve element function is 1.</p>\n        </emu-clause>\n      "}, "sec-promise.allsettled-reject-element-functions": {"num": "25.6.4.2.3", "title": "#sec-promise.allsettled-reject-element-functions Promise.allSettled Reject Element Functions", "html": "<emu-clause id=\"sec-promise.allsettled-reject-element-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.allsettled-reject-element-functions\">#sec-promise.allsettled-reject-element-functions</span> <code>Promise.allSettled</code> Reject Element Functions</h1>\n          <p>A <code>Promise.allSettled</code> reject element function is an anonymous built-in function that is used to reject a specific <code>Promise.allSettled</code> element. Each <code>Promise.allSettled</code> reject element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>\n          <p>When a <code>Promise.allSettled</code> reject element function is called with argument <var>x</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>alreadyCalled</var> be <var>F</var>.[[AlreadyCalled]].</li><li>If <var>alreadyCalled</var>.[[Value]] is <emu-val>true</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Set <var>alreadyCalled</var>.[[Value]] to <emu-val>true</emu-val>.</li><li>Let <var>index</var> be <var>F</var>.[[Index]].</li><li>Let <var>values</var> be <var>F</var>.[[Values]].</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li>Let <var>remainingElementsCount</var> be <var>F</var>.[[RemainingElements]].</li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%Object.prototype%).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"status\"</emu-val>, <emu-val>\"rejected\"</emu-val>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"reason\"</emu-val>, <var>x</var>).</li><li>Set <var>values</var>[<var>index</var>] to <var>obj</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a <code>Promise.allSettled</code> reject element function is 1.</p>\n        </emu-clause>\n      "}, "sec-async-functions-abstract-operations-async-function-start": {"num": "25.7.5.1", "title": "#sec-async-functions-abstract-operations-async-function-start AsyncFunctionStart ( promiseCapability, asyncFunctionBody )", "html": "<emu-clause id=\"sec-async-functions-abstract-operations-async-function-start\" aoid=\"AsyncFunctionStart\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-functions-abstract-operations-async-function-start\">#sec-async-functions-abstract-operations-async-function-start</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>\n        <p>The abstract operation AsyncFunctionStart takes arguments <var>promiseCapability</var> and <var>asyncFunctionBody</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>runningContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li>NOTE: Copying the execution state is required for the step below to resume its execution. It is ill-defined to resume a currently executing context.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> or, if the async function doesn't await anything, step 4.g above.</li><li>Return.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport Runtime Semantics: FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> Runtime Semantics: FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by host environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-newpromisereactionjob", "sec-asyncgeneratorreject", "sec-promise.allsettled-resolve-element-functions", "sec-asyncgeneratorresolve", "sec-asyncfromsynciteratorcontinuation", "sec-promise.all-resolve-element-functions", "sec-promise.allsettled-reject-element-functions", "sec-async-functions-abstract-operations-async-function-start", "sec-finishdynamicimport"], "secData": {"sec-newpromisereactionjob": {"num": "25.6.2.1", "title": "#sec-newpromisereactionjob NewPromiseReactionJob ( reaction, argument )", "html": "<emu-clause id=\"sec-newpromisereactionjob\" aoid=\"NewPromiseReactionJob\" oldids=\"sec-promisereactionjob\">\n        <span id=\"sec-promisereactionjob\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-newpromisereactionjob\">#sec-newpromisereactionjob</span> NewPromiseReactionJob ( <var>reaction</var>, <var>argument</var> )</h1>\n        <p>The abstract operation NewPromiseReactionJob takes arguments <var>reaction</var> and <var>argument</var>. It returns a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that applies the appropriate handler to the incoming value, and uses the handler's return value to resolve or reject the derived promise associated with that handler. It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>job</var> be a new <emu-xref href=\"#job\"><a href=\"#job\">Job</a></emu-xref> <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures <var>reaction</var> and <var>argument</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>reaction</var> is a PromiseReaction <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseCapability</var> be <var>reaction</var>.[[Capability]].</li><li>Let <var>type</var> be <var>reaction</var>.[[Type]].</li><li>Let <var>handler</var> be <var>reaction</var>.[[Handler]].</li><li>If <var>handler</var> is <emu-val>undefined</emu-val>, then<ol><li>If <var>type</var> is <emu-const>Fulfill</emu-const>, let <var>handlerResult</var> be <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>argument</var>).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>type</var> is <emu-const>Reject</emu-const>.</li><li>Let <var>handlerResult</var> be <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>argument</var>).</li></ol></li></ol></li><li>Else, let <var>handlerResult</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>handler</var>, <emu-val>undefined</emu-val>, &#171; <var>argument</var> &#187;).</li><li>If <var>promiseCapability</var> is <emu-val>undefined</emu-val>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>handlerResult</var> is not an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>If <var>handlerResult</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li>Let <var>status</var> be <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>handlerResult</var>.[[Value]] &#187;).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>Let <var>handlerRealm</var> be <emu-val>null</emu-val>.</li><li>If <var>reaction</var>.[[Handler]] is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>getHandlerRealmResult</var> be <emu-xref aoid=\"GetFunctionRealm\"><a href=\"#sec-getfunctionrealm\">GetFunctionRealm</a></emu-xref>(<var>reaction</var>.[[Handler]]).</li><li>If <var>getHandlerRealmResult</var> is a normal completion, then set <var>handlerRealm</var> to <var>getHandlerRealmResult</var>.[[Value]].</li></ol></li><li>Return the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Job]]: <var>job</var>, [[Realm]]: <var>handlerRealm</var> }.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncgeneratorreject": {"num": "25.5.3.4", "title": "#sec-asyncgeneratorreject AsyncGeneratorReject ( generator, exception )", "html": "<emu-clause id=\"sec-asyncgeneratorreject\" aoid=\"AsyncGeneratorReject\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorreject\">#sec-asyncgeneratorreject</span> AsyncGeneratorReject ( <var>generator</var>, <var>exception</var> )</h1>\n        <p>The abstract operation AsyncGeneratorReject takes arguments <var>generator</var> and <var>exception</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var> is an AsyncGenerator instance.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>queue</var> is not an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Remove the first element from <var>queue</var> and let <var>next</var> be the value of that element.</li><li>Let <var>promiseCapability</var> be <var>next</var>.[[Capability]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>exception</var> &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref>(<var>generator</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-promise.allsettled-resolve-element-functions": {"num": "25.6.4.2.2", "title": "#sec-promise.allsettled-resolve-element-functions Promise.allSettled Resolve Element Functions", "html": "<emu-clause id=\"sec-promise.allsettled-resolve-element-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.allsettled-resolve-element-functions\">#sec-promise.allsettled-resolve-element-functions</span> <code>Promise.allSettled</code> Resolve Element Functions</h1>\n          <p>A <code>Promise.allSettled</code> resolve element function is an anonymous built-in function that is used to resolve a specific <code>Promise.allSettled</code> element. Each <code>Promise.allSettled</code> resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>\n          <p>When a <code>Promise.allSettled</code> resolve element function is called with argument <var>x</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>alreadyCalled</var> be <var>F</var>.[[AlreadyCalled]].</li><li>If <var>alreadyCalled</var>.[[Value]] is <emu-val>true</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Set <var>alreadyCalled</var>.[[Value]] to <emu-val>true</emu-val>.</li><li>Let <var>index</var> be <var>F</var>.[[Index]].</li><li>Let <var>values</var> be <var>F</var>.[[Values]].</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be <var>F</var>.[[RemainingElements]].</li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%Object.prototype%).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"status\"</emu-val>, <emu-val>\"fulfilled\"</emu-val>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"value\"</emu-val>, <var>x</var>).</li><li>Set <var>values</var>[<var>index</var>] to <var>obj</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a <code>Promise.allSettled</code> resolve element function is 1.</p>\n        </emu-clause>\n\n        "}, "sec-asyncgeneratorresolve": {"num": "25.5.3.3", "title": "#sec-asyncgeneratorresolve AsyncGeneratorResolve ( generator, value, done )", "html": "<emu-clause id=\"sec-asyncgeneratorresolve\" aoid=\"AsyncGeneratorResolve\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorresolve\">#sec-asyncgeneratorresolve</span> AsyncGeneratorResolve ( <var>generator</var>, <var>value</var>, <var>done</var> )</h1>\n        <p>The abstract operation AsyncGeneratorResolve takes arguments <var>generator</var>, <var>value</var>, and <var>done</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var> is an AsyncGenerator instance.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>queue</var> is not an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Remove the first element from <var>queue</var> and let <var>next</var> be the value of that element.</li><li>Let <var>promiseCapability</var> be <var>next</var>.[[Capability]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>iteratorResult</var> be !&#160;<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <var>done</var>).</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>iteratorResult</var> &#187;).</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref>(<var>generator</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-asyncfromsynciteratorcontinuation": {"num": "25.1.4.4", "title": "#sec-asyncfromsynciteratorcontinuation AsyncFromSyncIteratorContinuation ( result, promiseCapability )", "html": "<emu-clause id=\"sec-asyncfromsynciteratorcontinuation\" aoid=\"AsyncFromSyncIteratorContinuation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncfromsynciteratorcontinuation\">#sec-asyncfromsynciteratorcontinuation</span> AsyncFromSyncIteratorContinuation ( <var>result</var>, <var>promiseCapability</var> )</h1>\n        <p>The abstract operation AsyncFromSyncIteratorContinuation takes arguments <var>result</var> and <var>promiseCapability</var>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>done</var> be <emu-xref aoid=\"IteratorComplete\"><a href=\"#sec-iteratorcomplete\">IteratorComplete</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>done</var>, <var>promiseCapability</var>).</li><li>Let <var>value</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>value</var>, <var>promiseCapability</var>).</li><li>Let <var>valueWrapper</var> be <emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>valueWrapper</var>, <var>promiseCapability</var>).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-async-from-sync-iterator-value-unwrap-functions\" title=\"\"><a href=\"#sec-async-from-sync-iterator-value-unwrap-functions\">Async-from-Sync Iterator Value Unwrap Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[Done]] &#187;).</li><li>Set <var>onFulfilled</var>.[[Done]] to <var>done</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>valueWrapper</var>, <var>onFulfilled</var>, <emu-val>undefined</emu-val>, <var>promiseCapability</var>).</li><li>Return <var>promiseCapability</var>.[[Promise]].</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-promise.all-resolve-element-functions": {"num": "25.6.4.1.3", "title": "#sec-promise.all-resolve-element-functions Promise.all Resolve Element Functions", "html": "<emu-clause id=\"sec-promise.all-resolve-element-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.all-resolve-element-functions\">#sec-promise.all-resolve-element-functions</span> <code>Promise.all</code> Resolve Element Functions</h1>\n          <p>A <code>Promise.all</code> resolve element function is an anonymous built-in function that is used to resolve a specific <code>Promise.all</code> element. Each <code>Promise.all</code> resolve element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>\n          <p>When a <code>Promise.all</code> resolve element function is called with argument <var>x</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>alreadyCalled</var> be <var>F</var>.[[AlreadyCalled]].</li><li>If <var>alreadyCalled</var>.[[Value]] is <emu-val>true</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Set <var>alreadyCalled</var>.[[Value]] to <emu-val>true</emu-val>.</li><li>Let <var>index</var> be <var>F</var>.[[Index]].</li><li>Let <var>values</var> be <var>F</var>.[[Values]].</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be <var>F</var>.[[RemainingElements]].</li><li>Set <var>values</var>[<var>index</var>] to <var>x</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a <code>Promise.all</code> resolve element function is 1.</p>\n        </emu-clause>\n      "}, "sec-promise.allsettled-reject-element-functions": {"num": "25.6.4.2.3", "title": "#sec-promise.allsettled-reject-element-functions Promise.allSettled Reject Element Functions", "html": "<emu-clause id=\"sec-promise.allsettled-reject-element-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.allsettled-reject-element-functions\">#sec-promise.allsettled-reject-element-functions</span> <code>Promise.allSettled</code> Reject Element Functions</h1>\n          <p>A <code>Promise.allSettled</code> reject element function is an anonymous built-in function that is used to reject a specific <code>Promise.allSettled</code> element. Each <code>Promise.allSettled</code> reject element function has [[Index]], [[Values]], [[Capability]], [[RemainingElements]], and [[AlreadyCalled]] internal slots.</p>\n          <p>When a <code>Promise.allSettled</code> reject element function is called with argument <var>x</var>, the following steps are taken:</p>\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>alreadyCalled</var> be <var>F</var>.[[AlreadyCalled]].</li><li>If <var>alreadyCalled</var>.[[Value]] is <emu-val>true</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Set <var>alreadyCalled</var>.[[Value]] to <emu-val>true</emu-val>.</li><li>Let <var>index</var> be <var>F</var>.[[Index]].</li><li>Let <var>values</var> be <var>F</var>.[[Values]].</li><li>Let <var>promiseCapability</var> be <var>F</var>.[[Capability]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be <var>F</var>.[[RemainingElements]].</li><li>Let <var>obj</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(%Object.prototype%).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"status\"</emu-val>, <emu-val>\"rejected\"</emu-val>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>obj</var>, <emu-val>\"reason\"</emu-val>, <var>x</var>).</li><li>Set <var>values</var>[<var>index</var>] to <var>obj</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Return ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n          <p>The <emu-val>\"length\"</emu-val> property of a <code>Promise.allSettled</code> reject element function is 1.</p>\n        </emu-clause>\n      "}, "sec-async-functions-abstract-operations-async-function-start": {"num": "25.7.5.1", "title": "#sec-async-functions-abstract-operations-async-function-start AsyncFunctionStart ( promiseCapability, asyncFunctionBody )", "html": "<emu-clause id=\"sec-async-functions-abstract-operations-async-function-start\" aoid=\"AsyncFunctionStart\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-functions-abstract-operations-async-function-start\">#sec-async-functions-abstract-operations-async-function-start</span> AsyncFunctionStart ( <var>promiseCapability</var>, <var>asyncFunctionBody</var> )</h1>\n        <p>The abstract operation AsyncFunctionStart takes arguments <var>promiseCapability</var> and <var>asyncFunctionBody</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>runningContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>asyncContext</var> be a copy of <var>runningContext</var>.</li><li>NOTE: Copying the execution state is required for the step below to resume its execution. It is ill-defined to resume a currently executing context.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed for that <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> the following steps will be performed:<ol><li>Let <var>result</var> be the result of evaluating <var>asyncFunctionBody</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>If <var>result</var>.[[Type]] is <emu-const>normal</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <emu-val>undefined</emu-val> &#187;).</li></ol></li><li>Else if <var>result</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>result</var>.[[Value]] &#187;).</li></ol></li><li>Return.</li></ol></li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var>. Let <var>result</var> be the value returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>runningContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is a normal completion with a value of <emu-val>undefined</emu-val>. The possible sources of completion values are <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> or, if the async function doesn't await anything, step 4.g above.</li><li>Return.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport Runtime Semantics: FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> Runtime Semantics: FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by host environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>promiseCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {}}}