{"from": {"secList": ["sec-atomics.compareexchange"], "secData": {"sec-atomics.compareexchange": {"num": "24.4.4", "title": "#sec-atomics.compareexchange Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )", "html": "<emu-clause id=\"sec-atomics.compareexchange\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atomics.compareexchange\">#sec-atomics.compareexchange</span> Atomics.compareExchange ( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</h1>\n      <p>The following steps are taken:</p>\n      <emu-alg><ol><li>Let <var>buffer</var> be ?&#160;<emu-xref aoid=\"ValidateIntegerTypedArray\"><a href=\"#sec-validateintegertypedarray\">ValidateIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>indexedPosition</var> be ?&#160;<emu-xref aoid=\"ValidateAtomicAccess\"><a href=\"#sec-validateatomicaccess\">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>If <var>typedArray</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, then<ol><li>Let <var>expected</var> be ?&#160;<emu-xref aoid=\"ToBigInt\"><a href=\"#sec-tobigint\">ToBigInt</a></emu-xref>(<var>expectedValue</var>).</li><li>Let <var>replacement</var> be ?&#160;<emu-xref aoid=\"ToBigInt\"><a href=\"#sec-tobigint\">ToBigInt</a></emu-xref>(<var>replacementValue</var>).</li></ol></li><li>Else,<ol><li>Let <var>expected</var> be <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(? <emu-xref aoid=\"ToIntegerOrInfinity\"><a href=\"#sec-tointegerorinfinity\">ToIntegerOrInfinity</a></emu-xref>(<var>expectedValue</var>)).</li><li>Let <var>replacement</var> be <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(? <emu-xref aoid=\"ToIntegerOrInfinity\"><a href=\"#sec-tointegerorinfinity\">ToIntegerOrInfinity</a></emu-xref>(<var>replacementValue</var>)).</li></ol></li><li>If <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: The above check is not redundant with the check in <emu-xref aoid=\"ValidateIntegerTypedArray\"><a href=\"#sec-validateintegertypedarray\">ValidateIntegerTypedArray</a></emu-xref> because the call to <emu-xref aoid=\"ToBigInt\"><a href=\"#sec-tobigint\">ToBigInt</a></emu-xref> or <emu-xref aoid=\"ToIntegerOrInfinity\"><a href=\"#sec-tointegerorinfinity\">ToIntegerOrInfinity</a></emu-xref> on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached.</li><li>Let <var>elementType</var> be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>expectedBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>elementType</var>, <var>expected</var>, <var>isLittleEndian</var>).</li><li>Let <var>compareExchange</var> be a new <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> with parameters (<var>oldBytes</var>, <var>newBytes</var>) that captures <var>expectedBytes</var> and performs the following steps atomically when called:<ol><li>If <emu-xref aoid=\"ByteListEqual\"><a href=\"#sec-bytelistequal\">ByteListEqual</a></emu-xref>(<var>oldBytes</var>, <var>expectedBytes</var>) is <emu-val>true</emu-val>, return <var>newBytes</var>.</li><li>Return <var>oldBytes</var>.</li></ol></li><li>Return <emu-xref aoid=\"GetModifySetValueInBuffer\"><a href=\"#sec-getmodifysetvalueinbuffer\">GetModifySetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>replacement</var>, <var>compareExchange</var>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}}, "figData": {"table-the-typedarray-constructors": "Table 63"}}, "to": {"secList": ["sec-atomics.compareexchange"], "secData": {"sec-atomics.compareexchange": {"num": "24.4.4", "title": "#sec-atomics.compareexchange Atomics.compareExchange ( typedArray, index, expectedValue, replacementValue )", "html": "<emu-clause id=\"sec-atomics.compareexchange\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atomics.compareexchange\">#sec-atomics.compareexchange</span> Atomics.compareExchange ( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</h1>\n      <p>The following steps are taken:</p>\n      <emu-alg><ol><li>Let <var>buffer</var> be ?&#160;<emu-xref aoid=\"ValidateIntegerTypedArray\"><a href=\"#sec-validateintegertypedarray\">ValidateIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>block</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>indexedPosition</var> be ?&#160;<emu-xref aoid=\"ValidateAtomicAccess\"><a href=\"#sec-validateatomicaccess\">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>If <var>typedArray</var>.[[ContentType]] is <emu-const>BigInt</emu-const>, then<ol><li>Let <var>expected</var> be ?&#160;<emu-xref aoid=\"ToBigInt\"><a href=\"#sec-tobigint\">ToBigInt</a></emu-xref>(<var>expectedValue</var>).</li><li>Let <var>replacement</var> be ?&#160;<emu-xref aoid=\"ToBigInt\"><a href=\"#sec-tobigint\">ToBigInt</a></emu-xref>(<var>replacementValue</var>).</li></ol></li><li>Else,<ol><li>Let <var>expected</var> be <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(? <emu-xref aoid=\"ToIntegerOrInfinity\"><a href=\"#sec-tointegerorinfinity\">ToIntegerOrInfinity</a></emu-xref>(<var>expectedValue</var>)).</li><li>Let <var>replacement</var> be <emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(? <emu-xref aoid=\"ToIntegerOrInfinity\"><a href=\"#sec-tointegerorinfinity\">ToIntegerOrInfinity</a></emu-xref>(<var>replacementValue</var>)).</li></ol></li><li>If <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>NOTE: The above check is not redundant with the check in <emu-xref aoid=\"ValidateIntegerTypedArray\"><a href=\"#sec-validateintegertypedarray\">ValidateIntegerTypedArray</a></emu-xref> because the call to <emu-xref aoid=\"ToBigInt\"><a href=\"#sec-tobigint\">ToBigInt</a></emu-xref> or <emu-xref aoid=\"ToIntegerOrInfinity\"><a href=\"#sec-tointegerorinfinity\">ToIntegerOrInfinity</a></emu-xref> on the preceding lines can have arbitrary side effects, which could cause the buffer to become detached.</li><li>Let <var>elementType</var> be the Element Type value in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>elementType</var>.</li><li>Let <var>isLittleEndian</var> be the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>expectedBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>elementType</var>, <var>expected</var>, <var>isLittleEndian</var>).</li><li>Let <var>replacementBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>elementType</var>, <var>replacement</var>, <var>isLittleEndian</var>).</li><li>Let <var>second</var> be a new <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> with parameters (<var>oldBytes</var>, <var>newBytes</var>) that captures nothing and performs the following steps atomically when called:<ol><li>Return <var>newBytes</var>.</li></ol></li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>rawBytesRead</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are nondeterministically chosen byte values.</li><li>NOTE: In implementations, <var>rawBytesRead</var> is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>NOTE: The comparison of the expected value and the read value is performed outside of the <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref> to avoid needlessly strong synchronization when the expected value is not equal to the read value.</li><li>If <emu-xref aoid=\"ByteListEqual\"><a href=\"#sec-bytelistequal\">ByteListEqual</a></emu-xref>(<var>rawBytesRead</var>, <var>expectedBytes</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>event</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadModifyWriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>indexedPosition</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>replacementBytes</var>, [[ModifyOp]]: <var>second</var> }.</li></ol></li><li>Else,<ol><li>Let <var>event</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>indexedPosition</var>, [[ElementSize]]: <var>elementSize</var> }.</li></ol></li><li>Append <var>event</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>event</var>, [[ChosenValue]]: <var>rawBytesRead</var> } to <var>execution</var>.[[ChosenValues]].</li></ol></li><li>Else,<ol><li>Let <var>rawBytesRead</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are the sequence of <var>elementSize</var> bytes starting with <var>block</var>[<var>indexedPosition</var>].</li><li>If <emu-xref aoid=\"ByteListEqual\"><a href=\"#sec-bytelistequal\">ByteListEqual</a></emu-xref>(<var>rawBytesRead</var>, <var>expectedBytes</var>) is <emu-val>true</emu-val>, then<ol><li>Store the individual bytes of <var>replacementBytes</var> into <var>block</var>, starting at <var>block</var>[<var>indexedPosition</var>].</li></ol></li></ol></li><li>Return <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>elementType</var>, <var>rawBytesRead</var>, <var>isLittleEndian</var>).</li></ol></emu-alg>\n    </emu-clause>\n\n    "}}, "figData": {"table-the-typedarray-constructors": "Table 63"}}}