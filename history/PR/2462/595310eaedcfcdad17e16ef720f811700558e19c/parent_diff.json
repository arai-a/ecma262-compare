{"from": {"secList": ["sec-runtime-semantics-classdefinitionevaluation"], "secData": {"sec-runtime-semantics-classdefinitionevaluation": {"num": "15.7.12", "title": "#sec-runtime-semantics-classdefinitionevaluation Runtime Semantics: ClassDefinitionEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-classdefinitionevaluation\" oldids=\"sec-default-constructor-functions\" type=\"sdo\" aoid=\"ClassDefinitionEvaluation\"><span id=\"sec-default-constructor-functions\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-classdefinitionevaluation\">#sec-runtime-semantics-classdefinitionevaluation</span> Runtime Semantics: ClassDefinitionEvaluation</h1>\n      <p>With parameters <var>classBinding</var> and <var>className</var>.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>For ease of specification, private methods and accessors are included alongside private fields in the [[PrivateElements]] slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.</p>\n        <p>For example, an implementation could directly associate instance private methods with their corresponding <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref> and track, for each object, which class constructors have run with that object as their <code>this</code> value. Looking up an instance private method on an object then consists of checking that the class <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> which defines the method has been used to initialize the object, then returning the method associated with the <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref>.</p>\n        <p>This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"ClassTail\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassTail\">ClassTail</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"uopqpdqx\" id=\"prod-AcPtObVs\">\n        <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt>\n        <emu-t>{</emu-t>\n        <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt>\n        <emu-t>}</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Let <var>env</var> be the LexicalEnvironment of the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>classScope</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>env</var>).</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScope</var>.CreateImmutableBinding(<var>classBinding</var>, <emu-val>true</emu-val>).</li></ol></li><li>Let <var>outerPrivateEnvironment</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment.</li><li>Let <var>classPrivateEnvironment</var> be <emu-xref aoid=\"NewPrivateEnvironment\"><a href=\"#sec-newprivateenvironment\">NewPrivateEnvironment</a></emu-xref>(<var>outerPrivateEnvironment</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, then<ol><li>For each String <var>dn</var> of the <emu-xref aoid=\"PrivateBoundIdentifiers\"><a href=\"#sec-static-semantics-privateboundidentifiers\">PrivateBoundIdentifiers</a></emu-xref> of <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt>, do<ol><li>If <var>classPrivateEnvironment</var>.[[Names]] contains a <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref> whose [[Description]] is <var>dn</var>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: This is only possible for getter/setter pairs.</li></ol></li><li>Else,<ol><li>Let <var>name</var> be a new <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref> whose [[Description]] value is <var>dn</var>.</li><li>Append <var>name</var> to <var>classPrivateEnvironment</var>.[[Names]].</li></ol></li></ol></li></ol></li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, then<ol><li>Let <var>protoParent</var> be <emu-xref href=\"#sec-properties-of-the-object-prototype-object\"><a href=\"#sec-properties-of-the-object-prototype-object\">%Object.prototype%</a></emu-xref>.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else,<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>NOTE: The <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment is <var>outerPrivateEnvironment</var> when evaluating <emu-nt><a href=\"#prod-ClassHeritage\">ClassHeritage</a></emu-nt>.</li><li>Let <var>superclassRef</var> be the result of evaluating <emu-nt><a href=\"#prod-ClassHeritage\">ClassHeritage</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>env</var>.</li><li>Let <var>superclass</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>superclassRef</var>).</li><li>If <var>superclass</var> is <emu-val>null</emu-val>, then<ol><li>Let <var>protoParent</var> be <emu-val>null</emu-val>.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else if <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>superclass</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Else,<ol><li>Let <var>protoParent</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>superclass</var>, <emu-val>\"prototype\"</emu-val>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>protoParent</var>) is neither Object nor Null, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorParent</var> be <var>superclass</var>.</li></ol></li></ol></li><li>Let <var>proto</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<var>protoParent</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>constructor</var> be <emu-const>empty</emu-const>.</li><li>Else, let <var>constructor</var> be <emu-xref aoid=\"ConstructorMethod\"><a href=\"#sec-static-semantics-constructormethod\">ConstructorMethod</a></emu-xref> of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>classPrivateEnvironment</var>.</li><li>If <var>constructor</var> is <emu-const>empty</emu-const>, then<ol><li>Let <var>defaultConstructor</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures nothing and performs the following steps when called:<ol><li>Let <var>args</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of arguments that was passed to this function by [[Call]] or [[Construct]].</li><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>If <var>F</var>.[[ConstructorKind]] is <emu-const>derived</emu-const>, then<ol><li>NOTE: This branch behaves similarly to <code>constructor(...args) { super(...args); }</code>. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the <emu-xref href=\"#sec-well-known-symbols\"><a href=\"#sec-well-known-symbols\">@@iterator</a></emu-xref> method on <code>%Array.prototype%</code>, this function does not.</li><li>Let <var>func</var> be ! <var>F</var>.[[GetPrototypeOf]]().</li><li>If <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>func</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return ?&#160;<emu-xref aoid=\"Construct\"><a href=\"#sec-construct\">Construct</a></emu-xref>(<var>func</var>, <var>args</var>, NewTarget).</li></ol></li><li>Else,<ol><li>NOTE: This branch behaves similarly to <code>constructor() {}</code>.</li><li>Return ?&#160;<emu-xref aoid=\"OrdinaryCreateFromConstructor\"><a href=\"#sec-ordinarycreatefromconstructor\">OrdinaryCreateFromConstructor</a></emu-xref>(NewTarget, <emu-val>\"%Object.prototype%\"</emu-val>).</li></ol></li></ol></li><li>Let <var>F</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>defaultConstructor</var>, 0, <var>className</var>, &#171; [[ConstructorKind]], [[SourceText]] &#187;, <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>, <var>constructorParent</var>).</li></ol></li><li>Else,<ol><li>Let <var>constructorInfo</var> be ! <emu-xref aoid=\"DefineMethod\"><a href=\"#sec-runtime-semantics-definemethod\">DefineMethod</a></emu-xref> of <var>constructor</var> with arguments <var>proto</var> and <var>constructorParent</var>.</li><li>Let <var>F</var> be <var>constructorInfo</var>.[[Closure]].</li><li>Perform !&#160;<emu-xref aoid=\"MakeClassConstructor\"><a href=\"#sec-makeclassconstructor\">MakeClassConstructor</a></emu-xref>(<var>F</var>).</li><li>Perform !&#160;<emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>F</var>, <var>className</var>).</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"MakeConstructor\"><a href=\"#sec-makeconstructor\">MakeConstructor</a></emu-xref>(<var>F</var>, <emu-val>false</emu-val>, <var>proto</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, set <var>F</var>.[[ConstructorKind]] to <emu-const>derived</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"CreateMethodProperty\"><a href=\"#sec-createmethodproperty\">CreateMethodProperty</a></emu-xref>(<var>proto</var>, <emu-val>\"constructor\"</emu-val>, <var>F</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>elements</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Else, let <var>elements</var> be <emu-xref aoid=\"NonConstructorElements\"><a href=\"#sec-static-semantics-nonconstructorelements\">NonConstructorElements</a></emu-xref> of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>Let <var>instancePrivateMethods</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>staticPrivateMethods</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>instanceFields</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>staticFields</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <var>e</var> of <var>elements</var>, do<ol><li>If <emu-xref aoid=\"IsStatic\"><a href=\"#sec-static-semantics-isstatic\">IsStatic</a></emu-xref> of <var>e</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>field</var> be <emu-xref aoid=\"ClassElementEvaluation\"><a href=\"#sec-static-semantics-classelementevaluation\">ClassElementEvaluation</a></emu-xref> of <var>e</var> with arguments <var>proto</var> and <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>Let <var>field</var> be <emu-xref aoid=\"ClassElementEvaluation\"><a href=\"#sec-static-semantics-classelementevaluation\">ClassElementEvaluation</a></emu-xref> of <var>e</var> with arguments <var>F</var> and <emu-val>false</emu-val>.</li></ol></li><li>If <var>field</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>env</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>outerPrivateEnvironment</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>field</var>).</li></ol></li><li>Set <var>field</var> to <var>field</var>.[[Value]].</li><li>If <var>field</var> is a <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>field</var>.[[Kind]] is either <emu-const>method</emu-const> or <emu-const>accessor</emu-const>.</li><li>If <emu-xref aoid=\"IsStatic\"><a href=\"#sec-static-semantics-isstatic\">IsStatic</a></emu-xref> of <var>e</var> is <emu-val>false</emu-val>, let <var>container</var> be <var>instancePrivateMethods</var>.</li><li>Else, let <var>container</var> be <var>staticPrivateMethods</var>.</li><li>If <var>container</var> contains a <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> whose [[Key]] is <var>field</var>.[[Key]], then<ol><li>Let <var>existing</var> be that <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>field</var>.[[Kind]] and <var>existing</var>.[[Kind]] are both <emu-const>accessor</emu-const>.</li><li>If <var>field</var>.[[Get]] is <emu-val>undefined</emu-val>, then<ol><li>Let <var>combined</var> be <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> { [[Key]]: <var>field</var>.[[Key]], [[Kind]]: <emu-const>accessor</emu-const>, [[Get]]: <var>existing</var>.[[Get]], [[Set]]: <var>field</var>.[[Set]] }.</li></ol></li><li>Else,<ol><li>Let <var>combined</var> be <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> { [[Key]]: <var>field</var>.[[Key]], [[Kind]]: <emu-const>accessor</emu-const>, [[Get]]: <var>field</var>.[[Get]], [[Set]]: <var>existing</var>.[[Set]] }.</li></ol></li><li>Replace <var>existing</var> in <var>container</var> with <var>combined</var>.</li></ol></li><li>Else,<ol><li>Append <var>field</var> to <var>container</var>.</li></ol></li></ol></li><li>Else if <var>field</var> is a <emu-xref href=\"#sec-classfielddefinition-record-specification-type\"><a href=\"#sec-classfielddefinition-record-specification-type\">ClassFieldDefinition Record</a></emu-xref>, then<ol><li>If <emu-xref aoid=\"IsStatic\"><a href=\"#sec-static-semantics-isstatic\">IsStatic</a></emu-xref> of <var>e</var> is <emu-val>false</emu-val>, append <var>field</var> to <var>instanceFields</var>.</li><li>Else, append <var>field</var> to <var>staticFields</var>.</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>env</var>.</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScope</var>.InitializeBinding(<var>classBinding</var>, <var>F</var>).</li></ol></li><li>Set <var>F</var>.[[PrivateMethods]] to <var>instancePrivateMethods</var>.</li><li>Set <var>F</var>.[[Fields]] to <var>instanceFields</var>.</li><li>For each <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> <var>method</var> of <var>staticPrivateMethods</var>, do<ol><li>Perform !&#160;<emu-xref aoid=\"PrivateMethodOrAccessorAdd\"><a href=\"#sec-privatemethodoraccessoradd\">PrivateMethodOrAccessorAdd</a></emu-xref>(<var>method</var>, <var>F</var>).</li></ol></li><li>For each element <var>fieldRecord</var> of <var>staticFields</var>, do<ol><li>Let <var>result</var> be <emu-xref aoid=\"DefineField\"><a href=\"#sec-definefield\">DefineField</a></emu-xref>(<var>F</var>, <var>fieldRecord</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>outerPrivateEnvironment</var>.</li><li>Return <var>result</var>.</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>outerPrivateEnvironment</var>.</li><li>Return <var>F</var>.</li></ol></emu-alg>\n    </emu-clause>\n\n    "}}, "figData": {}}, "to": {"secList": ["sec-runtime-semantics-classdefinitionevaluation"], "secData": {"sec-runtime-semantics-classdefinitionevaluation": {"num": "15.7.12", "title": "#sec-runtime-semantics-classdefinitionevaluation Runtime Semantics: ClassDefinitionEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-classdefinitionevaluation\" oldids=\"sec-default-constructor-functions\" type=\"sdo\" aoid=\"ClassDefinitionEvaluation\"><span id=\"sec-default-constructor-functions\"></span>\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-classdefinitionevaluation\">#sec-runtime-semantics-classdefinitionevaluation</span> Runtime Semantics: ClassDefinitionEvaluation</h1>\n      <p>With parameters <var>classBinding</var> and <var>className</var>.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>For ease of specification, private methods and accessors are included alongside private fields in the [[PrivateElements]] slot of class instances. However, any given object has either all or none of the private methods and accessors defined by a given class. This feature has been designed so that implementations may choose to implement private methods and accessors using a strategy which does not require tracking each method or accessor individually.</p>\n        <p>For example, an implementation could directly associate instance private methods with their corresponding <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref> and track, for each object, which class constructors have run with that object as their <code>this</code> value. Looking up an instance private method on an object then consists of checking that the class <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> which defines the method has been used to initialize the object, then returning the method associated with the <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref>.</p>\n        <p>This differs from private fields: because field initializers can throw during class instantiation, an individual object may have some proper subset of the private fields of a given class, and so private fields must in general be tracked individually.</p>\n      </div></emu-note>\n      <emu-grammar><emu-production name=\"ClassTail\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ClassTail\">ClassTail</a></emu-nt> <emu-geq>:</emu-geq> <emu-rhs a=\"uopqpdqx\" id=\"prod-AcPtObVs\">\n        <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt>\n        <emu-t>{</emu-t>\n        <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt>\n        <emu-t>}</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n      <emu-alg><ol><li>Let <var>env</var> be the LexicalEnvironment of the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>classScope</var> be <emu-xref aoid=\"NewDeclarativeEnvironment\"><a href=\"#sec-newdeclarativeenvironment\">NewDeclarativeEnvironment</a></emu-xref>(<var>env</var>).</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScope</var>.CreateImmutableBinding(<var>classBinding</var>, <emu-val>true</emu-val>).</li></ol></li><li>Let <var>outerPrivateEnvironment</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment.</li><li>Let <var>classPrivateEnvironment</var> be <emu-xref aoid=\"NewPrivateEnvironment\"><a href=\"#sec-newprivateenvironment\">NewPrivateEnvironment</a></emu-xref>(<var>outerPrivateEnvironment</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, then<ol><li>For each String <var>dn</var> of the <emu-xref aoid=\"PrivateBoundIdentifiers\"><a href=\"#sec-static-semantics-privateboundidentifiers\">PrivateBoundIdentifiers</a></emu-xref> of <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt>, do<ol><li>If <var>classPrivateEnvironment</var>.[[Names]] contains a <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref> whose [[Description]] is <var>dn</var>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: This is only possible for getter/setter pairs.</li></ol></li><li>Else,<ol><li>Let <var>name</var> be a new <emu-xref href=\"#sec-private-names\"><a href=\"#sec-private-names\">Private Name</a></emu-xref> whose [[Description]] value is <var>dn</var>.</li><li>Append <var>name</var> to <var>classPrivateEnvironment</var>.[[Names]].</li></ol></li></ol></li></ol></li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, then<ol><li>Let <var>protoParent</var> be <emu-xref href=\"#sec-properties-of-the-object-prototype-object\"><a href=\"#sec-properties-of-the-object-prototype-object\">%Object.prototype%</a></emu-xref>.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else,<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>NOTE: The <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment is <var>outerPrivateEnvironment</var> when evaluating <emu-nt><a href=\"#prod-ClassHeritage\">ClassHeritage</a></emu-nt>.</li><li>Let <var>superclassRef</var> be the result of evaluating <emu-nt><a href=\"#prod-ClassHeritage\">ClassHeritage</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>env</var>.</li><li>Let <var>superclass</var> be ?&#160;<emu-xref aoid=\"GetValue\"><a href=\"#sec-getvalue\">GetValue</a></emu-xref>(<var>superclassRef</var>).</li><li>If <var>superclass</var> is <emu-val>null</emu-val>, then<ol><li>Let <var>protoParent</var> be <emu-val>null</emu-val>.</li><li>Let <var>constructorParent</var> be <emu-xref href=\"#sec-properties-of-the-function-prototype-object\"><a href=\"#sec-properties-of-the-function-prototype-object\">%Function.prototype%</a></emu-xref>.</li></ol></li><li>Else if <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>superclass</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Else,<ol><li>Let <var>protoParent</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>superclass</var>, <emu-val>\"prototype\"</emu-val>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>protoParent</var>) is neither Object nor Null, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>constructorParent</var> be <var>superclass</var>.</li></ol></li></ol></li><li>Let <var>proto</var> be !&#160;<emu-xref aoid=\"OrdinaryObjectCreate\"><a href=\"#sec-ordinaryobjectcreate\">OrdinaryObjectCreate</a></emu-xref>(<var>protoParent</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>constructor</var> be <emu-const>empty</emu-const>.</li><li>Else, let <var>constructor</var> be <emu-xref aoid=\"ConstructorMethod\"><a href=\"#sec-static-semantics-constructormethod\">ConstructorMethod</a></emu-xref> of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>classScope</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>classPrivateEnvironment</var>.</li><li>If <var>constructor</var> is <emu-const>empty</emu-const>, then<ol><li>Let <var>defaultConstructor</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with no parameters that captures nothing and performs the following steps when called:<ol><li>Let <var>args</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of arguments that was passed to this function by [[Call]] or [[Construct]].</li><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>If <var>F</var>.[[ConstructorKind]] is <emu-const>derived</emu-const>, then<ol><li>NOTE: This branch behaves similarly to <code>constructor(...args) { super(...args); }</code>. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the <emu-xref href=\"#sec-well-known-symbols\"><a href=\"#sec-well-known-symbols\">@@iterator</a></emu-xref> method on <code>%Array.prototype%</code>, this function does not.</li><li>Let <var>func</var> be ! <var>F</var>.[[GetPrototypeOf]]().</li><li>If <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>func</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Construct\"><a href=\"#sec-construct\">Construct</a></emu-xref>(<var>func</var>, <var>args</var>, NewTarget).</li></ol></li><li>Else,<ol><li>NOTE: This branch behaves similarly to <code>constructor() {}</code>.</li><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"OrdinaryCreateFromConstructor\"><a href=\"#sec-ordinarycreatefromconstructor\">OrdinaryCreateFromConstructor</a></emu-xref>(NewTarget, <emu-val>\"%Object.prototype%\"</emu-val>).</li></ol></li><li>Perform ?&#160;<emu-xref aoid=\"InitializeInstanceElements\"><a href=\"#sec-initializeinstanceelements\">InitializeInstanceElements</a></emu-xref>(<var>result</var>, <var>F</var>).</li><li>Return <var>result</var>.</li></ol></li><li>Let <var>F</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>defaultConstructor</var>, 0, <var>className</var>, &#171; [[ConstructorKind]], [[SourceText]] &#187;, <emu-xref href=\"#current-realm\"><a href=\"#current-realm\">the current Realm Record</a></emu-xref>, <var>constructorParent</var>).</li></ol></li><li>Else,<ol><li>Let <var>constructorInfo</var> be ! <emu-xref aoid=\"DefineMethod\"><a href=\"#sec-runtime-semantics-definemethod\">DefineMethod</a></emu-xref> of <var>constructor</var> with arguments <var>proto</var> and <var>constructorParent</var>.</li><li>Let <var>F</var> be <var>constructorInfo</var>.[[Closure]].</li><li>Perform !&#160;<emu-xref aoid=\"MakeClassConstructor\"><a href=\"#sec-makeclassconstructor\">MakeClassConstructor</a></emu-xref>(<var>F</var>).</li><li>Perform !&#160;<emu-xref aoid=\"SetFunctionName\"><a href=\"#sec-setfunctionname\">SetFunctionName</a></emu-xref>(<var>F</var>, <var>className</var>).</li></ol></li><li>Perform !&#160;<emu-xref aoid=\"MakeConstructor\"><a href=\"#sec-makeconstructor\">MakeConstructor</a></emu-xref>(<var>F</var>, <emu-val>false</emu-val>, <var>proto</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassHeritage\">ClassHeritage</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is present, set <var>F</var>.[[ConstructorKind]] to <emu-const>derived</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"CreateMethodProperty\"><a href=\"#sec-createmethodproperty\">CreateMethodProperty</a></emu-xref>(<var>proto</var>, <emu-val>\"constructor\"</emu-val>, <var>F</var>).</li><li>If <emu-nt optional=\"\"><a href=\"#prod-ClassBody\">ClassBody</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt> is not present, let <var>elements</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Else, let <var>elements</var> be <emu-xref aoid=\"NonConstructorElements\"><a href=\"#sec-static-semantics-nonconstructorelements\">NonConstructorElements</a></emu-xref> of <emu-nt><a href=\"#prod-ClassBody\">ClassBody</a></emu-nt>.</li><li>Let <var>instancePrivateMethods</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>staticPrivateMethods</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>instanceFields</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>staticFields</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <emu-nt><a href=\"#prod-ClassElement\">ClassElement</a></emu-nt> <var>e</var> of <var>elements</var>, do<ol><li>If <emu-xref aoid=\"IsStatic\"><a href=\"#sec-static-semantics-isstatic\">IsStatic</a></emu-xref> of <var>e</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>field</var> be <emu-xref aoid=\"ClassElementEvaluation\"><a href=\"#sec-static-semantics-classelementevaluation\">ClassElementEvaluation</a></emu-xref> of <var>e</var> with arguments <var>proto</var> and <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>Let <var>field</var> be <emu-xref aoid=\"ClassElementEvaluation\"><a href=\"#sec-static-semantics-classelementevaluation\">ClassElementEvaluation</a></emu-xref> of <var>e</var> with arguments <var>F</var> and <emu-val>false</emu-val>.</li></ol></li><li>If <var>field</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>env</var>.</li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>outerPrivateEnvironment</var>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>field</var>).</li></ol></li><li>Set <var>field</var> to <var>field</var>.[[Value]].</li><li>If <var>field</var> is a <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>field</var>.[[Kind]] is either <emu-const>method</emu-const> or <emu-const>accessor</emu-const>.</li><li>If <emu-xref aoid=\"IsStatic\"><a href=\"#sec-static-semantics-isstatic\">IsStatic</a></emu-xref> of <var>e</var> is <emu-val>false</emu-val>, let <var>container</var> be <var>instancePrivateMethods</var>.</li><li>Else, let <var>container</var> be <var>staticPrivateMethods</var>.</li><li>If <var>container</var> contains a <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> whose [[Key]] is <var>field</var>.[[Key]], then<ol><li>Let <var>existing</var> be that <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>field</var>.[[Kind]] and <var>existing</var>.[[Kind]] are both <emu-const>accessor</emu-const>.</li><li>If <var>field</var>.[[Get]] is <emu-val>undefined</emu-val>, then<ol><li>Let <var>combined</var> be <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> { [[Key]]: <var>field</var>.[[Key]], [[Kind]]: <emu-const>accessor</emu-const>, [[Get]]: <var>existing</var>.[[Get]], [[Set]]: <var>field</var>.[[Set]] }.</li></ol></li><li>Else,<ol><li>Let <var>combined</var> be <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> { [[Key]]: <var>field</var>.[[Key]], [[Kind]]: <emu-const>accessor</emu-const>, [[Get]]: <var>field</var>.[[Get]], [[Set]]: <var>existing</var>.[[Set]] }.</li></ol></li><li>Replace <var>existing</var> in <var>container</var> with <var>combined</var>.</li></ol></li><li>Else,<ol><li>Append <var>field</var> to <var>container</var>.</li></ol></li></ol></li><li>Else if <var>field</var> is a <emu-xref href=\"#sec-classfielddefinition-record-specification-type\"><a href=\"#sec-classfielddefinition-record-specification-type\">ClassFieldDefinition Record</a></emu-xref>, then<ol><li>If <emu-xref aoid=\"IsStatic\"><a href=\"#sec-static-semantics-isstatic\">IsStatic</a></emu-xref> of <var>e</var> is <emu-val>false</emu-val>, append <var>field</var> to <var>instanceFields</var>.</li><li>Else, append <var>field</var> to <var>staticFields</var>.</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s LexicalEnvironment to <var>env</var>.</li><li>If <var>classBinding</var> is not <emu-val>undefined</emu-val>, then<ol><li>Perform <var>classScope</var>.InitializeBinding(<var>classBinding</var>, <var>F</var>).</li></ol></li><li>Set <var>F</var>.[[PrivateMethods]] to <var>instancePrivateMethods</var>.</li><li>Set <var>F</var>.[[Fields]] to <var>instanceFields</var>.</li><li>For each <emu-xref href=\"#sec-privateelement-specification-type\"><a href=\"#sec-privateelement-specification-type\">PrivateElement</a></emu-xref> <var>method</var> of <var>staticPrivateMethods</var>, do<ol><li>Perform !&#160;<emu-xref aoid=\"PrivateMethodOrAccessorAdd\"><a href=\"#sec-privatemethodoraccessoradd\">PrivateMethodOrAccessorAdd</a></emu-xref>(<var>method</var>, <var>F</var>).</li></ol></li><li>For each element <var>fieldRecord</var> of <var>staticFields</var>, do<ol><li>Let <var>result</var> be <emu-xref aoid=\"DefineField\"><a href=\"#sec-definefield\">DefineField</a></emu-xref>(<var>F</var>, <var>fieldRecord</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>outerPrivateEnvironment</var>.</li><li>Return <var>result</var>.</li></ol></li></ol></li><li>Set the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>'s PrivateEnvironment to <var>outerPrivateEnvironment</var>.</li><li>Return <var>F</var>.</li></ol></emu-alg>\n    </emu-clause>\n\n    "}}, "figData": {}}}