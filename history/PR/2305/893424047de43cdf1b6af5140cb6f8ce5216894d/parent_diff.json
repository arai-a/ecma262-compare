{"from": {"secList": ["sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact", "sec-sortcompare", "sec-string.prototype.localecompare", "sec-%typedarray%.prototype.sort", "sec-array.prototype.sort"], "secData": {"sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact": {"num": "E", "title": "#sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact Corrections and Clarifications in CMAScript 2015 with Possible Compatibility Impact", "html": "<emu-annex id=\"sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact\">\n  <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact\">#sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact</span> Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact</h1>\n  <p><emu-xref href=\"#sec-candeclareglobalvar\"><a href=\"#sec-candeclareglobalvar\" class=\"excluded-xref\" excluded-id=\"sec-candeclareglobalvar\">#sec-candeclareglobalvar</a></emu-xref>-<emu-xref href=\"#sec-createglobalfunctionbinding\"><a href=\"#sec-createglobalfunctionbinding\" class=\"excluded-xref\" excluded-id=\"sec-createglobalfunctionbinding\">#sec-createglobalfunctionbinding</a></emu-xref> Edition 5 and 5.1 used a property existence test to determine whether a <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> property corresponding to a new global declaration already existed. ECMAScript 2015 uses an own property existence test. This corresponds to what has been most commonly implemented by web browsers.</p>\n  <p><emu-xref href=\"#sec-array-exotic-objects-defineownproperty-p-desc\"><a href=\"#sec-array-exotic-objects-defineownproperty-p-desc\" class=\"excluded-xref\" excluded-id=\"sec-array-exotic-objects-defineownproperty-p-desc\">#sec-array-exotic-objects-defineownproperty-p-desc</a></emu-xref>: The 5<sup>th</sup> Edition moved the capture of the current array length prior to the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> conversion of the <emu-xref href=\"#array-index\"><a href=\"#array-index\">array index</a></emu-xref> or new length value. However, the captured length value could become invalid if the conversion process has the side-effect of changing the array length. ECMAScript 2015 specifies that the current array length must be captured after the possible occurrence of such side-effects.</p>\n  <p><emu-xref href=\"#sec-timeclip\"><a href=\"#sec-timeclip\" class=\"excluded-xref\" excluded-id=\"sec-timeclip\">#sec-timeclip</a></emu-xref>: Previous editions permitted the <emu-xref aoid=\"TimeClip\"><a href=\"#sec-timeclip\">TimeClip</a></emu-xref> abstract operation to return either <emu-val>+0</emu-val><sub>&#120125;</sub> or <emu-val>-0</emu-val><sub>&#120125;</sub> as the representation of a 0 <emu-xref href=\"#sec-time-values-and-time-range\"><a href=\"#sec-time-values-and-time-range\">time value</a></emu-xref>. ECMAScript 2015 specifies that <emu-val>+0</emu-val><sub>&#120125;</sub> always returned. This means that for ECMAScript 2015 the <emu-xref href=\"#sec-time-values-and-time-range\"><a href=\"#sec-time-values-and-time-range\">time value</a></emu-xref> of a Date object is never observably <emu-val>-0</emu-val><sub>&#120125;</sub> and methods that return time values never return <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n  <p><emu-xref href=\"#sec-date-time-string-format\"><a href=\"#sec-date-time-string-format\" class=\"excluded-xref\" excluded-id=\"sec-date-time-string-format\">#sec-date-time-string-format</a></emu-xref>: If a UTC offset representation is not present, the local time zone is used. Edition 5.1 incorrectly stated that a missing time zone should be interpreted as <emu-val>\"z\"</emu-val>.</p>\n  <p><emu-xref href=\"#sec-date.prototype.toisostring\"><a href=\"#sec-date.prototype.toisostring\" class=\"excluded-xref\" excluded-id=\"sec-date.prototype.toisostring\">#sec-date.prototype.toisostring</a></emu-xref>: If the year cannot be represented using the Date Time String Format specified in <emu-xref href=\"#sec-date-time-string-format\"><a href=\"#sec-date-time-string-format\" class=\"excluded-xref\" excluded-id=\"sec-date-time-string-format\">#sec-date-time-string-format</a></emu-xref> a RangeError exception is thrown. Previous editions did not specify the behaviour for that case.</p>\n  <p><emu-xref href=\"#sec-date.prototype.tostring\"><a href=\"#sec-date.prototype.tostring\" class=\"excluded-xref\" excluded-id=\"sec-date.prototype.tostring\">#sec-date.prototype.tostring</a></emu-xref>: Previous editions did not specify the value returned by <code>Date.prototype.toString</code> when <emu-xref href=\"#this-time-value\"><a href=\"#this-time-value\">this time value</a></emu-xref> is <emu-val>NaN</emu-val>. ECMAScript 2015 specifies the result to be the String value <emu-val>\"Invalid Date\"</emu-val>.</p>\n  <p><emu-xref href=\"#sec-regexp-pattern-flags\"><a href=\"#sec-regexp-pattern-flags\" class=\"excluded-xref\" excluded-id=\"sec-regexp-pattern-flags\">#sec-regexp-pattern-flags</a></emu-xref>, <emu-xref href=\"#sec-escaperegexppattern\"><a href=\"#sec-escaperegexppattern\" class=\"excluded-xref\" excluded-id=\"sec-escaperegexppattern\">#sec-escaperegexppattern</a></emu-xref>: Any LineTerminator code points in the value of the <emu-val>\"source\"</emu-val> property of a RegExp instance must be expressed using an escape sequence. Edition 5.1 only required the escaping of <code>/</code>.</p>\n  <p><emu-xref href=\"#sec-regexp.prototype-@@match\"><a href=\"#sec-regexp.prototype-@@match\" class=\"excluded-xref\" excluded-id=\"sec-regexp.prototype-@@match\">#sec-regexp.prototype-@@match</a></emu-xref>, <emu-xref href=\"#sec-regexp.prototype-@@replace\"><a href=\"#sec-regexp.prototype-@@replace\" class=\"excluded-xref\" excluded-id=\"sec-regexp.prototype-@@replace\">#sec-regexp.prototype-@@replace</a></emu-xref>: In previous editions, the specifications for <code>String.prototype.match</code> and <code>String.prototype.replace</code> was incorrect for cases where the pattern argument was a RegExp value whose <code>global</code> flag is set. The previous specifications stated that for each attempt to match the pattern, if <code>lastIndex</code> did not change it should be incremented by 1. The correct behaviour is that <code>lastIndex</code> should be incremented by one only if the pattern matched the empty String.</p>\n  <p><emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>, <emu-xref href=\"#sec-sortcompare\"><a href=\"#sec-sortcompare\" class=\"excluded-xref\" excluded-id=\"sec-sortcompare\">#sec-sortcompare</a></emu-xref>: Previous editions did not specify how a <emu-val>NaN</emu-val> value returned by a <var>comparefn</var> was interpreted by <code>Array.prototype.sort</code>. ECMAScript 2015 specifies that such as value is treated as if <emu-val>+0</emu-val><sub>&#120125;</sub> was returned from the <var>comparefn</var>. ECMAScript 2015 also specifies that <emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref> is applied to the result returned by a <var>comparefn</var>. In previous editions, the effect of a <var>comparefn</var> result that is not a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> was <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>. In practice, implementations call <emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>.</p>\n</emu-annex>\n\n"}, "sec-sortcompare": {"num": "23.1.3.27.1", "title": "#sec-sortcompare SortCompare ( x, y )", "html": "<emu-clause id=\"sec-sortcompare\" aoid=\"SortCompare\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-sortcompare\">#sec-sortcompare</span> SortCompare ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation SortCompare takes arguments <var>x</var> and <var>y</var>. It also has access to the <var>comparefn</var> argument passed to the current invocation of the <code>sort</code> method. It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> and <var>y</var> are both <emu-val>undefined</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>undefined</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>y</var> is <emu-val>undefined</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&#160;<emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(? <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, &#171; <var>x</var>, <var>y</var> &#187;)).</li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>Return <var>v</var>.</li></ol></li><li id=\"step-sortcompare-tostring-x\">Let <var>xString</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>x</var>).</li><li id=\"step-sortcompare-tostring-y\">Let <var>yString</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>y</var>).</li><li>Let <var>xSmaller</var> be the result of performing <emu-xref aoid=\"Abstract Relational Comparison\"><a href=\"#sec-abstract-relational-comparison\">Abstract Relational Comparison</a></emu-xref> <var>xString</var> &lt; <var>yString</var>.</li><li>If <var>xSmaller</var> is <emu-val>true</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>Let <var>ySmaller</var> be the result of performing <emu-xref aoid=\"Abstract Relational Comparison\"><a href=\"#sec-abstract-relational-comparison\">Abstract Relational Comparison</a></emu-xref> <var>yString</var> &lt; <var>xString</var>.</li><li>If <var>ySmaller</var> is <emu-val>true</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>Because non-existent property values always compare greater than <emu-val>undefined</emu-val> property values, and <emu-val>undefined</emu-val> always compares greater than any other value, <emu-val>undefined</emu-val> property values always sort to the end of the result, followed by non-existent property values.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>Method calls performed by the <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> in steps <emu-xref href=\"#step-sortcompare-tostring-x\"><a href=\"#step-sortcompare-tostring-x\" class=\"excluded-xref\" excluded-id=\"step-sortcompare-tostring-x\">#step-sortcompare-tostring-x</a></emu-xref> and <emu-xref href=\"#step-sortcompare-tostring-y\"><a href=\"#step-sortcompare-tostring-y\" class=\"excluded-xref\" excluded-id=\"step-sortcompare-tostring-y\">#step-sortcompare-tostring-y</a></emu-xref> have the potential to cause SortCompare to not behave as a consistent comparison function.</p>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-string.prototype.localecompare": {"num": "22.1.3.10", "title": "#sec-string.prototype.localecompare String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )", "html": "<emu-clause id=\"sec-string.prototype.localecompare\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-string.prototype.localecompare\">#sec-string.prototype.localecompare</span> String.prototype.localeCompare ( <var>that</var> [ , <var>reserved1</var> [ , <var>reserved2</var> ] ] )</h1>\n        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the <code>localeCompare</code> method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the <code>localeCompare</code> method is used.</p>\n        <p>When the <code>localeCompare</code> method is called with argument <var>that</var>, it returns a Number other than <emu-val>NaN</emu-val> that represents the result of a locale-sensitive String comparison of the <emu-val>this</emu-val> value (converted to a String) with <var>that</var> (converted to a String). The two Strings are <var>S</var> and <var>That</var>. The two Strings are compared in an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> fashion. The result is intended to order String values in the sort order specified by a <emu-xref href=\"#host\"><a href=\"#host\">host</a></emu-xref> default locale, and will be negative, zero, or positive, depending on whether <var>S</var> comes before <var>That</var> in the sort order, the Strings are equal, or <var>S</var> comes after <var>That</var> in the sort order, respectively.</p>\n        <p>Before performing the comparisons, the following steps are performed to prepare the Strings:</p>\n        <emu-alg><ol><li>Let <var>O</var> be ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>S</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>O</var>).</li><li>Let <var>That</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>that</var>).</li></ol></emu-alg>\n        <p>The meaning of the optional second and third parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not assign any other interpretation to those parameter positions.</p>\n        <p>The <code>localeCompare</code> method, if considered as a function of two arguments <emu-val>this</emu-val> and <var>that</var>, is a consistent comparison function (as defined in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>) on the set of all Strings.</p>\n        <p>The actual return values are <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> to permit implementers to encode additional information in the value, but the function is required to define a total ordering on all Strings. This function must treat Strings that are canonically equivalent according to the Unicode standard as identical and must return <code>0</code> when comparing Strings that are considered canonically equivalent.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The <code>localeCompare</code> method itself is not directly suitable as an argument to <code>Array.prototype.sort</code> because the latter requires a function of two arguments.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>This function is intended to rely on whatever language-sensitive comparison functionality is available to the ECMAScript environment from the <emu-xref href=\"#host-environment\"><a href=\"#host-environment\">host environment</a></emu-xref>, and to compare according to the rules of the <emu-xref href=\"#host-environment\"><a href=\"#host-environment\">host environment</a></emu-xref>'s current locale. However, regardless of the <emu-xref href=\"#host\"><a href=\"#host\">host</a></emu-xref> provided comparison capabilities, this function must treat Strings that are canonically equivalent according to the Unicode standard as identical. It is recommended that this function should not honour Unicode compatibility equivalences or decompositions. For a definition and discussion of canonical equivalence see the Unicode Standard, chapters 2 and 3, as well as Unicode Standard Annex #15, Unicode Normalization Forms (<a href=\"https://unicode.org/reports/tr15/\">https://unicode.org/reports/tr15/</a>) and Unicode Technical Note #5, Canonical Equivalence in Applications (<a href=\"https://unicode.org/notes/tn5/\">https://www.unicode.org/notes/tn5/</a>). Also see Unicode Technical Standard #10, Unicode Collation Algorithm (<a href=\"https://unicode.org/reports/tr10/\">https://unicode.org/reports/tr10/</a>).</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>The <code>localeCompare</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-%typedarray%.prototype.sort": {"num": "23.2.3.26", "title": "#sec-%typedarray%.prototype.sort %TypedArray%.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-%typedarray%.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-%typedarray%.prototype.sort\">#sec-%typedarray%.prototype.sort</span> %TypedArray%.prototype.sort ( <var>comparefn</var> )</h1>\n        <p><emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> is a distinct function that, except as described below, implements the same requirements as those of <code>Array.prototype.sort</code> as defined in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>. The implementation of the <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> specification may be optimized with the knowledge that the <emu-val>this</emu-val> value is an object that has a fixed length and whose <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> properties are not sparse.</p>\n        <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>\n        <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function. These steps are used instead of steps <emu-xref href=\"#step-array-sort-comparefn\"><a href=\"#step-array-sort-comparefn\" class=\"excluded-xref\" excluded-id=\"step-array-sort-comparefn\">#step-array-sort-comparefn</a></emu-xref>&#8211;<emu-xref href=\"#step-array-sort-len\"><a href=\"#step-array-sort-len\" class=\"excluded-xref\" excluded-id=\"step-array-sort-len\">#step-array-sort-len</a></emu-xref> in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>buffer</var> be ?&#160;<emu-xref aoid=\"ValidateTypedArray\"><a href=\"#sec-validatetypedarray\">ValidateTypedArray</a></emu-xref>(<var>obj</var>).</li><li>Let <var>len</var> be <var>obj</var>.[[ArrayLength]].</li></ol></emu-alg>\n        <p>The following version of <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> is used by <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code>. It performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>.</p>\n        <p>The abstract operation TypedArraySortCompare takes arguments <var>x</var> and <var>y</var>. It also has access to the <var>comparefn</var> and <var>buffer</var> values of the current invocation of the <code>sort</code> method. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Both <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>) are Number or both are BigInt.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&#160;<emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(? <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, &#171; <var>x</var>, <var>y</var> &#187;)).</li><li>If <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>Return <var>v</var>.</li></ol></li><li>If <var>x</var> and <var>y</var> are both <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &lt; <var>y</var>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &gt; <var>y</var>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Because <emu-val>NaN</emu-val> always compares greater than any other value, <emu-val>NaN</emu-val> property values always sort to the end of the result when <var>comparefn</var> is not provided.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-array.prototype.sort": {"num": "23.1.3.27", "title": "#sec-array.prototype.sort Array.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-array.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</span> Array.prototype.sort ( <var>comparefn</var> )</h1>\n        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If <var>comparefn</var> is not <emu-val>undefined</emu-val>, it should be a function that accepts two arguments <var>x</var> and <var>y</var> and returns a negative value if <var>x</var> &lt; <var>y</var>, zero if <var>x</var> = <var>y</var>, or a positive value if <var>x</var> &gt; <var>y</var>.</p>\n        <p>The following steps are taken:</p>\n        <emu-alg><ol><li id=\"step-array-sort-comparefn\">If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li id=\"step-array-sort-len\">Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>obj</var>).</li><li>Let <var>items</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>k</var> be 0.</li><li>Repeat, while <var>k</var> &lt; <var>len</var>,<ol><li>Let <var>Pk</var> be !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>k</var>)).</li><li>Let <var>kPresent</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>obj</var>, <var>Pk</var>).</li><li>If <var>kPresent</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>kValue</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>Pk</var>).</li><li>Append <var>kValue</var> to <var>items</var>.</li></ol></li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Let <var>itemCount</var> be the number of elements in <var>items</var>.</li><li id=\"step-array-sort\">Sort <var>items</var> using an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> sequence of calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>. If any such call returns an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, stop before performing any further calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> or steps in this algorithm and return that completion.</li><li>Let <var>j</var> be 0.</li><li>Repeat, while <var>j</var> &lt; <var>itemCount</var>,<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>obj</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>)), <var>items</var>[<var>j</var>], <emu-val>true</emu-val>).</li><li>Set <var>j</var> to <var>j</var> + 1.</li></ol></li><li>Repeat, while <var>j</var> &lt; <var>len</var>,<ol><li>Perform ?&#160;<emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref>(<var>obj</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>))).</li><li>Set <var>j</var> to <var>j</var> + 1.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>\n        <p>The <em>sort order</em> is the ordering, after completion of this function, of the <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> property values of <var>obj</var> whose <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> indexes are less than <var>len</var>. The result of the <code>sort</code> function is then determined as follows:</p>\n        <p>The sort order is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> if any of the following conditions is true:</p>\n        <ul>\n          <li>\n            If <var>comparefn</var> is not <emu-val>undefined</emu-val> and is not a consistent comparison function for the elements of <var>items</var> (see below).\n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> does not act as a consistent comparison function.\n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and all applications of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>, to any specific value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>, do not produce the same result.\n          </li>\n        </ul>\n        <p>Unless the sort order is specified above to be <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>, <var>items</var> must satisfy all of the following conditions after executing step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> of the algorithm above:</p>\n        <ul>\n          <li>\n            There must be some mathematical permutation &#960; of the non-negative integers less than <var>itemCount</var>, such that for every non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> less than <var>itemCount</var>, the element <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is exactly the same as <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn>.\n          </li>\n          <li>\n            Then for all non-negative integers <var>j</var> and <var>k</var>, each less than <var>itemCount</var>, if <emu-eqn class=\"inline\"><emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>(old[<var>j</var>], old[<var>k</var>]) &lt; 0</emu-eqn> (see <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> below), then <emu-eqn class=\"inline\">&#960;(<var>j</var>) &lt; &#960;(<var>k</var>)</emu-eqn>.\n          </li>\n        </ul>\n        <p>Here the notation <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is used to refer to <emu-eqn class=\"inline\"><var>items</var>[<var>j</var>]</emu-eqn> before step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> is executed, and the notation <emu-eqn class=\"inline\">new[<var>j</var>]</emu-eqn> to refer to <emu-eqn class=\"inline\"><var>items</var>[<var>j</var>]</emu-eqn> after step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> has been executed.</p>\n        <p>A function <var>comparefn</var> is a consistent comparison function for a set of values <var>S</var> if all of the requirements below are met for all values <var>a</var>, <var>b</var>, and <var>c</var> (possibly the same value) in the set <var>S</var>: The notation <emu-eqn class=\"inline\"><var>a</var> &lt;<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &lt; 0</emu-eqn>; <emu-eqn class=\"inline\"><var>a</var> =<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) = 0</emu-eqn> (of either sign); and <emu-eqn class=\"inline\"><var>a</var> &gt;<sub>CF</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &gt; 0</emu-eqn>.</p>\n        <ul>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) always returns the same value <var>v</var> when given a specific pair of values <var>a</var> and <var>b</var> as its two arguments. Furthermore, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>v</var>) is Number, and <var>v</var> is not <emu-val>NaN</emu-val>. Note that this implies that exactly one of <var>a</var> &lt;<sub>CF</sub> <var>b</var>, <var>a</var> =<sub>CF</sub> <var>b</var>, and <var>a</var> &gt;<sub>CF</sub> <var>b</var> will be true for a given pair of <var>a</var> and <var>b</var>.\n          </li>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) does not modify <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          </li>\n          <li>\n            <var>a</var> =<sub>CF</sub> <var>a</var> (reflexivity)\n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var>, then <var>b</var> =<sub>CF</sub> <var>a</var> (symmetry)\n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var> and <var>b</var> =<sub>CF</sub> <var>c</var>, then <var>a</var> =<sub>CF</sub> <var>c</var> (transitivity of =<sub>CF</sub>)\n          </li>\n          <li>\n            If <var>a</var> &lt;<sub>CF</sub> <var>b</var> and <var>b</var> &lt;<sub>CF</sub> <var>c</var>, then <var>a</var> &lt;<sub>CF</sub> <var>c</var> (transitivity of &lt;<sub>CF</sub>)\n          </li>\n          <li>\n            If <var>a</var> &gt;<sub>CF</sub> <var>b</var> and <var>b</var> &gt;<sub>CF</sub> <var>c</var>, then <var>a</var> &gt;<sub>CF</sub> <var>c</var> (transitivity of &gt;<sub>CF</sub>)\n          </li>\n        </ul>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The above conditions are necessary and sufficient to ensure that <var>comparefn</var> divides the set <var>S</var> into equivalence classes and that these equivalence classes are totally ordered.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>sort</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-sortcompare\"><h1><span class=\"secnum\">23.1.3.27.1</span>#sec-sortcompare SortCompare ( x, y )</h1>...</div></emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact", "sec-string.prototype.localecompare", "sec-%typedarray%.prototype.sort", "sec-array.prototype.sort", "sec-sortarraylike"], "secData": {"sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact": {"num": "E", "title": "#sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact Corrections and Clarifications in CMAScript 2015 with Possible Compatibility Impact", "html": "<emu-annex id=\"sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact\">\n  <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact\">#sec-corrections-and-clarifications-in-ecmascript-2015-with-possible-compatibility-impact</span> Corrections and Clarifications in ECMAScript 2015 with Possible Compatibility Impact</h1>\n  <p><emu-xref href=\"#sec-candeclareglobalvar\"><a href=\"#sec-candeclareglobalvar\" class=\"excluded-xref\" excluded-id=\"sec-candeclareglobalvar\">#sec-candeclareglobalvar</a></emu-xref>-<emu-xref href=\"#sec-createglobalfunctionbinding\"><a href=\"#sec-createglobalfunctionbinding\" class=\"excluded-xref\" excluded-id=\"sec-createglobalfunctionbinding\">#sec-createglobalfunctionbinding</a></emu-xref> Edition 5 and 5.1 used a property existence test to determine whether a <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref> property corresponding to a new global declaration already existed. ECMAScript 2015 uses an own property existence test. This corresponds to what has been most commonly implemented by web browsers.</p>\n  <p><emu-xref href=\"#sec-array-exotic-objects-defineownproperty-p-desc\"><a href=\"#sec-array-exotic-objects-defineownproperty-p-desc\" class=\"excluded-xref\" excluded-id=\"sec-array-exotic-objects-defineownproperty-p-desc\">#sec-array-exotic-objects-defineownproperty-p-desc</a></emu-xref>: The 5<sup>th</sup> Edition moved the capture of the current array length prior to the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> conversion of the <emu-xref href=\"#array-index\"><a href=\"#array-index\">array index</a></emu-xref> or new length value. However, the captured length value could become invalid if the conversion process has the side-effect of changing the array length. ECMAScript 2015 specifies that the current array length must be captured after the possible occurrence of such side-effects.</p>\n  <p><emu-xref href=\"#sec-timeclip\"><a href=\"#sec-timeclip\" class=\"excluded-xref\" excluded-id=\"sec-timeclip\">#sec-timeclip</a></emu-xref>: Previous editions permitted the <emu-xref aoid=\"TimeClip\"><a href=\"#sec-timeclip\">TimeClip</a></emu-xref> abstract operation to return either <emu-val>+0</emu-val><sub>&#120125;</sub> or <emu-val>-0</emu-val><sub>&#120125;</sub> as the representation of a 0 <emu-xref href=\"#sec-time-values-and-time-range\"><a href=\"#sec-time-values-and-time-range\">time value</a></emu-xref>. ECMAScript 2015 specifies that <emu-val>+0</emu-val><sub>&#120125;</sub> always returned. This means that for ECMAScript 2015 the <emu-xref href=\"#sec-time-values-and-time-range\"><a href=\"#sec-time-values-and-time-range\">time value</a></emu-xref> of a Date object is never observably <emu-val>-0</emu-val><sub>&#120125;</sub> and methods that return time values never return <emu-val>-0</emu-val><sub>&#120125;</sub>.</p>\n  <p><emu-xref href=\"#sec-date-time-string-format\"><a href=\"#sec-date-time-string-format\" class=\"excluded-xref\" excluded-id=\"sec-date-time-string-format\">#sec-date-time-string-format</a></emu-xref>: If a UTC offset representation is not present, the local time zone is used. Edition 5.1 incorrectly stated that a missing time zone should be interpreted as <emu-val>\"z\"</emu-val>.</p>\n  <p><emu-xref href=\"#sec-date.prototype.toisostring\"><a href=\"#sec-date.prototype.toisostring\" class=\"excluded-xref\" excluded-id=\"sec-date.prototype.toisostring\">#sec-date.prototype.toisostring</a></emu-xref>: If the year cannot be represented using the Date Time String Format specified in <emu-xref href=\"#sec-date-time-string-format\"><a href=\"#sec-date-time-string-format\" class=\"excluded-xref\" excluded-id=\"sec-date-time-string-format\">#sec-date-time-string-format</a></emu-xref> a RangeError exception is thrown. Previous editions did not specify the behaviour for that case.</p>\n  <p><emu-xref href=\"#sec-date.prototype.tostring\"><a href=\"#sec-date.prototype.tostring\" class=\"excluded-xref\" excluded-id=\"sec-date.prototype.tostring\">#sec-date.prototype.tostring</a></emu-xref>: Previous editions did not specify the value returned by <code>Date.prototype.toString</code> when <emu-xref href=\"#this-time-value\"><a href=\"#this-time-value\">this time value</a></emu-xref> is <emu-val>NaN</emu-val>. ECMAScript 2015 specifies the result to be the String value <emu-val>\"Invalid Date\"</emu-val>.</p>\n  <p><emu-xref href=\"#sec-regexp-pattern-flags\"><a href=\"#sec-regexp-pattern-flags\" class=\"excluded-xref\" excluded-id=\"sec-regexp-pattern-flags\">#sec-regexp-pattern-flags</a></emu-xref>, <emu-xref href=\"#sec-escaperegexppattern\"><a href=\"#sec-escaperegexppattern\" class=\"excluded-xref\" excluded-id=\"sec-escaperegexppattern\">#sec-escaperegexppattern</a></emu-xref>: Any LineTerminator code points in the value of the <emu-val>\"source\"</emu-val> property of a RegExp instance must be expressed using an escape sequence. Edition 5.1 only required the escaping of <code>/</code>.</p>\n  <p><emu-xref href=\"#sec-regexp.prototype-@@match\"><a href=\"#sec-regexp.prototype-@@match\" class=\"excluded-xref\" excluded-id=\"sec-regexp.prototype-@@match\">#sec-regexp.prototype-@@match</a></emu-xref>, <emu-xref href=\"#sec-regexp.prototype-@@replace\"><a href=\"#sec-regexp.prototype-@@replace\" class=\"excluded-xref\" excluded-id=\"sec-regexp.prototype-@@replace\">#sec-regexp.prototype-@@replace</a></emu-xref>: In previous editions, the specifications for <code>String.prototype.match</code> and <code>String.prototype.replace</code> was incorrect for cases where the pattern argument was a RegExp value whose <code>global</code> flag is set. The previous specifications stated that for each attempt to match the pattern, if <code>lastIndex</code> did not change it should be incremented by 1. The correct behaviour is that <code>lastIndex</code> should be incremented by one only if the pattern matched the empty String.</p>\n  <p><emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>: Previous editions did not specify how a <emu-val>NaN</emu-val> value returned by a <var>comparefn</var> was interpreted by <code>Array.prototype.sort</code>. ECMAScript 2015 specifies that such as value is treated as if <emu-val>+0</emu-val><sub>&#120125;</sub> was returned from the <var>comparefn</var>. ECMAScript 2015 also specifies that <emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref> is applied to the result returned by a <var>comparefn</var>. In previous editions, the effect of a <var>comparefn</var> result that is not a <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> was <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>. In practice, implementations call <emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>.</p>\n</emu-annex>\n\n"}, "sec-string.prototype.localecompare": {"num": "22.1.3.10", "title": "#sec-string.prototype.localecompare String.prototype.localeCompare ( that [ , reserved1 [ , reserved2 ] ] )", "html": "<emu-clause id=\"sec-string.prototype.localecompare\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-string.prototype.localecompare\">#sec-string.prototype.localecompare</span> String.prototype.localeCompare ( <var>that</var> [ , <var>reserved1</var> [ , <var>reserved2</var> ] ] )</h1>\n        <p>An ECMAScript implementation that includes the ECMA-402 Internationalization API must implement the <code>localeCompare</code> method as specified in the ECMA-402 specification. If an ECMAScript implementation does not include the ECMA-402 API the following specification of the <code>localeCompare</code> method is used.</p>\n        <p>When the <code>localeCompare</code> method is called with argument <var>that</var>, it returns a Number other than <emu-val>NaN</emu-val> that represents the result of a locale-sensitive String comparison of the <emu-val>this</emu-val> value (converted to a String) with <var>that</var> (converted to a String). The two Strings are <var>S</var> and <var>That</var>. The two Strings are compared in an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> fashion. The result is intended to order String values in the sort order specified by a <emu-xref href=\"#host\"><a href=\"#host\">host</a></emu-xref> default locale, and will be negative, zero, or positive, depending on whether <var>S</var> comes before <var>That</var> in the sort order, the Strings are equal, or <var>S</var> comes after <var>That</var> in the sort order, respectively.</p>\n        <p>Before performing the comparisons, the following steps are performed to prepare the Strings:</p>\n        <emu-alg><ol><li>Let <var>O</var> be ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>S</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>O</var>).</li><li>Let <var>That</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>that</var>).</li></ol></emu-alg>\n        <p>The meaning of the optional second and third parameters to this method are defined in the ECMA-402 specification; implementations that do not include ECMA-402 support must not assign any other interpretation to those parameter positions.</p>\n        <p>The <code>localeCompare</code> method, if considered as a function of two arguments <emu-val>this</emu-val> and <var>that</var>, is a <emu-xref href=\"#sec-sortarraylike\"><a href=\"#sec-sortarraylike\">consistent comparator</a></emu-xref> (as defined in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>) on the set of all Strings.</p>\n        <p>The actual return values are <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> to permit implementers to encode additional information in the value, but the function is required to define a total ordering on all Strings. This function must treat Strings that are canonically equivalent according to the Unicode standard as identical and must return <code>0</code> when comparing Strings that are considered canonically equivalent.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The <code>localeCompare</code> method itself is not directly suitable as an argument to <code>Array.prototype.sort</code> because the latter requires a function of two arguments.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>This function is intended to rely on whatever language-sensitive comparison functionality is available to the ECMAScript environment from the <emu-xref href=\"#host-environment\"><a href=\"#host-environment\">host environment</a></emu-xref>, and to compare according to the rules of the <emu-xref href=\"#host-environment\"><a href=\"#host-environment\">host environment</a></emu-xref>'s current locale. However, regardless of the <emu-xref href=\"#host\"><a href=\"#host\">host</a></emu-xref> provided comparison capabilities, this function must treat Strings that are canonically equivalent according to the Unicode standard as identical. It is recommended that this function should not honour Unicode compatibility equivalences or decompositions. For a definition and discussion of canonical equivalence see the Unicode Standard, chapters 2 and 3, as well as Unicode Standard Annex #15, Unicode Normalization Forms (<a href=\"https://unicode.org/reports/tr15/\">https://unicode.org/reports/tr15/</a>) and Unicode Technical Note #5, Canonical Equivalence in Applications (<a href=\"https://unicode.org/notes/tn5/\">https://www.unicode.org/notes/tn5/</a>). Also see Unicode Technical Standard #10, Unicode Collation Algorithm (<a href=\"https://unicode.org/reports/tr10/\">https://unicode.org/reports/tr10/</a>).</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>The <code>localeCompare</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be a String object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-%typedarray%.prototype.sort": {"num": "23.2.3.26", "title": "#sec-%typedarray%.prototype.sort %TypedArray%.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-%typedarray%.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-%typedarray%.prototype.sort\">#sec-%typedarray%.prototype.sort</span> %TypedArray%.prototype.sort ( <var>comparefn</var> )</h1>\n        <p><emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> is a distinct function that, except as described below, implements the same requirements as those of <code>Array.prototype.sort</code> as defined in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>. The implementation of the <emu-xref href=\"#sec-%typedarray%-intrinsic-object\"><a href=\"#sec-%typedarray%-intrinsic-object\">%TypedArray%</a></emu-xref><code>.prototype.sort</code> specification may be optimized with the knowledge that the <emu-val>this</emu-val> value is an object that has a fixed length and whose <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> properties are not sparse.</p>\n        <p>This function is not generic. The <emu-val>this</emu-val> value must be an object with a [[TypedArrayName]] internal slot.</p>\n        <p>The following steps are performed:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>buffer</var> be ?&#160;<emu-xref aoid=\"ValidateTypedArray\"><a href=\"#sec-validatetypedarray\">ValidateTypedArray</a></emu-xref>(<var>obj</var>).</li><li>Let <var>len</var> be <var>obj</var>.[[ArrayLength]].</li><li>NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"><a href=\"#sec-array.prototype.sort\" class=\"excluded-xref\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</a></emu-xref>.</li><li>Let <var>SortCompare</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>x</var>, <var>y</var>) that captures <var>comparefn</var> and <var>buffer</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Both <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>x</var>) and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>y</var>) are Number or both are BigInt.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&#160;<emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(? <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, &#171; <var>x</var>, <var>y</var> &#187;)).</li><li>If <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>Return <var>v</var>.</li></ol></li><li>If <var>x</var> and <var>y</var> are both <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &lt; <var>y</var>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> &gt; <var>y</var>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>-0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>+0</emu-val><sub>&#120125;</sub>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>+0</emu-val><sub>&#120125;</sub> and <var>y</var> is <emu-val>-0</emu-val><sub>&#120125;</sub>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"SortArrayLike\"><a href=\"#sec-sortarraylike\">SortArrayLike</a></emu-xref>(<var>obj</var>, <var>len</var>, <var>SortCompare</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Because <emu-val>NaN</emu-val> always compares greater than any other value, <emu-val>NaN</emu-val> property values always sort to the end of the result when <var>comparefn</var> is not provided.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-array.prototype.sort": {"num": "23.1.3.27", "title": "#sec-array.prototype.sort Array.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-array.prototype.sort\" oldids=\"sec-sortcompare\"><span id=\"sec-sortcompare\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</span> Array.prototype.sort ( <var>comparefn</var> )</h1>\n        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If <var>comparefn</var> is not <emu-val>undefined</emu-val>, it should be a function that accepts two arguments <var>x</var> and <var>y</var> and returns a negative value if <var>x</var> &lt; <var>y</var>, zero if <var>x</var> = <var>y</var>, or a positive value if <var>x</var> &gt; <var>y</var>.</p>\n        <p>The following steps are taken:</p>\n        <emu-alg><ol><li id=\"step-array-sort-comparefn\">If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li id=\"step-array-sort-len\">Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>obj</var>).</li><li>Let <var>SortCompare</var> be a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>x</var>, <var>y</var>) that captures <var>comparefn</var> and performs the following steps when called:<ol><li>If <var>x</var> and <var>y</var> are both <emu-val>undefined</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>If <var>x</var> is <emu-val>undefined</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>If <var>y</var> is <emu-val>undefined</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val>, then<ol><li>Let <var>v</var> be ?&#160;<emu-xref aoid=\"ToNumber\"><a href=\"#sec-tonumber\">ToNumber</a></emu-xref>(? <emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>comparefn</var>, <emu-val>undefined</emu-val>, &#171; <var>x</var>, <var>y</var> &#187;)).</li><li>If <var>v</var> is <emu-val>NaN</emu-val>, return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li><li>Return <var>v</var>.</li></ol></li><li id=\"step-sortcompare-tostring-x\">Let <var>xString</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>x</var>).</li><li id=\"step-sortcompare-tostring-y\">Let <var>yString</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>y</var>).</li><li>Let <var>xSmaller</var> be the result of performing <emu-xref aoid=\"Abstract Relational Comparison\"><a href=\"#sec-abstract-relational-comparison\">Abstract Relational Comparison</a></emu-xref> <var>xString</var> &lt; <var>yString</var>.</li><li>If <var>xSmaller</var> is <emu-val>true</emu-val>, return <emu-val>-1</emu-val><sub>&#120125;</sub>.</li><li>Let <var>ySmaller</var> be the result of performing <emu-xref aoid=\"Abstract Relational Comparison\"><a href=\"#sec-abstract-relational-comparison\">Abstract Relational Comparison</a></emu-xref> <var>yString</var> &lt; <var>xString</var>.</li><li>If <var>ySmaller</var> is <emu-val>true</emu-val>, return <emu-val>1</emu-val><sub>&#120125;</sub>.</li><li>Return <emu-val>+0</emu-val><sub>&#120125;</sub>.</li></ol></li><li>Return ?&#160;<emu-xref aoid=\"SortArrayLike\"><a href=\"#sec-sortarraylike\">SortArrayLike</a></emu-xref>(<var>obj</var>, <var>len</var>, <var>SortCompare</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>Because non-existent property values always compare greater than <emu-val>undefined</emu-val> property values, and <emu-val>undefined</emu-val> always compares greater than any other value, <emu-val>undefined</emu-val> property values always sort to the end of the result, followed by non-existent property values.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p><var>SortCompare</var> is not a <emu-xref href=\"#sec-sortarraylike\"><a href=\"#sec-sortarraylike\">consistent comparator</a></emu-xref> if any of the following conditions is true:</p>\n          <ul>\n            <li>\n              <var>comparefn</var> is not <emu-val>undefined</emu-val> and is not a <emu-xref href=\"#sec-sortarraylike\"><a href=\"#sec-sortarraylike\">consistent comparator</a></emu-xref>.\n            </li>\n            <li>\n              <var>comparefn</var> is <emu-val>undefined</emu-val> and any invocation of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> (in step <emu-xref href=\"#step-sortcompare-tostring-x\"><a href=\"#step-sortcompare-tostring-x\">4.e</a></emu-xref> or <emu-xref href=\"#step-sortcompare-tostring-y\"><a href=\"#step-sortcompare-tostring-y\">4.f</a></emu-xref>) modifies <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n            </li>\n            <li>\n              <var>comparefn</var> is <emu-val>undefined</emu-val> and for any specific value passed as an argument to <var>SortCompare</var>, all applications of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> do not produce the same result.\n            </li>\n          </ul>\n          <p>The latter two cases can happen if <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> performs method calls.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>The <code>sort</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-sortarraylike\"><h1><span class=\"secnum\">23.1.3.27.1</span>#sec-sortarraylike SortArrayLike ( obj, len, SortCompare )</h1>...</div></emu-clause>\n\n      "}, "sec-sortarraylike": {"num": "23.1.3.27.1", "title": "#sec-sortarraylike SortArrayLike ( obj, len, SortCompare )", "html": "<emu-clause id=\"sec-sortarraylike\" aoid=\"SortArrayLike\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-sortarraylike\">#sec-sortarraylike</span> SortArrayLike ( <var>obj</var>, <var>len</var>, <var>SortCompare</var> )</h1>\n          <p>The abstract operation SortArrayLike takes arguments <var>obj</var> (an <emu-xref href=\"#sec-lengthofarraylike\"><a href=\"#sec-lengthofarraylike\">array-like object</a></emu-xref>), <var>len</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), and <var>SortCompare</var> (an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with two parameters). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>items</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>k</var> be 0.</li><li>Repeat, while <var>k</var> &lt; <var>len</var>,<ol><li>Let <var>Pk</var> be !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>k</var>)).</li><li>Let <var>kPresent</var> be ?&#160;<emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>obj</var>, <var>Pk</var>).</li><li>If <var>kPresent</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>kValue</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>Pk</var>).</li><li>Append <var>kValue</var> to <var>items</var>.</li></ol></li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Let <var>itemCount</var> be the number of elements in <var>items</var>.</li><li id=\"step-array-sort\">Sort <var>items</var> using an <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> sequence of calls to <var>SortCompare</var>. If any such call returns an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, stop before performing any further calls to <var>SortCompare</var> or steps in this algorithm and return that completion.</li><li>Let <var>j</var> be 0.</li><li>Repeat, while <var>j</var> &lt; <var>itemCount</var>,<ol><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>obj</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>)), <var>items</var>[<var>j</var>], <emu-val>true</emu-val>).</li><li>Set <var>j</var> to <var>j</var> + 1.</li></ol></li><li>Repeat, while <var>j</var> &lt; <var>len</var>,<ol><li>Perform ?&#160;<emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref>(<var>obj</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<emu-xref href=\"#%F0%9D%94%BD\"><a href=\"#%F0%9D%94%BD\">&#120125;</a></emu-xref>(<var>j</var>))).</li><li>Set <var>j</var> to <var>j</var> + 1.</li></ol></li><li>Return <var>obj</var>.</li></ol></emu-alg>\n          <p>The <em>sort order</em> is the ordering of <var>items</var> after completion of step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> of the algorithm above. If <var>SortCompare</var> is not a consistent comparator for the elements of <var>items</var> (see below), the sort order is <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref>. Otherwise, the sort order must satisfy all of the following conditions:</p>\n          <ul>\n            <li>\n              There must be some mathematical permutation &#960; of the non-negative integers less than <var>itemCount</var>, such that for every non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> less than <var>itemCount</var>, the element <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is exactly the same as <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn>.\n            </li>\n            <li>\n              Then for all non-negative integers <var>j</var> and <var>k</var>, each less than <var>itemCount</var>, if <emu-eqn class=\"inline\"><var>SortCompare</var>(old[<var>j</var>], old[<var>k</var>]) &lt; 0</emu-eqn>, then <emu-eqn class=\"inline\">&#960;(<var>j</var>) &lt; &#960;(<var>k</var>)</emu-eqn>.\n            </li>\n          </ul>\n          <p>Here the notation <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is used to refer to <emu-eqn class=\"inline\"><var>items</var>[<var>j</var>]</emu-eqn> before step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> is executed, and the notation <emu-eqn class=\"inline\">new[<var>j</var>]</emu-eqn> to refer to <emu-eqn class=\"inline\"><var>items</var>[<var>j</var>]</emu-eqn> after step <emu-xref href=\"#step-array-sort\"><a href=\"#step-array-sort\" class=\"excluded-xref\" excluded-id=\"step-array-sort\">#step-array-sort</a></emu-xref> has been executed.</p>\n          <p>An abstract closure or function <var>comparator</var> is a <dfn>consistent comparator</dfn> for a set of values <var>S</var> if all of the requirements below are met for all values <var>a</var>, <var>b</var>, and <var>c</var> (possibly the same value) in the set <var>S</var>: The notation <emu-eqn class=\"inline\"><var>a</var> &lt;<sub>C</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparator</var>(<var>a</var>, <var>b</var>) &lt; 0</emu-eqn>; <emu-eqn class=\"inline\"><var>a</var> =<sub>C</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparator</var>(<var>a</var>, <var>b</var>) = 0</emu-eqn> (of either sign); and <emu-eqn class=\"inline\"><var>a</var> &gt;<sub>C</sub> <var>b</var></emu-eqn> means <emu-eqn class=\"inline\"><var>comparator</var>(<var>a</var>, <var>b</var>) &gt; 0</emu-eqn>.</p>\n          <ul>\n            <li>\n              Calling <var>comparator</var>(<var>a</var>, <var>b</var>) always returns the same value <var>v</var> when given a specific pair of values <var>a</var> and <var>b</var> as its two arguments. Furthermore, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>v</var>) is Number, and <var>v</var> is not <emu-val>NaN</emu-val>. Note that this implies that exactly one of <var>a</var> &lt;<sub>C</sub> <var>b</var>, <var>a</var> =<sub>C</sub> <var>b</var>, and <var>a</var> &gt;<sub>C</sub> <var>b</var> will be true for a given pair of <var>a</var> and <var>b</var>.\n            </li>\n            <li>\n              Calling <var>comparator</var>(<var>a</var>, <var>b</var>) does not modify <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n            </li>\n            <li>\n              <var>a</var> =<sub>C</sub> <var>a</var> (reflexivity)\n            </li>\n            <li>\n              If <var>a</var> =<sub>C</sub> <var>b</var>, then <var>b</var> =<sub>C</sub> <var>a</var> (symmetry)\n            </li>\n            <li>\n              If <var>a</var> =<sub>C</sub> <var>b</var> and <var>b</var> =<sub>C</sub> <var>c</var>, then <var>a</var> =<sub>C</sub> <var>c</var> (transitivity of =<sub>C</sub>)\n            </li>\n            <li>\n              If <var>a</var> &lt;<sub>C</sub> <var>b</var> and <var>b</var> &lt;<sub>C</sub> <var>c</var>, then <var>a</var> &lt;<sub>C</sub> <var>c</var> (transitivity of &lt;<sub>C</sub>)\n            </li>\n            <li>\n              If <var>a</var> &gt;<sub>C</sub> <var>b</var> and <var>b</var> &gt;<sub>C</sub> <var>c</var>, then <var>a</var> &gt;<sub>C</sub> <var>c</var> (transitivity of &gt;<sub>C</sub>)\n            </li>\n          </ul>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>The above conditions are necessary and sufficient to ensure that <var>comparator</var> divides the set <var>S</var> into equivalence classes and that these equivalence classes are totally ordered.</p>\n          </div></emu-note>\n        </emu-clause>\n      "}}, "figData": {}}}