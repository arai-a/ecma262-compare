{"from": {"secList": ["sec-abstract-relational-comparison", "sec-applystringornumericbinaryoperator"], "secData": {"sec-abstract-relational-comparison": {"num": "7.2.13", "title": "#sec-abstract-relational-comparison Abstract Relational Comparison", "html": "<emu-clause id=\"sec-abstract-relational-comparison\" aoid=\"Abstract Relational Comparison\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-abstract-relational-comparison\">#sec-abstract-relational-comparison</span> Abstract Relational Comparison</h1>\n      <p>The comparison <var>x</var> &lt; <var>y</var>, where <var>x</var> and <var>y</var> are values, produces <emu-val>true</emu-val>, <emu-val>false</emu-val>, or <emu-val>undefined</emu-val> (which indicates that at least one operand is <emu-val>NaN</emu-val>). In addition to <var>x</var> and <var>y</var> the algorithm takes a Boolean flag named <var>LeftFirst</var> as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of <var>LeftFirst</var> is <emu-val>true</emu-val> and indicates that the <var>x</var> parameter corresponds to an expression that occurs to the left of the <var>y</var> parameter's corresponding expression. If <var>LeftFirst</var> is <emu-val>false</emu-val>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. Such a comparison is performed as follows:</p>\n      <emu-alg><ol><li>If the <var>LeftFirst</var> flag is <emu-val>true</emu-val>, then<ol><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li></ol></li><li>Else,<ol><li>NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li></ol></li><li id=\"step-arc-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>py</var>, <var>px</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>px</var>, <var>py</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>k</var> be the smallest non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that the code unit at index <var>k</var> within <var>px</var> is different from the code unit at index <var>k</var> within <var>py</var>. (There must be such a <var>k</var>, for neither String is a prefix of the other.)</li><li>Let <var>m</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>px</var>.</li><li>Let <var>n</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>py</var>.</li><li>If <var>m</var> &lt; <var>n</var>, return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>py</var>).</li><li>If <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>px</var>, <var>ny</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is BigInt, then<ol><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>px</var>).</li><li>If <var>nx</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>nx</var>, <var>py</var>).</li></ol></li><li>NOTE: Because <var>px</var> and <var>py</var> are primitive values, evaluation order is not important.</li><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>px</var>).</li><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>py</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is the same as <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>), return <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>)::lessThan(<var>nx</var>, <var>ny</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is Number, or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is BigInt.</li><li>If <var>nx</var> or <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>nx</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>nx</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>nx</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>ny</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> differs from step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">1.c</a></emu-xref> in the algorithm that handles the addition operator <code>+</code> (<emu-xref href=\"#sec-applystringornumericbinaryoperator\"><a href=\"#sec-applystringornumericbinaryoperator\" class=\"excluded-xref\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</a></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-applystringornumericbinaryoperator": {"num": "13.15.3", "title": "#sec-applystringornumericbinaryoperator ApplyStringOrNumericBinaryOperator ( lval, opText, rval )", "html": "<emu-clause id=\"sec-applystringornumericbinaryoperator\" aoid=\"ApplyStringOrNumericBinaryOperator\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</span> ApplyStringOrNumericBinaryOperator ( <var>lval</var>, <var>opText</var>, <var>rval</var> )</h1>\n      <p>The abstract operation ApplyStringOrNumericBinaryOperator takes arguments <var>lval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>opText</var> (a sequence of Unicode code points), and <var>rval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n      <emu-alg><ol><li>If <var>opText</var> is <code>+</code>, then<ol><li id=\"step-binary-op-toprimitive-lval\">Let <var>lprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>lval</var>).</li><li id=\"step-binary-op-toprimitive-rval\">Let <var>rprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>rval</var>).</li><li id=\"step-binary-op-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lprim</var>) is String or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rprim</var>) is String, then<ol><li>Let <var>lstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>lprim</var>).</li><li>Let <var>rstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>rprim</var>).</li><li>Return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of <var>lstr</var> and <var>rstr</var>.</li></ol></li><li>Set <var>lval</var> to <var>lprim</var>.</li><li>Set <var>rval</var> to <var>rprim</var>.</li></ol></li><li>NOTE: At this point, it must be a numeric operation.</li><li>Let <var>lnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>lval</var>).</li><li>Let <var>rnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>rval</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rnum</var>), throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>).</li><li>Let <var>operation</var> be the abstract operation associated with <var>opText</var> in the following table:\n          <figure>\n            <table class=\"lightweight-table\">\n              <tbody>\n                <tr><th> <var>opText</var>       </th><th> <var>operation</var>             </th></tr>\n                <tr><td> <code>**</code>           </td><td> <var>T</var>::exponentiate       </td></tr>\n                <tr><td> <code>*</code>            </td><td> <var>T</var>::multiply           </td></tr>\n                <tr><td> <code>/</code>            </td><td> <var>T</var>::divide             </td></tr>\n                <tr><td> <code>%</code>            </td><td> <var>T</var>::remainder          </td></tr>\n                <tr><td> <code>+</code>            </td><td> <var>T</var>::add                </td></tr>\n                <tr><td> <code>-</code>            </td><td> <var>T</var>::subtract           </td></tr>\n                <tr><td> <code>&lt;&lt;</code>     </td><td> <var>T</var>::leftShift          </td></tr>\n                <tr><td> <code>&gt;&gt;</code>     </td><td> <var>T</var>::signedRightShift   </td></tr>\n                <tr><td> <code>&gt;&gt;&gt;</code> </td><td> <var>T</var>::unsignedRightShift </td></tr>\n                <tr><td> <code>&amp;</code>        </td><td> <var>T</var>::bitwiseAND         </td></tr>\n                <tr><td> <code>^</code>            </td><td> <var>T</var>::bitwiseXOR         </td></tr>\n                <tr><td> <code>|</code>            </td><td> <var>T</var>::bitwiseOR          </td></tr>\n              </tbody>\n            </table>\n          </figure></li><li>Return ? <var>operation</var>(<var>lnum</var>, <var>rnum</var>).</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>No hint is provided in the calls to <emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref> in steps <emu-xref href=\"#step-binary-op-toprimitive-lval\"><a href=\"#step-binary-op-toprimitive-lval\">1.a</a></emu-xref> and <emu-xref href=\"#step-binary-op-toprimitive-rval\"><a href=\"#step-binary-op-toprimitive-rval\">1.b</a></emu-xref>. All standard objects except Date objects handle the absence of a hint as if <emu-const>number</emu-const> were given; Date objects handle the absence of a hint as if <emu-const>string</emu-const> were given. Exotic objects may handle the absence of a hint in some other manner.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">1.c</a></emu-xref> differs from step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> of the <emu-xref aoid=\"Abstract Relational Comparison\"><a href=\"#sec-abstract-relational-comparison\">Abstract Relational Comparison</a></emu-xref> algorithm, by using the logical-or operation instead of the logical-and operation.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}}, "figData": {}}, "to": {"secList": ["sec-abstract-relational-comparison", "sec-applystringornumericbinaryoperator"], "secData": {"sec-abstract-relational-comparison": {"num": "7.2.13", "title": "#sec-abstract-relational-comparison Abstract Relational Comparison", "html": "<emu-clause id=\"sec-abstract-relational-comparison\" aoid=\"Abstract Relational Comparison\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-abstract-relational-comparison\">#sec-abstract-relational-comparison</span> Abstract Relational Comparison</h1>\n      <p>The comparison <var>x</var> &lt; <var>y</var>, where <var>x</var> and <var>y</var> are values, produces <emu-val>true</emu-val>, <emu-val>false</emu-val>, or <emu-val>undefined</emu-val> (which indicates that at least one operand is <emu-val>NaN</emu-val>). In addition to <var>x</var> and <var>y</var> the algorithm takes a Boolean flag named <var>LeftFirst</var> as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon <var>x</var> and <var>y</var>. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value of <var>LeftFirst</var> is <emu-val>true</emu-val> and indicates that the <var>x</var> parameter corresponds to an expression that occurs to the left of the <var>y</var> parameter's corresponding expression. If <var>LeftFirst</var> is <emu-val>false</emu-val>, the reverse is the case and operations must be performed upon <var>y</var> before <var>x</var>. Such a comparison is performed as follows:</p>\n      <emu-alg><ol><li>If the <var>LeftFirst</var> flag is <emu-val>true</emu-val>, then<ol><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li></ol></li><li>Else,<ol><li>NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.</li><li>Let <var>py</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>y</var>, <emu-const>number</emu-const>).</li><li>Let <var>px</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>x</var>, <emu-const>number</emu-const>).</li></ol></li><li id=\"step-arc-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>py</var>, <var>px</var>) is <emu-val>true</emu-val>, return <emu-val>false</emu-val>.</li><li>If <emu-xref aoid=\"IsStringPrefix\"><a href=\"#sec-isstringprefix\">IsStringPrefix</a></emu-xref>(<var>px</var>, <var>py</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Let <var>k</var> be the smallest non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> such that the code unit at index <var>k</var> within <var>px</var> is different from the code unit at index <var>k</var> within <var>py</var>. (There must be such a <var>k</var>, for neither String is a prefix of the other.)</li><li>Let <var>m</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>px</var>.</li><li>Let <var>n</var> be the <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is the numeric value of the code unit at index <var>k</var> within <var>py</var>.</li><li>If <var>m</var> &lt; <var>n</var>, return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.</li></ol></li><li>Else,<ol><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is String, then<ol><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>py</var>).</li><li>If <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>px</var>, <var>ny</var>).</li></ol></li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>px</var>) is String and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>py</var>) is BigInt, then<ol><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"StringToBigInt\"><a href=\"#sec-stringtobigint\">StringToBigInt</a></emu-xref>(<var>px</var>).</li><li>If <var>nx</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>Return BigInt::lessThan(<var>nx</var>, <var>py</var>).</li></ol></li><li>NOTE: Because <var>px</var> and <var>py</var> are primitive values, evaluation order is not important.</li><li>Let <var>nx</var> be !&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>px</var>).</li><li>Let <var>ny</var> be !&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>py</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is the same as <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>), return <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>)::lessThan(<var>nx</var>, <var>ny</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is BigInt and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is Number, or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>nx</var>) is Number and <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>ny</var>) is BigInt.</li><li>If <var>nx</var> or <var>ny</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>nx</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>true</emu-val>.</li><li>If <var>nx</var> is <emu-val>+&#8734;</emu-val><sub>&#120125;</sub> or <var>ny</var> is <emu-val>-&#8734;</emu-val><sub>&#120125;</sub>, return <emu-val>false</emu-val>.</li><li>If <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>nx</var>) &lt; <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>ny</var>), return <emu-val>true</emu-val>; otherwise return <emu-val>false</emu-val>.</li></ol></li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> differs from step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">2.c</a></emu-xref> in the algorithm that handles the addition operator <code>+</code> (<emu-xref href=\"#sec-applystringornumericbinaryoperator\"><a href=\"#sec-applystringornumericbinaryoperator\" class=\"excluded-xref\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</a></emu-xref>) by using the logical-and operation instead of the logical-or operation.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalized form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-applystringornumericbinaryoperator": {"num": "13.15.3", "title": "#sec-applystringornumericbinaryoperator ApplyStringOrNumericBinaryOperator ( lval, opText, rval )", "html": "<emu-clause id=\"sec-applystringornumericbinaryoperator\" aoid=\"ApplyStringOrNumericBinaryOperator\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-applystringornumericbinaryoperator\">#sec-applystringornumericbinaryoperator</span> ApplyStringOrNumericBinaryOperator ( <var>lval</var>, <var>opText</var>, <var>rval</var> )</h1>\n      <p>The abstract operation ApplyStringOrNumericBinaryOperator takes arguments <var>lval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>), <var>opText</var> (a sequence of Unicode code points), and <var>rval</var> (an <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref>). It performs the following steps when called:</p>\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>opText</var> is present in the below <emu-xref href=\"#table-applystringornumericbinaryoperator-operations\"><a href=\"#table-applystringornumericbinaryoperator-operations\">table of operations</a></emu-xref>.</li><li>If <var>opText</var> is <code>+</code>, then<ol><li id=\"step-binary-op-toprimitive-lval\">Let <var>lprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>lval</var>).</li><li id=\"step-binary-op-toprimitive-rval\">Let <var>rprim</var> be ?&#160;<emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref>(<var>rval</var>).</li><li id=\"step-binary-op-string-check\">If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lprim</var>) is String or <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rprim</var>) is String, then<ol><li>Let <var>lstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>lprim</var>).</li><li>Let <var>rstr</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>rprim</var>).</li><li>Return the <emu-xref href=\"#string-concatenation\"><a href=\"#string-concatenation\">string-concatenation</a></emu-xref> of <var>lstr</var> and <var>rstr</var>.</li></ol></li><li>Set <var>lval</var> to <var>lprim</var>.</li><li>Set <var>rval</var> to <var>rprim</var>.</li></ol></li><li>NOTE: At this point, it must be a numeric operation.</li><li>Let <var>lnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>lval</var>).</li><li>Let <var>rnum</var> be ?&#160;<emu-xref aoid=\"ToNumeric\"><a href=\"#sec-tonumeric\">ToNumeric</a></emu-xref>(<var>rval</var>).</li><li>If <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>) is different from <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>rnum</var>), throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>T</var> be <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>lnum</var>).</li><li>Let <var>operation</var> be the abstract operation associated with <var>opText</var> in the following <emu-xref href=\"#table-applystringornumericbinaryoperator-operations\"><a href=\"#table-applystringornumericbinaryoperator-operations\">table of operations</a></emu-xref>.</li><li>Return ? <var>operation</var>(<var>lnum</var>, <var>rnum</var>).</li></ol></emu-alg>\n      <emu-table id=\"table-applystringornumericbinaryoperator-operations\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-applystringornumericbinaryoperator-operations\">#table-applystringornumericbinaryoperator-operations</span></figcaption>\n        <table class=\"lightweigt-table\">\n          <tbody>\n            <tr><th> <var>opText</var>       </th><th> <var>operation</var>             </th></tr>\n            <tr><td> <code>**</code>           </td><td> <var>T</var>::exponentiate       </td></tr>\n            <tr><td> <code>*</code>            </td><td> <var>T</var>::multiply           </td></tr>\n            <tr><td> <code>/</code>            </td><td> <var>T</var>::divide             </td></tr>\n            <tr><td> <code>%</code>            </td><td> <var>T</var>::remainder          </td></tr>\n            <tr><td> <code>+</code>            </td><td> <var>T</var>::add                </td></tr>\n            <tr><td> <code>-</code>            </td><td> <var>T</var>::subtract           </td></tr>\n            <tr><td> <code>&lt;&lt;</code>     </td><td> <var>T</var>::leftShift          </td></tr>\n            <tr><td> <code>&gt;&gt;</code>     </td><td> <var>T</var>::signedRightShift   </td></tr>\n            <tr><td> <code>&gt;&gt;&gt;</code> </td><td> <var>T</var>::unsignedRightShift </td></tr>\n            <tr><td> <code>&amp;</code>        </td><td> <var>T</var>::bitwiseAND         </td></tr>\n            <tr><td> <code>^</code>            </td><td> <var>T</var>::bitwiseXOR         </td></tr>\n            <tr><td> <code>|</code>            </td><td> <var>T</var>::bitwiseOR          </td></tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n        <p>No hint is provided in the calls to <emu-xref aoid=\"ToPrimitive\"><a href=\"#sec-toprimitive\">ToPrimitive</a></emu-xref> in steps <emu-xref href=\"#step-binary-op-toprimitive-lval\"><a href=\"#step-binary-op-toprimitive-lval\">2.a</a></emu-xref> and <emu-xref href=\"#step-binary-op-toprimitive-rval\"><a href=\"#step-binary-op-toprimitive-rval\">2.b</a></emu-xref>. All standard objects except Date objects handle the absence of a hint as if <emu-const>number</emu-const> were given; Date objects handle the absence of a hint as if <emu-const>string</emu-const> were given. Exotic objects may handle the absence of a hint in some other manner.</p>\n      </div></emu-note>\n      <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n        <p>Step <emu-xref href=\"#step-binary-op-string-check\"><a href=\"#step-binary-op-string-check\">2.c</a></emu-xref> differs from step <emu-xref href=\"#step-arc-string-check\"><a href=\"#step-arc-string-check\" class=\"excluded-xref\" excluded-id=\"step-arc-string-check\">#step-arc-string-check</a></emu-xref> of the <emu-xref aoid=\"Abstract Relational Comparison\"><a href=\"#sec-abstract-relational-comparison\">Abstract Relational Comparison</a></emu-xref> algorithm, by using the logical-or operation instead of the logical-and operation.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}}, "figData": {"table-applystringornumericbinaryoperator-operations": "Table 38"}}}