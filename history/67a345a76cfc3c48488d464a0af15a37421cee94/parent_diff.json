{"from": {"secList": ["sec-example-cyclic-module-record-graphs"], "secData": {"sec-example-cyclic-module-record-graphs": {"num": "15.2.1.16.3", "title": "#sec-example-cyclic-module-record-graphs Example Cyclic Module Record Graphs", "html": "<emu-clause id=\"sec-example-cyclic-module-record-graphs\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-example-cyclic-module-record-graphs\">#sec-example-cyclic-module-record-graphs</span> Example Cyclic Module Record Graphs</h1>\n\n          <p>This non-normative section gives a series of examples of the linking and evaluation of a few common module graphs, with a specific focus on how errors can occur.</p>\n\n          <p>First consider the following simple module graph:</p>\n\n          <emu-figure id=\"figure-module-graph-simple\" caption=\"A simple module graph\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"figure-module-graph-simple\">#figure-module-graph-simple</span>: A simple module graph</figcaption>\n            <img alt=\"A module graph in which module A depends on module B\" width=\"121\" height=\"211\" src=\"img/module-graph-simple.svg\">\n          </figure></emu-figure>\n\n          <p>Let's first assume that there are no error conditions. When a host first calls <var>A</var>.Link(), this will complete successfully by assumption, and recursively link modules <var>B</var> and <var>C</var> as well, such that <var>A</var>.[[Status]] = <var>B</var>.[[Status]] = <var>C</var>.[[Status]] = <code>\"linked\"</code>. This preparatory step can be performed at any time. Later, when the host is ready to incur any possible side effects of the modules, it can call <var>A</var>.Evaluate(), which will complete successfully (again by assumption), recursively having evaluated first <var>C</var> and then <var>B</var>. Each module's [[Status]] at this point will be <code>\"evaluated\"</code>.</p>\n\n          <p>Consider then cases involving linking errors. If <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> of <var>C</var> succeeds but, thereafter, fails for <var>B</var>, for example because it imports something that <var>C</var> does not provide, then the original <var>A</var>.Link() will fail, and both <var>A</var> and <var>B</var>'s [[Status]] remain <code>\"unlinked\"</code>. <var>C</var>'s [[Status]] has become <code>\"linked\"</code>, though.</p>\n\n          <p>Finally, consider a case involving evaluation errors. If <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref> of <var>C</var> succeeds but, thereafter, fails for <var>B</var>, for example because <var>B</var> contains code that throws an exception, then the original <var>A</var>.Evaluate() will fail. The resulting exception will be recorded in both <var>A</var> and <var>B</var>'s [[EvaluationError]] fields, and their [[Status]] will become <code>\"evaluated\"</code>. <var>C</var> will also become <code>\"evaluated\"</code> but, in contrast to <var>A</var> and <var>B</var>, will remain without an [[EvaluationError]], as it successfully completed evaluation. Storing the exception ensures that any time a host tries to reuse <var>A</var> or <var>B</var> by calling their Evaluate() method, it will encounter the same exception. (Hosts are not required to reuse Cyclic Module Records; similarly, hosts are not required to expose the exception objects thrown by these  methods. However, the specification enables such uses.)</p>\n\n          <p>The difference here between linking and evaluation errors is due to how evaluation must be only performed once, as it can cause side effects; it is thus important to remember whether evaluation has already been performed, even if unsuccessfully. (In the error case, it makes sense to also remember the exception because otherwise subsequent Evaluate() calls would have to synthesize a new one.) Linking, on the other hand, is side-effect-free, and thus even if it fails, it can be retried at a later time with no issues.</p>\n\n          <p>Now consider a different type of error condition:</p>\n\n          <emu-figure id=\"figure-module-graph-missing\" caption=\"A module graph with an unresolvable module\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"figure-module-graph-missing\">#figure-module-graph-missing</span>: A module graph with an unresolvable module</figcaption>\n            <img alt=\"A module graph in which module A depends on a missing (unresolvable) module, represented by ???\" width=\"121\" height=\"121\" src=\"img/module-graph-missing.svg\">\n          </figure></emu-figure>\n\n          <p>In this scenario, module <var>A</var> declares a dependency on some other module, but no <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> exists for that module, i.e. <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> throws an exception when asked for it. This could occur for a variety of reasons, such as the corresponding resource not existing, or the resource existing but <emu-xref aoid=\"ParseModule\"><a href=\"#sec-parsemodule\">ParseModule</a></emu-xref> throwing an exception when trying to parse the resulting source text. Hosts can choose to expose the cause of failure via the exception they throw from <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>. In any case, this exception causes a linking failure, which as before results in <var>A</var>'s [[Status]] remaining <code>\"unlinked\"</code>.</p>\n\n          <p>Lastly, consider a module graph with a cycle:</p>\n\n          <emu-figure id=\"figure-module-graph-cycle\" caption=\"A cyclic module graph\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"figure-module-graph-cycle\">#figure-module-graph-cycle</span>: A cyclic module graph</figcaption>\n            <img alt=\"A module graph in which module A depends on module B and C, but module B also depends on module A\" width=\"181\" height=\"121\" src=\"img/module-graph-cycle.svg\">\n          </figure></emu-figure>\n\n          <p>Here we assume that the entry point is module <var>A</var>, so that the host proceeds by calling <var>A</var>.Link(), which performs <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>. This in turn calls <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>B</var>. Because of the cycle, this again triggers <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>, but at this point it is a no-op since <var>A</var>.[[Status]] is already <code>\"linking\"</code>. <var>B</var>.[[Status]] itself remains <code>\"linking\"</code> when control gets back to <var>A</var> and <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> is triggered on <var>C</var>. After this returns with <var>C</var>.[[Status]] being <code>\"linked\"</code> , both <var>A</var> and <var>B</var> transition from <code>\"linking\"</code> to <code>\"linked\"</code> together; this is by design, since they form a strongly connected component.</p>\n\n          <p>An analogous story occurs for the evaluation phase of a cyclic module graph, in the success case.</p>\n\n          <p>Now consider a case where <var>A</var> has an linking error; for example, it tries to import a binding from <var>C</var> that does not exist. In that case, the above steps still occur, including the early return from the second call to <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>. However, once we unwind back to the original <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>, it fails during ModuleDeclarationEnvironmentSetup, namely right after <var>C</var>.ResolveExport(). The thrown <emu-val>SyntaxError</emu-val> exception propagates up to <var>A</var>.Link, which resets all modules that are currently on its <var>stack</var> (these are always exactly the modules that are still <code>\"linking\"</code>). Hence both <var>A</var> and <var>B</var> become <code>\"unlinked\"</code>. Note that <var>C</var> is left as <code>\"linked\"</code>.</p>\n\n          <p>Finally, consider a case where <var>A</var> has an evaluation error; for example, its source code throws an exception. In that case, the evaluation-time analog of the above steps still occurs, including the early return from the second call to <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref> on <var>A</var>. However, once we unwind back to the original <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref> on <var>A</var>, it fails by assumption. The exception thrown propagates up to <var>A</var>.Evaluate(), which records the error in all modules that are currently on its <var>stack</var> (i.e., the modules that are still <code>\"evaluating\"</code>). Hence both <var>A</var> and <var>B</var> become <code>\"evaluated\"</code> and the exception is recorded in both <var>A</var> and <var>B</var>'s [[EvaluationError]] fields, while <var>C</var> is left as <code>\"evaluated\"</code> with no [[EvaluationError]].</p>\n        </emu-clause>\n      "}}, "figData": {"figure-module-graph-simple": "Figure 2", "figure-module-graph-missing": "Figure 3", "figure-module-graph-cycle": "Figure 4"}}, "to": {"secList": ["sec-example-cyclic-module-record-graphs"], "secData": {"sec-example-cyclic-module-record-graphs": {"num": "15.2.1.16.3", "title": "#sec-example-cyclic-module-record-graphs Example Cyclic Module Record Graphs", "html": "<emu-clause id=\"sec-example-cyclic-module-record-graphs\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-example-cyclic-module-record-graphs\">#sec-example-cyclic-module-record-graphs</span> Example Cyclic Module Record Graphs</h1>\n\n          <p>This non-normative section gives a series of examples of the linking and evaluation of a few common module graphs, with a specific focus on how errors can occur.</p>\n\n          <p>First consider the following simple module graph:</p>\n\n          <emu-figure id=\"figure-module-graph-simple\" caption=\"A simple module graph\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"figure-module-graph-simple\">#figure-module-graph-simple</span>: A simple module graph</figcaption>\n            <img alt=\"A module graph in which module A depends on module B, and module B depends on module C\" width=\"121\" height=\"211\" src=\"img/module-graph-simple.svg\">\n          </figure></emu-figure>\n\n          <p>Let's first assume that there are no error conditions. When a host first calls <var>A</var>.Link(), this will complete successfully by assumption, and recursively link modules <var>B</var> and <var>C</var> as well, such that <var>A</var>.[[Status]] = <var>B</var>.[[Status]] = <var>C</var>.[[Status]] = <code>\"linked\"</code>. This preparatory step can be performed at any time. Later, when the host is ready to incur any possible side effects of the modules, it can call <var>A</var>.Evaluate(), which will complete successfully (again by assumption), recursively having evaluated first <var>C</var> and then <var>B</var>. Each module's [[Status]] at this point will be <code>\"evaluated\"</code>.</p>\n\n          <p>Consider then cases involving linking errors. If <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> of <var>C</var> succeeds but, thereafter, fails for <var>B</var>, for example because it imports something that <var>C</var> does not provide, then the original <var>A</var>.Link() will fail, and both <var>A</var> and <var>B</var>'s [[Status]] remain <code>\"unlinked\"</code>. <var>C</var>'s [[Status]] has become <code>\"linked\"</code>, though.</p>\n\n          <p>Finally, consider a case involving evaluation errors. If <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref> of <var>C</var> succeeds but, thereafter, fails for <var>B</var>, for example because <var>B</var> contains code that throws an exception, then the original <var>A</var>.Evaluate() will fail. The resulting exception will be recorded in both <var>A</var> and <var>B</var>'s [[EvaluationError]] fields, and their [[Status]] will become <code>\"evaluated\"</code>. <var>C</var> will also become <code>\"evaluated\"</code> but, in contrast to <var>A</var> and <var>B</var>, will remain without an [[EvaluationError]], as it successfully completed evaluation. Storing the exception ensures that any time a host tries to reuse <var>A</var> or <var>B</var> by calling their Evaluate() method, it will encounter the same exception. (Hosts are not required to reuse Cyclic Module Records; similarly, hosts are not required to expose the exception objects thrown by these  methods. However, the specification enables such uses.)</p>\n\n          <p>The difference here between linking and evaluation errors is due to how evaluation must be only performed once, as it can cause side effects; it is thus important to remember whether evaluation has already been performed, even if unsuccessfully. (In the error case, it makes sense to also remember the exception because otherwise subsequent Evaluate() calls would have to synthesize a new one.) Linking, on the other hand, is side-effect-free, and thus even if it fails, it can be retried at a later time with no issues.</p>\n\n          <p>Now consider a different type of error condition:</p>\n\n          <emu-figure id=\"figure-module-graph-missing\" caption=\"A module graph with an unresolvable module\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"figure-module-graph-missing\">#figure-module-graph-missing</span>: A module graph with an unresolvable module</figcaption>\n            <img alt=\"A module graph in which module A depends on a missing (unresolvable) module, represented by ???\" width=\"121\" height=\"121\" src=\"img/module-graph-missing.svg\">\n          </figure></emu-figure>\n\n          <p>In this scenario, module <var>A</var> declares a dependency on some other module, but no <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> exists for that module, i.e. <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> throws an exception when asked for it. This could occur for a variety of reasons, such as the corresponding resource not existing, or the resource existing but <emu-xref aoid=\"ParseModule\"><a href=\"#sec-parsemodule\">ParseModule</a></emu-xref> throwing an exception when trying to parse the resulting source text. Hosts can choose to expose the cause of failure via the exception they throw from <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>. In any case, this exception causes a linking failure, which as before results in <var>A</var>'s [[Status]] remaining <code>\"unlinked\"</code>.</p>\n\n          <p>Lastly, consider a module graph with a cycle:</p>\n\n          <emu-figure id=\"figure-module-graph-cycle\" caption=\"A cyclic module graph\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"figure-module-graph-cycle\">#figure-module-graph-cycle</span>: A cyclic module graph</figcaption>\n            <img alt=\"A module graph in which module A depends on module B and C, but module B also depends on module A\" width=\"181\" height=\"121\" src=\"img/module-graph-cycle.svg\">\n          </figure></emu-figure>\n\n          <p>Here we assume that the entry point is module <var>A</var>, so that the host proceeds by calling <var>A</var>.Link(), which performs <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>. This in turn calls <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>B</var>. Because of the cycle, this again triggers <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>, but at this point it is a no-op since <var>A</var>.[[Status]] is already <code>\"linking\"</code>. <var>B</var>.[[Status]] itself remains <code>\"linking\"</code> when control gets back to <var>A</var> and <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> is triggered on <var>C</var>. After this returns with <var>C</var>.[[Status]] being <code>\"linked\"</code> , both <var>A</var> and <var>B</var> transition from <code>\"linking\"</code> to <code>\"linked\"</code> together; this is by design, since they form a strongly connected component.</p>\n\n          <p>An analogous story occurs for the evaluation phase of a cyclic module graph, in the success case.</p>\n\n          <p>Now consider a case where <var>A</var> has an linking error; for example, it tries to import a binding from <var>C</var> that does not exist. In that case, the above steps still occur, including the early return from the second call to <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>. However, once we unwind back to the original <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref> on <var>A</var>, it fails during ModuleDeclarationEnvironmentSetup, namely right after <var>C</var>.ResolveExport(). The thrown <emu-val>SyntaxError</emu-val> exception propagates up to <var>A</var>.Link, which resets all modules that are currently on its <var>stack</var> (these are always exactly the modules that are still <code>\"linking\"</code>). Hence both <var>A</var> and <var>B</var> become <code>\"unlinked\"</code>. Note that <var>C</var> is left as <code>\"linked\"</code>.</p>\n\n          <p>Finally, consider a case where <var>A</var> has an evaluation error; for example, its source code throws an exception. In that case, the evaluation-time analog of the above steps still occurs, including the early return from the second call to <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref> on <var>A</var>. However, once we unwind back to the original <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref> on <var>A</var>, it fails by assumption. The exception thrown propagates up to <var>A</var>.Evaluate(), which records the error in all modules that are currently on its <var>stack</var> (i.e., the modules that are still <code>\"evaluating\"</code>). Hence both <var>A</var> and <var>B</var> become <code>\"evaluated\"</code> and the exception is recorded in both <var>A</var> and <var>B</var>'s [[EvaluationError]] fields, while <var>C</var> is left as <code>\"evaluated\"</code> with no [[EvaluationError]].</p>\n        </emu-clause>\n      "}}, "figData": {"figure-module-graph-simple": "Figure 2", "figure-module-graph-missing": "Figure 3", "figure-module-graph-cycle": "Figure 4"}}}