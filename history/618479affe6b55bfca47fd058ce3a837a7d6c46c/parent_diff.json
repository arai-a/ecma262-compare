{"from": {"secList": ["sec-array.prototype.sort"], "secData": {"sec-array.prototype.sort": {"num": "22.1.3.27", "title": "#sec-array.prototype.sort Array.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-array.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</span> Array.prototype.sort ( <var>comparefn</var> )</h1>\n        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If <var>comparefn</var> is not <emu-val>undefined</emu-val>, it should be a function that accepts two arguments <var>x</var> and <var>y</var> and returns a negative value if <var>x</var> &lt; <var>y</var>, zero if <var>x</var> = <var>y</var>, or a positive value if <var>x</var> &gt; <var>y</var>.</p>\n        <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>obj</var>).\n        </li></ol></emu-alg>\n        <p>Within this specification of the <code>sort</code> method, an object, <var>obj</var>, is said to be  <em>sparse</em> if the following algorithm returns <emu-val>true</emu-val>:</p>\n        <emu-alg><ol><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> in the range 0 &#8804; <var>i</var> &lt; <var>len</var>, do<ol><li>Let <var>elem</var> be <var>obj</var>.[[GetOwnProperty]](! <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>i</var>)).</li><li>If <var>elem</var> is <emu-val>undefined</emu-val>, return <emu-val>true</emu-val>.</li></ol></li><li>Return <emu-val>false</emu-val>.\n        </li></ol></emu-alg>\n        <p>The  <em>sort order</em> is the ordering, after completion of this function, of the  <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> property values of <var>obj</var> whose <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> indexes are less than <var>len</var>. The result of the <code>sort</code> function is then determined as follows:</p>\n        <p>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and is not a consistent comparison function for the elements of this array (see below), the sort order is implementation-defined. The sort order is also implementation-defined if <var>comparefn</var> is <emu-val>undefined</emu-val> and <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> does not act as a consistent comparison function.</p>\n        <p>Let <var>proto</var> be <var>obj</var>.[[GetPrototypeOf]](). If <var>proto</var> is not <emu-val>null</emu-val> and there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> such that all of the conditions below are satisfied then the sort order is implementation-defined:</p>\n        <ul>\n          <li>\n            <var>obj</var> is sparse\n          \n          </li>\n          <li>\n            0 &#8804; <var>j</var> &lt; <var>len</var>\n          \n          </li>\n          <li>\n            <emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>proto</var>, <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>j</var>)) is <emu-val>true</emu-val>.\n          \n          </li>\n        </ul>\n        <p>The sort order is also implementation-defined if <var>obj</var> is sparse and any of the following conditions are true:</p>\n        <ul>\n          <li>\n            <emu-xref aoid=\"IsExtensible\"><a href=\"#sec-isextensible-o\">IsExtensible</a></emu-xref>(<var>obj</var>) is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            Any <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer index</a></emu-xref> property of <var>obj</var> whose name is a nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var> is a <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">data property</a></emu-xref> whose [[Configurable]] attribute is <emu-val>false</emu-val>.\n          \n          </li>\n        </ul>\n        <p>The sort order is also implementation-defined if any of the following conditions are true:</p>\n        <ul>\n          <li>\n            If <var>obj</var> is an <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">exotic object</a></emu-xref> (including Proxy exotic objects) whose behaviour for [[Get]], [[Set]], [[Delete]], and [[GetOwnProperty]] is not the ordinary object implementation of these internal methods.\n          \n          </li>\n          <li>\n            If any index property of <var>obj</var> whose name is a nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var> is an <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">accessor property</a></emu-xref> or is a <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">data property</a></emu-xref> whose [[Writable]] attribute is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and the application of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> to any value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> modifies <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          \n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and all applications of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>, to any specific value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>, do not produce the same result.\n          \n          </li>\n        </ul>\n        <p>The following steps are taken:</p>\n        <emu-alg><ol><li>Perform an implementation-dependent sequence of calls to the [[Get]] and [[Set]] internal methods of <var>obj</var>, to the <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> and <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref> abstract operation with <var>obj</var> as the first argument, and to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> (described below), such that:<ul><li>The property key argument for each call to [[Get]], [[Set]], <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref>, or <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> is the string representation of a nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var>.</li><li>The arguments for calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> are values returned by a previous call to the [[Get]] internal method, unless the properties accessed by those previous calls did not exist according to <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref>. If both prospective arguments to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> correspond to non-existent properties, use <emu-val>+0</emu-val> instead of calling <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>. If only the first prospective argument is non-existent use +1. If only the second prospective argument is non-existent use -1.</li><li>If <var>obj</var> is not sparse then <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> must not be called.</li><li>If any [[Set]] call returns <emu-val>false</emu-val> a <emu-val>TypeError</emu-val> exception is thrown.</li><li>If an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> is returned from any of these operations, it is immediately returned as the value of this function.</li></ul></li><li>Return <var>obj</var>.\n        </li></ol></emu-alg>\n        <p>Unless the sort order is specified above to be implementation-defined, the returned object must have the following two characteristics:</p>\n        <ul>\n          <li>\n            There must be some mathematical permutation &#960; of the nonnegative integers less than <var>len</var>, such that for every nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> less than <var>len</var>, if property  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> existed, then  <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn> is exactly the same value as  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn>. But if property  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> did not exist, then  <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn> does not exist.\n          \n          </li>\n          <li>\n            Then for all nonnegative integers <var>j</var> and <var>k</var>, each less than <var>len</var>, if  <emu-eqn class=\"inline\"><emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>(old[<var>j</var>], old[<var>k</var>]) &lt; 0</emu-eqn> (see <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> below), then  <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)] &lt; new[&#960;(<var>k</var>)]</emu-eqn>.\n          \n          </li>\n        </ul>\n        <p>Here the notation  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is used to refer to the hypothetical result of calling <var>obj</var>.[[Get]](<var>j</var>) before this function is executed, and the notation  <emu-eqn class=\"inline\">new[<var>j</var>]</emu-eqn> to refer to the hypothetical result of calling <var>obj</var>.[[Get]](<var>j</var>) after this function has been executed.</p>\n        <p>A function <var>comparefn</var> is a consistent comparison function for a set of values <var>S</var> if all of the requirements below are met for all values <var>a</var>, <var>b</var>, and <var>c</var> (possibly the same value) in the set <var>S</var>: The notation  <emu-eqn class=\"inline\"><var>a</var> &lt;<sub>CF</sub> <var>b</var></emu-eqn> means  <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &lt; 0</emu-eqn>;  <emu-eqn class=\"inline\"><var>a</var> =<sub>CF</sub> <var>b</var></emu-eqn> means  <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) = 0</emu-eqn> (of either sign); and  <emu-eqn class=\"inline\"><var>a</var> &gt;<sub>CF</sub> <var>b</var></emu-eqn> means  <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &gt; 0</emu-eqn>.</p>\n        <ul>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) always returns the same value <var>v</var> when given a specific pair of values <var>a</var> and <var>b</var> as its two arguments. Furthermore, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>v</var>) is Number, and <var>v</var> is not <emu-val>NaN</emu-val>. Note that this implies that exactly one of <var>a</var> &lt;<sub>CF</sub> <var>b</var>, <var>a</var> =<sub>CF</sub> <var>b</var>, and <var>a</var> &gt;<sub>CF</sub> <var>b</var> will be true for a given pair of <var>a</var> and <var>b</var>.\n          \n          </li>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) does not modify <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          \n          </li>\n          <li>\n            <var>a</var> =<sub>CF</sub> <var>a</var> (reflexivity)\n          \n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var>, then <var>b</var> =<sub>CF</sub> <var>a</var> (symmetry)\n          \n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var> and <var>b</var> =<sub>CF</sub> <var>c</var>, then <var>a</var> =<sub>CF</sub> <var>c</var> (transitivity of =<sub>CF</sub>)\n          \n          </li>\n          <li>\n            If <var>a</var> &lt;<sub>CF</sub> <var>b</var> and <var>b</var> &lt;<sub>CF</sub> <var>c</var>, then <var>a</var> &lt;<sub>CF</sub> <var>c</var> (transitivity of &lt;<sub>CF</sub>)\n          \n          </li>\n          <li>\n            If <var>a</var> &gt;<sub>CF</sub> <var>b</var> and <var>b</var> &gt;<sub>CF</sub> <var>c</var>, then <var>a</var> &gt;<sub>CF</sub> <var>c</var> (transitivity of &gt;<sub>CF</sub>)\n          \n          </li>\n        </ul>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The above conditions are necessary and sufficient to ensure that <var>comparefn</var> divides the set <var>S</var> into equivalence classes and that these equivalence classes are totally ordered.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>sort</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-sortcompare\"><h1><span class=\"secnum\">22.1.3.27.1</span>#sec-sortcompare Runtime Semantics: SortCompare ( x, y )</h1>...</div></emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-array.prototype.sort"], "secData": {"sec-array.prototype.sort": {"num": "22.1.3.27", "title": "#sec-array.prototype.sort Array.prototype.sort ( comparefn )", "html": "<emu-clause id=\"sec-array.prototype.sort\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.sort\">#sec-array.prototype.sort</span> Array.prototype.sort ( <var>comparefn</var> )</h1>\n        <p>The elements of this array are sorted. The sort must be stable (that is, elements that compare equal must remain in their original order). If <var>comparefn</var> is not <emu-val>undefined</emu-val>, it should be a function that accepts two arguments <var>x</var> and <var>y</var> and returns a negative value if <var>x</var> &lt; <var>y</var>, zero if <var>x</var> = <var>y</var>, or a positive value if <var>x</var> &gt; <var>y</var>.</p>\n        <p>Upon entry, the following steps are performed to initialize evaluation of the <code>sort</code> function:</p>\n        <emu-alg><ol><li>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>comparefn</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>obj</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>obj</var>).\n        </li></ol></emu-alg>\n        <p>Within this specification of the <code>sort</code> method, an object, <var>obj</var>, is said to be  <em>sparse</em> if the following algorithm returns <emu-val>true</emu-val>:</p>\n        <emu-alg><ol><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> in the range 0 &#8804; <var>i</var> &lt; <var>len</var>, do<ol><li>Let <var>elem</var> be <var>obj</var>.[[GetOwnProperty]](! <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>i</var>)).</li><li>If <var>elem</var> is <emu-val>undefined</emu-val>, return <emu-val>true</emu-val>.</li></ol></li><li>Return <emu-val>false</emu-val>.\n        </li></ol></emu-alg>\n        <p>The  <em>sort order</em> is the ordering, after completion of this function, of the  <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer-indexed</a></emu-xref> property values of <var>obj</var> whose <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> indexes are less than <var>len</var>. The result of the <code>sort</code> function is then determined as follows:</p>\n        <p>If <var>comparefn</var> is not <emu-val>undefined</emu-val> and is not a consistent comparison function for the elements of this array (see below), the sort order is implementation-defined. The sort order is also implementation-defined if <var>comparefn</var> is <emu-val>undefined</emu-val> and <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> does not act as a consistent comparison function.</p>\n        <p>Let <var>proto</var> be <var>obj</var>.[[GetPrototypeOf]](). If <var>proto</var> is not <emu-val>null</emu-val> and there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> such that all of the conditions below are satisfied then the sort order is implementation-defined:</p>\n        <ul>\n          <li>\n            <var>obj</var> is sparse\n          \n          </li>\n          <li>\n            0 &#8804; <var>j</var> &lt; <var>len</var>\n          \n          </li>\n          <li>\n            <emu-xref aoid=\"HasProperty\"><a href=\"#sec-hasproperty\">HasProperty</a></emu-xref>(<var>proto</var>, <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>j</var>)) is <emu-val>true</emu-val>.\n          \n          </li>\n        </ul>\n        <p>The sort order is also implementation-defined if <var>obj</var> is sparse and any of the following conditions are true:</p>\n        <ul>\n          <li>\n            <emu-xref aoid=\"IsExtensible\"><a href=\"#sec-isextensible-o\">IsExtensible</a></emu-xref>(<var>obj</var>) is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            Any <emu-xref href=\"#integer-index\"><a href=\"#integer-index\">integer index</a></emu-xref> property of <var>obj</var> whose name is a nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var> is a <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">data property</a></emu-xref> whose [[Configurable]] attribute is <emu-val>false</emu-val>.\n          \n          </li>\n        </ul>\n        <p>The sort order is also implementation-defined if any of the following conditions are true:</p>\n        <ul>\n          <li>\n            If <var>obj</var> is an <emu-xref href=\"#exotic-object\"><a href=\"#exotic-object\">exotic object</a></emu-xref> (including Proxy exotic objects) whose behaviour for [[Get]], [[Set]], [[Delete]], and [[GetOwnProperty]] is not the ordinary object implementation of these internal methods.\n          \n          </li>\n          <li>\n            If any index property of <var>obj</var> whose name is a nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var> is an <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">accessor property</a></emu-xref> or is a <emu-xref href=\"#sec-object-type\"><a href=\"#sec-object-type\">data property</a></emu-xref> whose [[Writable]] attribute is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and the application of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref> to any value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> modifies <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          \n          </li>\n          <li>\n            If <var>comparefn</var> is <emu-val>undefined</emu-val> and all applications of <emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>, to any specific value passed as an argument to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>, do not produce the same result.\n          \n          </li>\n        </ul>\n        <p>The following steps are taken:</p>\n        <emu-alg><ol><li>Perform an implementation-dependent sequence of calls to the <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>, <emu-xref href=\"#sec-set-o-p-v-throw\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>, <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref>, and <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref> abstract operation with <var>obj</var> as the first argument, and to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> (described below), such that:<ul><li>The property key argument for each call to <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>, <emu-xref href=\"#sec-set-o-p-v-throw\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>, <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref>, or <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> is the string representation of a nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> less than <var>len</var>.</li><li>The <code>Throw</code> argument for every call to <emu-xref href=\"#sec-set-o-p-v-throw\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref> is <emu-val>true</emu-val>.</li><li>The arguments for calls to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> are values returned by a previous call to the <emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref> abstract operation, unless the properties accessed by those previous calls did not exist according to <emu-xref aoid=\"HasOwnProperty\"><a href=\"#sec-hasownproperty\">HasOwnProperty</a></emu-xref>. If both prospective arguments to <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> correspond to non-existent properties, use <emu-val>+0</emu-val> instead of calling <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>. If only the first prospective argument is non-existent use +1. If only the second prospective argument is non-existent use -1.</li><li>If <var>obj</var> is not sparse then <emu-xref aoid=\"DeletePropertyOrThrow\"><a href=\"#sec-deletepropertyorthrow\">DeletePropertyOrThrow</a></emu-xref> must not be called.</li><li>If an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> is returned from any of these operations, it is immediately returned as the value of this function.</li></ul></li><li>Return <var>obj</var>.\n        </li></ol></emu-alg>\n        <p>Unless the sort order is specified above to be implementation-defined, the returned object must have the following two characteristics:</p>\n        <ul>\n          <li>\n            There must be some mathematical permutation &#960; of the nonnegative integers less than <var>len</var>, such that for every nonnegative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>j</var> less than <var>len</var>, if property  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> existed, then  <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn> is exactly the same value as  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn>. But if property  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> did not exist, then  <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)]</emu-eqn> does not exist.\n          \n          </li>\n          <li>\n            Then for all nonnegative integers <var>j</var> and <var>k</var>, each less than <var>len</var>, if  <emu-eqn class=\"inline\"><emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref>(old[<var>j</var>], old[<var>k</var>]) &lt; 0</emu-eqn> (see <emu-xref aoid=\"SortCompare\"><a href=\"#sec-sortcompare\">SortCompare</a></emu-xref> below), then  <emu-eqn class=\"inline\">new[&#960;(<var>j</var>)] &lt; new[&#960;(<var>k</var>)]</emu-eqn>.\n          \n          </li>\n        </ul>\n        <p>Here the notation  <emu-eqn class=\"inline\">old[<var>j</var>]</emu-eqn> is used to refer to the hypothetical result of calling  <emu-eqn class=\"inline\"><emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>j</var>)</emu-eqn> before this function is executed, and the notation  <emu-eqn class=\"inline\">new[<var>j</var>]</emu-eqn> to refer to the hypothetical result of calling  <emu-eqn class=\"inline\"><emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>obj</var>, <var>j</var>)</emu-eqn> after this function has been executed.</p>\n        <p>A function <var>comparefn</var> is a consistent comparison function for a set of values <var>S</var> if all of the requirements below are met for all values <var>a</var>, <var>b</var>, and <var>c</var> (possibly the same value) in the set <var>S</var>: The notation  <emu-eqn class=\"inline\"><var>a</var> &lt;<sub>CF</sub> <var>b</var></emu-eqn> means  <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &lt; 0</emu-eqn>;  <emu-eqn class=\"inline\"><var>a</var> =<sub>CF</sub> <var>b</var></emu-eqn> means  <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) = 0</emu-eqn> (of either sign); and  <emu-eqn class=\"inline\"><var>a</var> &gt;<sub>CF</sub> <var>b</var></emu-eqn> means  <emu-eqn class=\"inline\"><var>comparefn</var>(<var>a</var>, <var>b</var>) &gt; 0</emu-eqn>.</p>\n        <ul>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) always returns the same value <var>v</var> when given a specific pair of values <var>a</var> and <var>b</var> as its two arguments. Furthermore, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>v</var>) is Number, and <var>v</var> is not <emu-val>NaN</emu-val>. Note that this implies that exactly one of <var>a</var> &lt;<sub>CF</sub> <var>b</var>, <var>a</var> =<sub>CF</sub> <var>b</var>, and <var>a</var> &gt;<sub>CF</sub> <var>b</var> will be true for a given pair of <var>a</var> and <var>b</var>.\n          \n          </li>\n          <li>\n            Calling <var>comparefn</var>(<var>a</var>, <var>b</var>) does not modify <var>obj</var> or any object on <var>obj</var>'s prototype chain.\n          \n          </li>\n          <li>\n            <var>a</var> =<sub>CF</sub> <var>a</var> (reflexivity)\n          \n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var>, then <var>b</var> =<sub>CF</sub> <var>a</var> (symmetry)\n          \n          </li>\n          <li>\n            If <var>a</var> =<sub>CF</sub> <var>b</var> and <var>b</var> =<sub>CF</sub> <var>c</var>, then <var>a</var> =<sub>CF</sub> <var>c</var> (transitivity of =<sub>CF</sub>)\n          \n          </li>\n          <li>\n            If <var>a</var> &lt;<sub>CF</sub> <var>b</var> and <var>b</var> &lt;<sub>CF</sub> <var>c</var>, then <var>a</var> &lt;<sub>CF</sub> <var>c</var> (transitivity of &lt;<sub>CF</sub>)\n          \n          </li>\n          <li>\n            If <var>a</var> &gt;<sub>CF</sub> <var>b</var> and <var>b</var> &gt;<sub>CF</sub> <var>c</var>, then <var>a</var> &gt;<sub>CF</sub> <var>c</var> (transitivity of &gt;<sub>CF</sub>)\n          \n          </li>\n        </ul>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>The above conditions are necessary and sufficient to ensure that <var>comparefn</var> divides the set <var>S</var> into equivalence classes and that these equivalence classes are totally ordered.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>sort</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore, it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-sortcompare\"><h1><span class=\"secnum\">22.1.3.27.1</span>#sec-sortcompare Runtime Semantics: SortCompare ( x, y )</h1>...</div></emu-clause>\n\n      "}}, "figData": {}}}