{"from": {"secList": ["sec-compileassertion", "sec-compilepattern"], "secData": {"sec-compileassertion": {"num": "22.2.2.4", "title": "#sec-compileassertion Runtime Semantics: CompileAssertion", "html": "<emu-clause id=\"sec-compileassertion\" type=\"sdo\" oldids=\"sec-assertion\" aoid=\"CompileAssertion\"><span id=\"sec-assertion\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compileassertion\">#sec-compileassertion</span> Runtime Semantics: CompileAssertion</h1>\n        <p>The syntax-directed operation CompileAssertion takes no arguments. It returns a Matcher.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>This section is amended in <emu-xref href=\"#sec-compileassertion-annexb\"><a href=\"#sec-compileassertion-annexb\" class=\"excluded-xref\" excluded-id=\"sec-compileassertion-annexb\">#sec-compileassertion-annexb</a></emu-xref>.</p>\n        </div></emu-note>\n        <p>It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"5yeieuod\" id=\"prod-sVm_wok4\"><emu-t>^</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> = 0, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var> - 1] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Return <var>c</var>(<var>x</var>).</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>Even when the <code>y</code> flag is used with a pattern, <code>^</code> always matches only at the beginning of <var>Input</var>, or (if <var>Multiline</var> is <emu-val>true</emu-val>) at the beginning of a line.</p>\n        </div></emu-note>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"emlmkqfm\" id=\"prod-STP3aqEM\"><emu-t>$</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> = <var>InputLength</var>, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var>] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Return <var>c</var>(<var>x</var>).</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"hiknpumm\" id=\"prod-ViPM0g4q\">\n        <emu-t>\\</emu-t>\n        <emu-t>b</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>a</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1).</li><li>Let <var>b</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>).</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"pdyx-jbz\" id=\"prod-zZ_Qgb0r\">\n        <emu-t>\\</emu-t>\n        <emu-t>B</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>a</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1).</li><li>Let <var>b</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>).</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>true</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>false</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"z7lplbsq\" id=\"prod-K3dw8gDB\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>=</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument 1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>z</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"upj24t7r\" id=\"prod-aFJAHEX0\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>!</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument 1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Return <var>c</var>(<var>x</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"jbn7vi8y\" id=\"prod-ITDs20e0\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>&lt;=</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument -1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>z</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"gweywjfp\" id=\"prod-Oce7U7TP\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>&lt;!</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument -1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Return <var>c</var>(<var>x</var>).</li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-iswordchar-abstract-operation\"><h1><span class=\"secnum\">22.2.2.4.1</span>#sec-runtime-semantics-iswordchar-abstract-operation IsWordChar ( e )</h1>...</div></emu-clause>\n\n      "}, "sec-compilepattern": {"num": "22.2.2.2", "title": "#sec-compilepattern Runtime Semantics: CompilePattern", "html": "<emu-clause id=\"sec-compilepattern\" type=\"sdo\" oldids=\"sec-pattern\" aoid=\"CompilePattern\"><span id=\"sec-pattern\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compilepattern\">#sec-compilepattern</span> Runtime Semantics: CompilePattern</h1>\n        <p>The syntax-directed operation CompilePattern takes no arguments. It returns an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that takes a String and a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> and returns a MatchResult. It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Pattern\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"eaw70mcy\" id=\"prod-mHyeO4wo\"><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument 1.</li><li>Return a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>str</var>, <var>index</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>str</var>) is String.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>index</var> is a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> which is &#8804; the length of <var>str</var>.</li><li>If <var>Unicode</var> is <emu-val>true</emu-val>, let <var>Input</var> be !&#160;<emu-xref aoid=\"StringToCodePoints\"><a href=\"#sec-stringtocodepoints\">StringToCodePoints</a></emu-xref>(<var>str</var>). Otherwise, let <var>Input</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the code units that are the elements of <var>str</var>. <var>Input</var> will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>. Each element of <var>Input</var> is considered to be a character.</li><li>Let <var>InputLength</var> be the number of characters contained in <var>Input</var>. This alias will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>.</li><li>Let <var>listIndex</var> be the index into <var>Input</var> of the character that was obtained from element <var>index</var> of <var>str</var>.</li><li>Let <var>c</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>cap</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> <emu-val>undefined</emu-val> values, indexed 1 through <var>NcapturingParens</var>.</li><li>Let <var>x</var> be the State (<var>listIndex</var>, <var>cap</var>).</li><li>Return <var>m</var>(<var>x</var>, <var>c</var>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>A Pattern compiles to an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> value. <emu-xref aoid=\"RegExpBuiltinExec\"><a href=\"#sec-regexpbuiltinexec\">RegExpBuiltinExec</a></emu-xref> can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref> are designed so that compiling a pattern may throw a <emu-val>SyntaxError</emu-val> exception; on the other hand, once the pattern is successfully compiled, applying the resulting <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> to find a match in a String cannot throw an exception (except for any <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> exceptions that can occur anywhere such as out-of-memory).</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}}, "figData": {}}, "to": {"secList": ["sec-compileassertion", "sec-compilepattern"], "secData": {"sec-compileassertion": {"num": "22.2.2.4", "title": "#sec-compileassertion Runtime Semantics: CompileAssertion", "html": "<emu-clause id=\"sec-compileassertion\" type=\"sdo\" oldids=\"sec-assertion\" aoid=\"CompileAssertion\"><span id=\"sec-assertion\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compileassertion\">#sec-compileassertion</span> Runtime Semantics: CompileAssertion</h1>\n        <p>The syntax-directed operation CompileAssertion takes no arguments. It returns a Matcher.</p>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>This section is amended in <emu-xref href=\"#sec-compileassertion-annexb\"><a href=\"#sec-compileassertion-annexb\" class=\"excluded-xref\" excluded-id=\"sec-compileassertion-annexb\">#sec-compileassertion-annexb</a></emu-xref>.</p>\n        </div></emu-note>\n        <p>It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"5yeieuod\" id=\"prod-sVm_wok4\"><emu-t>^</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> = 0, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var> - 1] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Return <var>c</var>(<var>x</var>).</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>Even when the <code>y</code> flag is used with a pattern, <code>^</code> always matches only at the beginning of <var>Input</var>, or (if <var>Multiline</var> is <emu-val>true</emu-val>) at the beginning of a line.</p>\n        </div></emu-note>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"emlmkqfm\" id=\"prod-STP3aqEM\"><emu-t>$</emu-t></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> = <var>InputLength</var>, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var>] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Return <var>c</var>(<var>x</var>).</li></ol></li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"hiknpumm\" id=\"prod-ViPM0g4q\">\n        <emu-t>\\</emu-t>\n        <emu-t>b</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>a</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1).</li><li>Let <var>b</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>).</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"pdyx-jbz\" id=\"prod-zZ_Qgb0r\">\n        <emu-t>\\</emu-t>\n        <emu-t>B</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>a</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1).</li><li>Let <var>b</var> be !&#160;<emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>).</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>true</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>false</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Return <emu-const>failure</emu-const>.</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"z7lplbsq\" id=\"prod-K3dw8gDB\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>=</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <emu-const>forward</emu-const>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>z</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"upj24t7r\" id=\"prod-aFJAHEX0\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>!</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <emu-const>forward</emu-const>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Return <var>c</var>(<var>x</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"jbn7vi8y\" id=\"prod-ITDs20e0\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>&lt;=</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <emu-const>backward</emu-const>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Return <var>c</var>(<var>z</var>).</li></ol></li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"gweywjfp\" id=\"prod-Oce7U7TP\">\n        <emu-t>(</emu-t>\n        <emu-t>?</emu-t>\n        <emu-t>&lt;!</emu-t>\n        <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>\n        <emu-t>)</emu-t>\n    </emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <emu-const>backward</emu-const>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>r</var> be <var>m</var>(<var>x</var>, <var>d</var>).</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Return <var>c</var>(<var>x</var>).</li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-iswordchar-abstract-operation\"><h1><span class=\"secnum\">22.2.2.4.1</span>#sec-runtime-semantics-iswordchar-abstract-operation IsWordChar ( e )</h1>...</div></emu-clause>\n\n      "}, "sec-compilepattern": {"num": "22.2.2.2", "title": "#sec-compilepattern Runtime Semantics: CompilePattern", "html": "<emu-clause id=\"sec-compilepattern\" type=\"sdo\" oldids=\"sec-pattern\" aoid=\"CompilePattern\"><span id=\"sec-pattern\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-compilepattern\">#sec-compilepattern</span> Runtime Semantics: CompilePattern</h1>\n        <p>The syntax-directed operation CompilePattern takes no arguments. It returns an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> that takes a String and a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> and returns a MatchResult. It is defined piecewise over the following productions:</p>\n        <emu-grammar><emu-production name=\"Pattern\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> <emu-geq>::</emu-geq> <emu-rhs a=\"eaw70mcy\" id=\"prod-mHyeO4wo\"><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt></emu-rhs>\n</emu-production>\n</emu-grammar>\n        <emu-alg><ol><li>Let <var>m</var> be <emu-xref aoid=\"CompileSubpattern\"><a href=\"#sec-compilesubpattern\">CompileSubpattern</a></emu-xref> of <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <emu-const>forward</emu-const>.</li><li>Return a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> with parameters (<var>str</var>, <var>index</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>str</var>) is String.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>index</var> is a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> which is &#8804; the length of <var>str</var>.</li><li>If <var>Unicode</var> is <emu-val>true</emu-val>, let <var>Input</var> be !&#160;<emu-xref aoid=\"StringToCodePoints\"><a href=\"#sec-stringtocodepoints\">StringToCodePoints</a></emu-xref>(<var>str</var>). Otherwise, let <var>Input</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the code units that are the elements of <var>str</var>. <var>Input</var> will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>. Each element of <var>Input</var> is considered to be a character.</li><li>Let <var>InputLength</var> be the number of characters contained in <var>Input</var>. This alias will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>.</li><li>Let <var>listIndex</var> be the index into <var>Input</var> of the character that was obtained from element <var>index</var> of <var>str</var>.</li><li>Let <var>c</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>cap</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> <emu-val>undefined</emu-val> values, indexed 1 through <var>NcapturingParens</var>.</li><li>Let <var>x</var> be the State (<var>listIndex</var>, <var>cap</var>).</li><li>Return <var>m</var>(<var>x</var>, <var>c</var>).</li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>A Pattern compiles to an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> value. <emu-xref aoid=\"RegExpBuiltinExec\"><a href=\"#sec-regexpbuiltinexec\">RegExpBuiltinExec</a></emu-xref> can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref> are designed so that compiling a pattern may throw a <emu-val>SyntaxError</emu-val> exception; on the other hand, once the pattern is successfully compiled, applying the resulting <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">Abstract Closure</a></emu-xref> to find a match in a String cannot throw an exception (except for any <emu-xref href=\"#implementation-defined\"><a href=\"#implementation-defined\">implementation-defined</a></emu-xref> exceptions that can occur anywhere such as out-of-memory).</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}}, "figData": {}}}