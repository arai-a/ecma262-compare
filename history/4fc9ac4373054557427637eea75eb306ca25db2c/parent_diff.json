{"from": {"secList": ["sec-async-function-constructor-arguments", "sec-asyncgeneratorresumenext", "sec-completion-record-specification-type", "sec-moduledeclarationlinking", "sec-getmodulenamespace", "sec-typeof-operator", "sec-hostimportmoduledynamically", "sec-innermoduleevaluation", "sec-hostensurecancompilestrings", "sec-runtime-semantics-destructuringassignmentevaluation", "sec-InnerModuleLinking", "sec-moduleevaluation", "sec-host-promise-rejection-tracker", "sec-asyncgenerator-prototype-tostringtag", "sec-copydataproperties", "sec-forward-progress", "sec-array.prototype.includes", "sec-parse-script", "sec-numericvalue", "sec-finishdynamicimport", "sec-source-text-module-record-initialize-environment", "sec-reflection", "sec-source-text-module-record-execute-module", "sec-%typedarray%-intrinsic-object", "sec-async-from-sync-iterator-value-unwrap-functions"], "secData": {"sec-async-function-constructor-arguments": {"num": "25.7.1.1", "title": "#sec-async-function-constructor-arguments AsyncFunction ( p1, p2, \u2026 , pn, body )", "html": "<emu-clause id=\"sec-async-function-constructor-arguments\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-function-constructor-arguments\">#sec-async-function-constructor-arguments</span> AsyncFunction ( <var>p1</var>, <var>p2</var>, &#8230; , <var>pn</var>, <var>body</var> )</h1>\n        <p>The last argument specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.</p>\n        <p>When the <code>AsyncFunction</code> function is called with some arguments <var>p1</var>, <var>p2</var>, &#8230; , <var>pn</var>, <var>body</var> (where <var>n</var> might be 0, that is, there are no <var>p</var> arguments, and where <var>body</var> might also not be provided), the following steps are taken:</p>\n\n\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>args</var> be the <var>argumentsList</var> that was passed to this function by [[Call]] or [[Construct]].</li><li>Return <emu-xref aoid=\"CreateDynamicFunction\"><a href=\"#sec-createdynamicfunction\">CreateDynamicFunction</a></emu-xref>(<var>C</var>, NewTarget, <emu-const>async</emu-const>, <var>args</var>).</li></ol></emu-alg>\n\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">See NOTE for <emu-xref href=\"#sec-function-p1-p2-pn-body\"><a href=\"#sec-function-p1-p2-pn-body\" class=\"excluded-xref\" excluded-id=\"sec-function-p1-p2-pn-body\">#sec-function-p1-p2-pn-body</a></emu-xref>.</div></emu-note>\n      </emu-clause>\n    "}, "sec-asyncgeneratorresumenext": {"num": "25.5.3.5", "title": "#sec-asyncgeneratorresumenext AsyncGeneratorResumeNext ( generator )", "html": "<emu-clause id=\"sec-asyncgeneratorresumenext\" aoid=\"AsyncGeneratorResumeNext\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorresumenext\">#sec-asyncgeneratorresumenext</span> AsyncGeneratorResumeNext ( <var>generator</var> )</h1>\n        <p>The abstract operation AsyncGeneratorResumeNext takes argument <var>generator</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var> is an AsyncGenerator instance.</li><li>Let <var>state</var> be <var>generator</var>.[[AsyncGeneratorState]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>state</var> is not <emu-const>executing</emu-const>.</li><li>If <var>state</var> is <emu-const>awaiting-return</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li>If <var>queue</var> is an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>, return <emu-val>undefined</emu-val>.</li><li>Let <var>next</var> be the value of the first element of <var>queue</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>next</var> is an AsyncGeneratorRequest record.</li><li>Let <var>completion</var> be <var>next</var>.[[Completion]].</li><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>state</var> is <emu-const>suspendedStart</emu-const>, then<ol><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>completed</emu-const>.</li><li>Set <var>state</var> to <emu-const>completed</emu-const>.</li></ol></li><li>If <var>state</var> is <emu-const>completed</emu-const>, then<ol><li>If <var>completion</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>awaiting-return</emu-const>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>completion</var>.[[Value]]).</li><li>Let <var>stepsFulfilled</var> be the algorithm steps defined in <emu-xref href=\"#async-generator-resume-next-return-processor-fulfilled\" title=\"\"><a href=\"#async-generator-resume-next-return-processor-fulfilled\">AsyncGeneratorResumeNext Return Processor Fulfilled Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsFulfilled</var>, &#171; [[Generator]] &#187;).</li><li>Set <var>onFulfilled</var>.[[Generator]] to <var>generator</var>.</li><li>Let <var>stepsRejected</var> be the algorithm steps defined in <emu-xref href=\"#async-generator-resume-next-return-processor-rejected\" title=\"\"><a href=\"#async-generator-resume-next-return-processor-rejected\">AsyncGeneratorResumeNext Return Processor Rejected Functions</a></emu-xref>.</li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsRejected</var>, &#171; [[Generator]] &#187;).</li><li>Set <var>onRejected</var>.[[Generator]] to <var>generator</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorReject\"><a href=\"#sec-asyncgeneratorreject\">AsyncGeneratorReject</a></emu-xref>(<var>generator</var>, <var>completion</var>.[[Value]]).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li></ol></li></ol></li><li>Else if <var>state</var> is <emu-const>completed</emu-const>, return !&#160;<emu-xref aoid=\"AsyncGeneratorResolve\"><a href=\"#sec-asyncgeneratorresolve\">AsyncGeneratorResolve</a></emu-xref>(<var>generator</var>, <emu-val>undefined</emu-val>, <emu-val>true</emu-val>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>state</var> is either <emu-const>suspendedStart</emu-const> or <emu-const>suspendedYield</emu-const>.</li><li>Let <var>genContext</var> be <var>generator</var>.[[AsyncGeneratorContext]].</li><li>Let <var>callerContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>callerContext</var>.</li><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>executing</emu-const>.</li><li>Push <var>genContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>genContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>genContext</var> using <var>completion</var> as the result of the operation that suspended it. Let <var>result</var> be the completion record returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is never an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>genContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>callerContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n        <emu-clause id=\"async-generator-resume-next-return-processor-fulfilled\">\n          <h1><span class=\"secnum\">25.5.3.5.1</span> AsyncGeneratorResumeNext Return Processor Fulfilled Functions</h1>\n          <p>An <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> specification device to unwrap promises passed in to the <emu-xref href=\"#sec-asyncgenerator-prototype-return\" title=\"\"><a href=\"#sec-asyncgenerator-prototype-return\">AsyncGenerator.prototype.return ( <var>value</var> )</a></emu-xref> method. Each <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function has a [[Generator]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function is called with argument <var>value</var>, the following steps are taken:</p>\n\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Set <var>F</var>.[[Generator]].[[AsyncGeneratorState]] to <emu-const>completed</emu-const>.</li><li>Return !&#160;<emu-xref aoid=\"AsyncGeneratorResolve\"><a href=\"#sec-asyncgeneratorresolve\">AsyncGeneratorResolve</a></emu-xref>(<var>F</var>.[[Generator]], <var>value</var>, <emu-val>true</emu-val>).</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function is 1.</p>\n        </emu-clause>\n\n        <emu-clause id=\"async-generator-resume-next-return-processor-rejected\">\n          <h1><span class=\"secnum\">25.5.3.5.2</span> AsyncGeneratorResumeNext Return Processor Rejected Functions</h1>\n          <p>An <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> specification device to unwrap promises passed in to the <emu-xref href=\"#sec-asyncgenerator-prototype-return\" title=\"\"><a href=\"#sec-asyncgenerator-prototype-return\">AsyncGenerator.prototype.return ( <var>value</var> )</a></emu-xref> method. Each <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function has a [[Generator]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function is called with argument <var>reason</var>, the following steps are taken:</p>\n\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Set <var>F</var>.[[Generator]].[[AsyncGeneratorState]] to <emu-const>completed</emu-const>.</li><li>Return !&#160;<emu-xref aoid=\"AsyncGeneratorReject\"><a href=\"#sec-asyncgeneratorreject\">AsyncGeneratorReject</a></emu-xref>(<var>F</var>.[[Generator]], <var>reason</var>).</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function is 1.</p>\n        </emu-clause>\n      </emu-clause>\n\n      "}, "sec-completion-record-specification-type": {"num": "6.2.3", "title": "#sec-completion-record-specification-type The Completion Record Specification Type", "html": "<emu-clause id=\"sec-completion-record-specification-type\" aoid=\"Completion\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completion-record-specification-type\">#sec-completion-record-specification-type</span> The Completion Record Specification Type</h1>\n      <p>The Completion type is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> used to explain the runtime propagation of values and control flow such as the behaviour of statements (<code>break</code>, <code>continue</code>, <code>return</code> and <code>throw</code>) that perform nonlocal transfers of control.</p>\n      <p>Values of the Completion type are <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> values whose fields are defined as by <emu-xref href=\"#table-8\"><a href=\"#table-8\" class=\"excluded-xref\" excluded-id=\"table-8\">#table-8</a></emu-xref>. Such values are referred to as <dfn>Completion Record</dfn>s.</p>\n      <emu-table id=\"table-8\" caption=\"Completion Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-8\">#table-8</span>: <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> Fields</figcaption>\n        <table>\n          <tbody>\n          <tr>\n            <th>\n              Field Name\n            </th>\n            <th>\n              Value\n            </th>\n            <th>\n              Meaning\n            </th>\n          </tr>\n          <tr>\n            <td>\n              [[Type]]\n            </td>\n            <td>\n              One of <emu-const>normal</emu-const>, <emu-const>break</emu-const>, <emu-const>continue</emu-const>, <emu-const>return</emu-const>, or <emu-const>throw</emu-const>\n            </td>\n            <td>\n              The type of completion that occurred.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Value]]\n            </td>\n            <td>\n              any <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref> or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The value that was produced.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Target]]\n            </td>\n            <td>\n              any ECMAScript string or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The target label for directed control transfers.\n            </td>\n          </tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <p>The term &#8220;<dfn>abrupt completion</dfn>&#8221; refers to any completion with a [[Type]] value other than <emu-const>normal</emu-const>.</p>\n\n      <emu-clause id=\"await\" aoid=\"Await\">\n        <h1><span class=\"secnum\">6.2.3.1</span> Await</h1>\n\n        <p>Algorithm steps that say</p>\n\n        <emu-alg><ol><li>Let <var>completion</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n        <p>mean the same thing as:</p>\n\n        <emu-alg><ol><li>Let <var>asyncContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li>Let <var>stepsFulfilled</var> be the algorithm steps defined in <emu-xref href=\"#await-fulfilled\" title=\"\"><a href=\"#await-fulfilled\">Await Fulfilled Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsFulfilled</var>, &#171; [[AsyncContext]] &#187;).</li><li>Set <var>onFulfilled</var>.[[AsyncContext]] to <var>asyncContext</var>.</li><li>Let <var>stepsRejected</var> be the algorithm steps defined in <emu-xref href=\"#await-rejected\" title=\"\"><a href=\"#await-rejected\">Await Rejected Functions</a></emu-xref>.</li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsRejected</var>, &#171; [[AsyncContext]] &#187;).</li><li>Set <var>onRejected</var>.[[AsyncContext]] to <var>asyncContext</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed with a <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> <var>completion</var>, the following steps of the algorithm that invoked <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> will be performed, with <var>completion</var> available.</li><li>Return.</li><li>NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of <var>asyncContext</var>.</li></ol></emu-alg>\n\n        <p>where all aliases in the above steps, with the exception of <var>completion</var>, are ephemeral and visible only in the steps pertaining to Await.</p>\n\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Await can be combined with the <code>?</code> and <code>!</code> prefixes, so that for example</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n          <p>means the same thing as:</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </div></emu-note>\n\n        <emu-clause id=\"await-fulfilled\">\n          <h1><span class=\"secnum\">6.2.3.1.1</span> Await Fulfilled Functions</h1>\n          <p>An <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> specification device to deliver the promise fulfillment value to the caller as a normal completion. Each <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function has an [[AsyncContext]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function is called with argument <var>value</var>, the following steps are taken:</p>\n\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>asyncContext</var> be <var>F</var>.[[AsyncContext]].</li><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>value</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function is 1.</p>\n        </emu-clause>\n\n        <emu-clause id=\"await-rejected\">\n          <h1><span class=\"secnum\">6.2.3.1.2</span> Await Rejected Functions</h1>\n          <p>An <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> specification device to deliver the promise rejection reason to the caller as an abrupt throw completion. Each <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function has an [[AsyncContext]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function is called with argument <var>reason</var>, the following steps are taken:</p>\n\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>asyncContext</var> be <var>F</var>.[[AsyncContext]].</li><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>reason</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function is 1.</p>\n        </emu-clause>\n      </emu-clause>\n\n      <div id=\"excluded-sec-normalcompletion\"><h1><span class=\"secnum\">6.2.3.2</span>#sec-normalcompletion NormalCompletion</h1>...</div><div id=\"excluded-sec-throwcompletion\"><h1><span class=\"secnum\">6.2.3.3</span>#sec-throwcompletion ThrowCompletion</h1>...</div><div id=\"excluded-sec-updateempty\"><h1><span class=\"secnum\">6.2.3.4</span>#sec-updateempty UpdateEmpty ( completionRecord, value )</h1>...</div></emu-clause>\n\n    "}, "sec-moduledeclarationlinking": {"num": "15.2.1.16.1", "title": "#sec-moduledeclarationlinking Link ( ) Concrete Method", "html": "<emu-clause id=\"sec-moduledeclarationlinking\" oldids=\"sec-moduledeclarationinstantiation\">\n          <span id=\"sec-moduledeclarationinstantiation\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-moduledeclarationlinking\">#sec-moduledeclarationlinking</span> Link ( ) Concrete Method</h1>\n          <p>The Link concrete method of a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> abstract method.</p>\n          <p>On success, Link transitions this module's [[Status]] from <emu-const>unlinked</emu-const> to <emu-const>linked</emu-const>. On failure, an exception is thrown and this module's [[Status]] remains <emu-const>unlinked</emu-const>.</p>\n          <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>):</p>\n\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is not <emu-const>linking</emu-const> or <emu-const>evaluating</emu-const>.</li><li>Let <var>stack</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>(<var>module</var>, <var>stack</var>, 0).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> in <var>stack</var>, do<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[Status]] is <emu-const>linking</emu-const>.</li><li>Set <var>m</var>.[[Status]] to <emu-const>unlinked</emu-const>.</li><li>Set <var>m</var>.[[Environment]] to <emu-val>undefined</emu-val>.</li><li>Set <var>m</var>.[[DFSIndex]] to <emu-val>undefined</emu-val>.</li><li>Set <var>m</var>.[[DFSAncestorIndex]] to <emu-val>undefined</emu-val>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>unlinked</emu-const>.</li><li>Return <var>result</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>linked</emu-const> or <emu-const>evaluated</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>stack</var> is empty.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <div id=\"excluded-sec-InnerModuleLinking\"><h1><span class=\"secnum\">15.2.1.16.1.1</span>#sec-InnerModuleLinking InnerModuleLinking ( module, stack, index )</h1>...</div></emu-clause>\n\n        "}, "sec-getmodulenamespace": {"num": "15.2.1.21", "title": "#sec-getmodulenamespace Runtime Semantics: GetModuleNamespace ( module )", "html": "<emu-clause id=\"sec-getmodulenamespace\" aoid=\"GetModuleNamespace\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getmodulenamespace\">#sec-getmodulenamespace</span> Runtime Semantics: GetModuleNamespace ( <var>module</var> )</h1>\n        <p>The abstract operation GetModuleNamespace takes argument <var>module</var>. It retrieves the Module Namespace Object representing <var>module</var>'s exports, lazily creating it the first time it was requested, and storing it in <var>module</var>.[[Namespace]] for future retrieval. It performs the following steps when called:</p>\n\n\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var> is an instance of a concrete subclass of <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>module</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then <var>module</var>.[[Status]] is not <emu-const>unlinked</emu-const>.</li><li>Let <var>namespace</var> be <var>module</var>.[[Namespace]].</li><li>If <var>namespace</var> is <emu-val>undefined</emu-val>, then<ol><li>Let <var>exportedNames</var> be ? <var>module</var>.GetExportedNames().</li><li>Let <var>unambiguousNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>name</var> that is an element of <var>exportedNames</var>, do<ol><li>Let <var>resolution</var> be ? <var>module</var>.ResolveExport(<var>name</var>).</li><li>If <var>resolution</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>, append <var>name</var> to <var>unambiguousNames</var>.</li></ol></li><li>Set <var>namespace</var> to <emu-xref aoid=\"ModuleNamespaceCreate\"><a href=\"#sec-modulenamespacecreate\">ModuleNamespaceCreate</a></emu-xref>(<var>module</var>, <var>unambiguousNames</var>).</li></ol></li><li>Return <var>namespace</var>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The only way GetModuleNamespace can throw is via one of the triggered <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> calls. Unresolvable names are simply excluded from the namespace at this point. They will lead to a real linking error later unless they are all ambiguous star exports that are not explicitly requested anywhere.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-typeof-operator": {"num": "12.5.5", "title": "#sec-typeof-operator The typeof Operator", "html": "<emu-clause id=\"sec-typeof-operator\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-typeof-operator\">#sec-typeof-operator</span> The <code>typeof</code> Operator</h1>\n\n      <div id=\"excluded-sec-typeof-operator-runtime-semantics-evaluation\"><h1><span class=\"secnum\">12.5.5.1</span>#sec-typeof-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation</h1>...</div></emu-clause>\n\n\n    "}, "sec-hostimportmoduledynamically": {"num": "15.2.1.19", "title": "#sec-hostimportmoduledynamically Runtime Semantics: HostImportModuleDynamically ( referencingScriptOrModule, specifier, promiseCapability )", "html": "<emu-clause id=\"sec-hostimportmoduledynamically\" aoid=\"HostImportModuleDynamically\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-hostimportmoduledynamically\">#sec-hostimportmoduledynamically</span> Runtime Semantics: HostImportModuleDynamically ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var> )</h1>\n        <p>HostImportModuleDynamically is an implementation-defined abstract operation that performs any necessary setup work in order to make available the module corresponding to the <emu-nt><a href=\"#prod-ModuleSpecifier\">ModuleSpecifier</a></emu-nt> String, <var>specifier</var>, occurring within the context of the script or module represented by the <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> or <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> <var>referencingScriptOrModule</var>. (<var>referencingScriptOrModule</var> may also be <emu-val>null</emu-val>, if there is no active script or module when the <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> expression occurs.) It then performs <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref> to finish the dynamic import process.</p>\n\n\n        <p>The implementation of HostImportModuleDynamically must conform to the following requirements:</p>\n\n        <ul>\n          <li>\n            The abstract operation must always complete normally with <emu-val>undefined</emu-val>. Success or failure must instead be signaled as discussed below.\n          </li>\n          <li>\n            The host environment must conform to one of the two following sets of requirements:\n            <dl>\n              <dt>Success path</dt>\n\n              <dd>\n                <ul>\n                  <li>At some future time, the host environment must perform <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>)).</li>\n\n                  <li>Any subsequent call to <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> after <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref> has completed, given the arguments <var>referencingScriptOrModule</var> and <var>specifier</var>, must complete normally.</li>\n\n                  <li>The completion value of any subsequent call to <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> after <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref> has completed, given the arguments <var>referencingScriptOrModule</var> and <var>specifier</var>, must be a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>\n                </ul>\n              </dd>\n\n              <dt>Failure path</dt>\n\n              <dd>\n                <ul>\n                  <li>At some future time, the host environment must perform <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>), with the <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> representing the cause of failure.</li>\n                </ul>\n              </dd>\n            </dl>\n          </li>\n          <li>\n            If the host environment takes the success path once for a given <var>referencingScriptOrModule</var>, <var>specifier</var> pair, it must always do so for subsequent calls.\n          </li>\n          <li>\n            The operation must not call <var>promiseCapability</var>.[[Resolve]] or <var>promiseCapability</var>.[[Reject]], but instead must treat <var>promiseCapability</var> as an opaque identifying value to be passed through to <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref>.\n          </li>\n        </ul>\n\n        <p>The actual process performed is implementation-defined, but typically consists of performing whatever I/O operations are necessary to allow <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> to synchronously retrieve the appropriate <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, and then calling its Evaluate concrete method. This might require performing similar normalization as <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> does.</p>\n      </emu-clause>\n\n      "}, "sec-innermoduleevaluation": {"num": "15.2.1.16.2.1", "title": "#sec-innermoduleevaluation InnerModuleEvaluation ( module, stack, index )", "html": "<emu-clause id=\"sec-innermoduleevaluation\" aoid=\"InnerModuleEvaluation\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-innermoduleevaluation\">#sec-innermoduleevaluation</span> InnerModuleEvaluation ( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>\n            <p>The abstract operation InnerModuleEvaluation takes arguments <var>module</var> (a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>), <var>stack</var>, and <var>index</var>. It is used by Evaluate to perform the actual evaluation process for <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as <var>module</var>'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>. It performs the following steps when called:</p>\n\n\n            <emu-alg><ol><li>If <var>module</var> is not a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li>Perform ? <var>module</var>.Evaluate().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li>If <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>, return <var>index</var>.</li><li>Otherwise, return <var>module</var>.[[EvaluationError]].</li></ol></li><li>If <var>module</var>.[[Status]] is <emu-const>evaluating</emu-const>, return <var>index</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>linked</emu-const>.</li><li>Set <var>module</var>.[[Status]] to <emu-const>evaluating</emu-const>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>NOTE: Link must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.</li><li>Set <var>index</var> to ?&#160;<emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>If <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is either <emu-const>evaluating</emu-const> or <emu-const>evaluated</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is <emu-const>evaluating</emu-const> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <emu-const>evaluating</emu-const>, then<ol><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li></ol></li><li>Perform ? <var>module</var>.<emu-xref aoid=\"ExecuteModule\"><a href=\"#sec-source-text-module-record-execute-module\">ExecuteModule</a></emu-xref>().</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var> occurs exactly once in <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li>Set <var>requiredModule</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <var>index</var>.</li></ol></emu-alg>\n          </emu-clause>\n        "}, "sec-hostensurecancompilestrings": {"num": "18.2.1.2", "title": "#sec-hostensurecancompilestrings HostEnsureCanCompileStrings ( callerRealm, calleeRealm )", "html": "<emu-clause id=\"sec-hostensurecancompilestrings\" aoid=\"HostEnsureCanCompileStrings\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-hostensurecancompilestrings\">#sec-hostensurecancompilestrings</span> HostEnsureCanCompileStrings ( <var>callerRealm</var>, <var>calleeRealm</var> )</h1>\n        <p>HostEnsureCanCompileStrings is an implementation-defined abstract operation that allows host environments to block certain ECMAScript functions which allow developers to compile strings into ECMAScript code.</p>\n\n\n        <p>An implementation of HostEnsureCanCompileStrings may complete normally or abruptly. Any abrupt completions will be propagated to its callers. The default implementation of HostEnsureCanCompileStrings is to unconditionally return an empty normal completion.</p>\n      </emu-clause>\n\n      "}, "sec-runtime-semantics-destructuringassignmentevaluation": {"num": "12.15.7.2", "title": "#sec-runtime-semantics-destructuringassignmentevaluation Runtime Semantics: DestructuringAssignmentEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-destructuringassignmentevaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-destructuringassignmentevaluation\">#sec-runtime-semantics-destructuringassignmentevaluation</span> Runtime Semantics: DestructuringAssignmentEvaluation</h1>\n        <p>With parameter <var>value</var>.</p>\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"81ba5a4a\"><emu-t>{</emu-t><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"02d75808\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n    <emu-rhs a=\"831120ec\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt><emu-t>,</emu-t><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Perform ? PropertyDestructuringAssignmentEvaluation for <emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt> using <var>value</var> as the argument.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"99d85234\"><emu-t>[</emu-t><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>)).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"31ffe6b2\"><emu-t>[</emu-t><emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Let <var>result</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"72641904\"><emu-t>[</emu-t><emu-nt optional=\"\"><a href=\"#prod-Elision\">Elision</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>If <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> is present, then<ol><li>Let <var>status</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iteratorRecord</var>.[[Done]] is <emu-val>true</emu-val>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li></ol></li><li>Let <var>result</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"815ecab3\"><emu-t>[</emu-t><emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Let <var>result</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"cd334403\"><emu-t>[</emu-t><emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt><emu-t>,</emu-t><emu-nt optional=\"\"><a href=\"#prod-Elision\">Elision</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-nt optional=\"\"><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Let <var>status</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>If <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> is present, then<ol><li>Set <var>status</var> to the result of performing IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> with <var>iteratorRecord</var> as the argument.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iteratorRecord</var>.[[Done]] is <emu-val>true</emu-val>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li></ol></li><li>If <emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt> is present, then<ol><li>Set <var>status</var> to the result of performing IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt> with <var>iteratorRecord</var> as the argument.</li></ol></li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d3f69c83\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Let <var>excludedNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Return the result of performing RestDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt> with <var>value</var> and <var>excludedNames</var> as the arguments.</li></ol></emu-alg>\n\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b3c2d7a5\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt><emu-t>,</emu-t><emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Let <var>excludedNames</var> be ? PropertyDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt> with argument <var>value</var>.</li><li>Return the result of performing RestDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt> with arguments <var>value</var> and <var>excludedNames</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n\n      "}, "sec-InnerModuleLinking": {"num": "15.2.1.16.1.1", "title": "#sec-InnerModuleLinking InnerModuleLinking ( module, stack, index )", "html": "<emu-clause id=\"sec-InnerModuleLinking\" oldids=\"sec-innermoduleinstantiation\" aoid=\"InnerModuleLinking\">\n            <span id=\"sec-innermoduleinstantiation\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-InnerModuleLinking\">#sec-InnerModuleLinking</span> InnerModuleLinking ( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>\n            <p>The abstract operation InnerModuleLinking takes arguments <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>), <var>stack</var>, and <var>index</var>. It is used by Link to perform the actual linking process for <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to <emu-const>linked</emu-const> together. It performs the following steps when called:</p>\n\n\n            <emu-alg><ol><li>If <var>module</var> is not a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li>Perform ? <var>module</var>.Link().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <emu-const>linking</emu-const>, <emu-const>linked</emu-const>, or <emu-const>evaluated</emu-const>, then<ol><li>Return <var>index</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>unlinked</emu-const>.</li><li>Set <var>module</var>.[[Status]] to <emu-const>linking</emu-const>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be ?&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>Set <var>index</var> to ?&#160;<emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>If <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is either <emu-const>linking</emu-const>, <emu-const>linked</emu-const>, or <emu-const>evaluated</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is <emu-const>linking</emu-const> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <emu-const>linking</emu-const>, then<ol><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li></ol></li><li>Perform ? <var>module</var>.<emu-xref aoid=\"InitializeEnvironment\"><a href=\"#sec-source-text-module-record-initialize-environment\">InitializeEnvironment</a></emu-xref>().</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var> occurs exactly once in <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li>Set <var>requiredModule</var>.[[Status]] to <emu-const>linked</emu-const>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <var>index</var>.</li></ol></emu-alg>\n          </emu-clause>\n        "}, "sec-moduleevaluation": {"num": "15.2.1.16.2", "title": "#sec-moduleevaluation Evaluate ( ) Concrete Method", "html": "<emu-clause id=\"sec-moduleevaluation\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-moduleevaluation\">#sec-moduleevaluation</span> Evaluate ( ) Concrete Method</h1>\n          <p>The Evaluate concrete method of a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> abstract method.</p>\n          <p>Evaluate transitions this module's [[Status]] from <emu-const>linked</emu-const> to <emu-const>evaluated</emu-const>.</p>\n          <p>If execution results in an exception, that exception is recorded in the [[EvaluationError]] field and rethrown by future invocations of Evaluate.</p>\n          <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>):</p>\n\n\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: This call to Evaluate is not happening at the same time as another call to Evaluate within the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>.</li><li>Let <var>module</var> be this <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>linked</emu-const> or <emu-const>evaluated</emu-const>.</li><li>Let <var>stack</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>(<var>module</var>, <var>stack</var>, 0).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> in <var>stack</var>, do<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[Status]] is <emu-const>evaluating</emu-const>.</li><li>Set <var>m</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>Set <var>m</var>.[[EvaluationError]] to <var>result</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const> and <var>module</var>.[[EvaluationError]] is <var>result</var>.</li><li>Return <var>result</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const> and <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>stack</var> is empty.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <div id=\"excluded-sec-innermoduleevaluation\"><h1><span class=\"secnum\">15.2.1.16.2.1</span>#sec-innermoduleevaluation InnerModuleEvaluation ( module, stack, index )</h1>...</div></emu-clause>\n\n        "}, "sec-host-promise-rejection-tracker": {"num": "25.6.1.9", "title": "#sec-host-promise-rejection-tracker HostPromiseRejectionTracker ( promise, operation )", "html": "<emu-clause id=\"sec-host-promise-rejection-tracker\" aoid=\"HostPromiseRejectionTracker\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-host-promise-rejection-tracker\">#sec-host-promise-rejection-tracker</span> HostPromiseRejectionTracker ( <var>promise</var>, <var>operation</var> )</h1>\n        <p>HostPromiseRejectionTracker is an implementation-defined abstract operation that allows host environments to track promise rejections.</p>\n\n\n        <p>An implementation of HostPromiseRejectionTracker must complete normally in all cases. The default implementation of HostPromiseRejectionTracker is to unconditionally return an empty normal completion.</p>\n\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>HostPromiseRejectionTracker is called in two scenarios:</p>\n\n          <ul>\n            <li>When a promise is rejected without any handlers, it is called with its <var>operation</var> argument set to <emu-val>\"reject\"</emu-val>.</li>\n            <li>When a handler is added to a rejected promise for the first time, it is called with its <var>operation</var> argument set to <emu-val>\"handle\"</emu-val>.</li>\n          </ul>\n\n          <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>\n        </div></emu-note>\n\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>If <var>operation</var> is <emu-val>\"handle\"</emu-val>, an implementation should not hold a reference to <var>promise</var> in a way that would interfere with garbage collection. An implementation may hold a reference to <var>promise</var> if <var>operation</var> is <emu-val>\"reject\"</emu-val>, since it is expected that rejections will be rare and not on hot code paths.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-asyncgenerator-prototype-tostringtag": {"num": "25.5.1.5", "title": "#sec-asyncgenerator-prototype-tostringtag AsyncGenerator.prototype [ @@toStringTag ]", "html": "<emu-clause id=\"sec-asyncgenerator-prototype-tostringtag\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgenerator-prototype-tostringtag\">#sec-asyncgenerator-prototype-tostringtag</span> AsyncGenerator.prototype [ @@toStringTag ]</h1>\n        <p>The initial value of the @@toStringTag property is the String value <emu-val>\"AsyncGenerator\"</emu-val>.</p>\n        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>\n      </emu-clause>\n\n    "}, "sec-copydataproperties": {"num": "7.3.25", "title": "#sec-copydataproperties CopyDataProperties ( target, source, excludedItems )", "html": "<emu-clause id=\"sec-copydataproperties\" aoid=\"CopyDataProperties\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-copydataproperties\">#sec-copydataproperties</span> CopyDataProperties ( <var>target</var>, <var>source</var>, <var>excludedItems</var> )</h1>\n      <p>The abstract operation CopyDataProperties takes arguments <var>target</var>, <var>source</var>, and <var>excludedItems</var>. It performs the following steps when called:</p>\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>target</var>) is Object.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>excludedItems</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of property keys.</li><li>If <var>source</var> is <emu-val>undefined</emu-val> or <emu-val>null</emu-val>, return <var>target</var>.</li><li>Let <var>from</var> be !&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>source</var>).</li><li>Let <var>keys</var> be ? <var>from</var>.[[OwnPropertyKeys]]().</li><li>For each element <var>nextKey</var> of <var>keys</var> in <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> order, do<ol><li>Let <var>excluded</var> be <emu-val>false</emu-val>.</li><li>For each element <var>e</var> of <var>excludedItems</var> in <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> order, do<ol><li>If <emu-xref aoid=\"SameValue\"><a href=\"#sec-samevalue\">SameValue</a></emu-xref>(<var>e</var>, <var>nextKey</var>) is <emu-val>true</emu-val>, then<ol><li>Set <var>excluded</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>If <var>excluded</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>desc</var> be ? <var>from</var>.[[GetOwnProperty]](<var>nextKey</var>).</li><li>If <var>desc</var> is not <emu-val>undefined</emu-val> and <var>desc</var>.[[Enumerable]] is <emu-val>true</emu-val>, then<ol><li>Let <var>propValue</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>from</var>, <var>nextKey</var>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>target</var>, <var>nextKey</var>, <var>propValue</var>).</li></ol></li></ol></li></ol></li><li>Return <var>target</var>.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The target passed in here is always a newly created object which is not directly accessible in case of an error being thrown.</p>\n      </div></emu-note>\n    </emu-clause>\n\n  "}, "sec-forward-progress": {"num": "8.8", "title": "#sec-forward-progress Forward Progress", "html": "<emu-clause id=\"sec-forward-progress\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-forward-progress\">#sec-forward-progress</span> Forward Progress</h1>\n    <p>For an <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> to <em>make forward progress</em> is for it to perform an evaluation step according to this specification.</p>\n    <p>An <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> becomes <em>blocked</em> when its <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref> waits synchronously and indefinitely for an external event. Only agents whose <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>'s [[CanBlock]] property is <emu-val>true</emu-val> can become blocked in this sense.  An <em>unblocked</em> <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> is one that is not blocked.</p>\n\n    <p>Implementations must ensure that:</p>\n    <ul>\n      <li>every unblocked <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> with a dedicated <emu-xref href=\"#executing-thread\"><a href=\"#executing-thread\">executing thread</a></emu-xref> eventually makes forward progress</li>\n      <li>in a set of agents that share an <emu-xref href=\"#executing-thread\"><a href=\"#executing-thread\">executing thread</a></emu-xref>, one <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> eventually makes forward progress</li>\n      <li>an <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> does not cause another <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> to become blocked except via explicit APIs that provide blocking.</li>\n    </ul>\n\n    <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n      <p>This, along with the liveness guarantee in the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>, ensures that all <emu-const>SeqCst</emu-const> writes eventually become observable to all agents.</p>\n    </div></emu-note>\n  </emu-clause>\n\n"}, "sec-array.prototype.includes": {"num": "22.1.3.13", "title": "#sec-array.prototype.includes Array.prototype.includes ( searchElement [ , fromIndex ] )", "html": "<emu-clause id=\"sec-array.prototype.includes\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.includes\">#sec-array.prototype.includes</span> Array.prototype.includes ( <var>searchElement</var> [ , <var>fromIndex</var> ] )</h1>\n\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p><code>includes</code> compares <var>searchElement</var> to the elements of the array, in ascending order, using the <emu-xref aoid=\"SameValueZero\"><a href=\"#sec-samevaluezero\">SameValueZero</a></emu-xref> algorithm, and if found at any position, returns <emu-val>true</emu-val>; otherwise, <emu-val>false</emu-val> is returned.</p>\n\n          <p>The optional second argument <var>fromIndex</var> defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array, <emu-val>false</emu-val> is returned, i.e. the array will not be searched. If it is negative, it is used as the offset from the end of the array to compute <var>fromIndex</var>. If the computed index is less than 0, the whole array will be searched.</p>\n        </div></emu-note>\n        <p>When the <code>includes</code> method is called, the following steps are taken:</p>\n\n\n        <emu-alg><ol><li>Let <var>O</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>O</var>).</li><li>If <var>len</var> is 0, return <emu-val>false</emu-val>.</li><li>Let <var>n</var> be ?&#160;<emu-xref aoid=\"ToInteger\"><a href=\"#sec-tointeger\">ToInteger</a></emu-xref>(<var>fromIndex</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>fromIndex</var> is <emu-val>undefined</emu-val>, then <var>n</var> is 0.</li><li>If <var>n</var> &#8805; 0, then<ol><li>Let <var>k</var> be <var>n</var>.</li></ol></li><li>Else,<ol><li>Let <var>k</var> be <var>len</var> + <var>n</var>.</li><li>If <var>k</var> &lt; 0, set <var>k</var> to 0.</li></ol></li><li>Repeat, while <var>k</var> &lt; <var>len</var>,<ol><li>Let <var>elementK</var> be the result of ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>O</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>k</var>)).</li><li>If <emu-xref aoid=\"SameValueZero\"><a href=\"#sec-samevaluezero\">SameValueZero</a></emu-xref>(<var>searchElement</var>, <var>elementK</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>includes</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>The <code>includes</code> method intentionally differs from the similar <code>indexOf</code> method in two ways. First, it uses the <emu-xref aoid=\"SameValueZero\"><a href=\"#sec-samevaluezero\">SameValueZero</a></emu-xref> algorithm, instead of <emu-xref aoid=\"Strict Equality Comparison\"><a href=\"#sec-strict-equality-comparison\">Strict Equality Comparison</a></emu-xref>, allowing it to detect <emu-val>NaN</emu-val> array elements. Second, it does not skip missing array elements, instead treating them as <emu-val>undefined</emu-val>.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-parse-script": {"num": "15.1.9", "title": "#sec-parse-script ParseScript ( sourceText, realm, hostDefined )", "html": "<emu-clause id=\"sec-parse-script\" aoid=\"ParseScript\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-parse-script\">#sec-parse-script</span> ParseScript ( <var>sourceText</var>, <var>realm</var>, <var>hostDefined</var> )</h1>\n      <p>The abstract operation ParseScript takes arguments <var>sourceText</var>, <var>realm</var>, and <var>hostDefined</var>. It creates a <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> based upon the result of parsing <var>sourceText</var> as a <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt>. It performs the following steps when called:</p>\n\n\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>sourceText</var> is an ECMAScript source text (see clause <emu-xref href=\"#sec-ecmascript-language-source-code\"><a href=\"#sec-ecmascript-language-source-code\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-source-code\">#sec-ecmascript-language-source-code</a></emu-xref>).</li><li>Parse <var>sourceText</var> using <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt> as the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let <var>body</var> be the resulting parse tree. Otherwise, let <var>body</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of one or more <emu-val>SyntaxError</emu-val> objects representing the parsing errors and/or early errors. Parsing and <emu-xref href=\"#early-error\"><a href=\"#early-error\">early error</a></emu-xref> detection may be interweaved in an implementation-dependent manner. If more than one parsing error or <emu-xref href=\"#early-error\"><a href=\"#early-error\">early error</a></emu-xref> is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.</li><li>If <var>body</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of errors, return <var>body</var>.</li><li>Return <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> { [[Realm]]: <var>realm</var>, [[Environment]]: <emu-val>undefined</emu-val>, [[ECMAScriptCode]]: <var>body</var>, [[HostDefined]]: <var>hostDefined</var> }.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>An implementation may parse script source text and analyse it for Early Error conditions prior to evaluation of ParseScript for that script source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseScript upon that source text.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-numericvalue": {"num": "11.8.3.2", "title": "#sec-numericvalue Static Semantics: NumericValue", "html": "<emu-clause id=\"sec-numericvalue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numericvalue\">#sec-numericvalue</span> Static Semantics: NumericValue</h1>\n        <emu-grammar><emu-production name=\"NumericLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-NumericLiteral\">NumericLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"18c0356f\"><emu-nt><a href=\"#prod-DecimalLiteral\">DecimalLiteral</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that results from rounding the MV of <emu-nt><a href=\"#prod-DecimalLiteral\">DecimalLiteral</a></emu-nt> as described below.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"NumericLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-NumericLiteral\">NumericLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e867b70b\"><emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that results from rounding the MV of <emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt> as described below.</li></ol></emu-alg>\n        <p>Once the exact MV for a numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0<sub>&#8477;</sub>, then the rounded value is <emu-val>+0</emu-val>; otherwise, the rounded value must be the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the MV (as specified in <emu-xref href=\"#sec-ecmascript-language-types-number-type\"><a href=\"#sec-ecmascript-language-types-number-type\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-types-number-type\">#sec-ecmascript-language-types-number-type</a></emu-xref>), unless the literal is a <emu-nt><a href=\"#prod-DecimalLiteral\">DecimalLiteral</a></emu-nt> and the literal has more than 20 significant digits, in which case the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> may be either the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the MV of a literal produced by replacing each significant digit after the 20th with a <code>0</code> digit or the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the MV of a literal produced by replacing each significant digit after the 20th with a <code>0</code> digit and then incrementing the literal at the 20th significant digit position. A digit is <em>significant</em> if it is not part of an <emu-nt><a href=\"#prod-ExponentPart\">ExponentPart</a></emu-nt> and</p>\n        <ul>\n          <li>\n            it is not <code>0</code>; or\n          </li>\n          <li>\n            there is a nonzero digit to its left and there is a nonzero digit, not in the <emu-nt><a href=\"#prod-ExponentPart\">ExponentPart</a></emu-nt>, to its right.\n          </li>\n        </ul>\n\n        <emu-grammar><emu-production name=\"NumericLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-NumericLiteral\">NumericLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"68def506\"><emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the BigInt value that represents the MV of <emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"DecimalBigIntegerLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-DecimalBigIntegerLiteral\">DecimalBigIntegerLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"ddee4872\"><emu-t>0</emu-t><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the BigInt value that represents 0<sub>&#8477;</sub>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"DecimalBigIntegerLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-DecimalBigIntegerLiteral\">DecimalBigIntegerLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"7641418e\"><emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the BigInt value that represents the MV of <emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"DecimalBigIntegerLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-DecimalBigIntegerLiteral\">DecimalBigIntegerLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"93069ccc\"><emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt><emu-nt><a href=\"#prod-DecimalDigits\">DecimalDigits</a></emu-nt><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>n</var> be the <emu-xref href=\"#mathematical%20integer\"><a href=\"#mathematical%20integer\">mathematical integer</a></emu-xref> number of code points in <emu-nt><a href=\"#prod-DecimalDigits\">DecimalDigits</a></emu-nt>.</li><li>Let <var>mv</var> be (the MV of <emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt> &#215; 10<sub>&#8477;</sub><sup><var>n</var></sup>) plus the MV of <emu-nt><a href=\"#prod-DecimalDigits\">DecimalDigits</a></emu-nt>.</li><li>Return the BigInt value that represents <var>mv</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n    "}, "sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport Runtime Semantics: FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> Runtime Semantics: FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by host environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n\n\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-source-text-module-record-initialize-environment": {"num": "15.2.1.17.4", "title": "#sec-source-text-module-record-initialize-environment InitializeEnvironment ( ) Concrete Method", "html": "<emu-clause id=\"sec-source-text-module-record-initialize-environment\" aoid=\"InitializeEnvironment\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-source-text-module-record-initialize-environment\">#sec-source-text-module-record-initialize-environment</span> InitializeEnvironment ( ) Concrete Method</h1>\n          <p>The InitializeEnvironment concrete method of a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> abstract method.</p>\n          <p>This abstract method performs the following steps:</p>\n\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>.</li><li>For each <emu-xref href=\"#exportentry-record\"><a href=\"#exportentry-record\">ExportEntry Record</a></emu-xref> <var>e</var> in <var>module</var>.[[IndirectExportEntries]], do<ol><li>Let <var>resolution</var> be ? <var>module</var>.ResolveExport(<var>e</var>.[[ExportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resolution</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: All named exports from <var>module</var> are resolvable.</li><li>Let <var>realm</var> be <var>module</var>.[[Realm]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>realm</var> is not <emu-val>undefined</emu-val>.</li><li>Let <var>env</var> be <emu-xref aoid=\"NewModuleEnvironment\"><a href=\"#sec-newmoduleenvironment\">NewModuleEnvironment</a></emu-xref>(<var>realm</var>.[[GlobalEnv]]).</li><li>Set <var>module</var>.[[Environment]] to <var>env</var>.</li><li>For each <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Record</a></emu-xref> <var>in</var> in <var>module</var>.[[ImportEntries]], do<ol><li>Let <var>importedModule</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>in</var>.[[ModuleRequest]]).</li><li>NOTE: The above call cannot fail because imported module requests are a subset of <var>module</var>.[[RequestedModules]], and these have been resolved earlier in this algorithm.</li><li>If <var>in</var>.[[ImportName]] is <emu-val>\"*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>importedModule</var>).</li><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Let <var>resolution</var> be ? <var>importedModule</var>.ResolveExport(<var>in</var>.[[ImportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>resolution</var>.[[BindingName]] is <emu-val>\"*namespace*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>resolution</var>.[[Module]]).</li><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Call <var>env</var>.CreateImportBinding(<var>in</var>.[[LocalName]], <var>resolution</var>.[[Module]], <var>resolution</var>.[[BindingName]]).</li></ol></li></ol></li></ol></li><li>Let <var>moduleContext</var> be a new ECMAScript code <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleContext</var> to <emu-val>null</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> of <var>moduleContext</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleContext</var> to <var>module</var>.</li><li>Set the VariableEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set <var>module</var>.[[Context]] to <var>moduleContext</var>.</li><li>Push <var>moduleContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>moduleContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>code</var> be <var>module</var>.[[ECMAScriptCode]].</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>code</var>.</li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each element <var>d</var> in <var>varDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If <var>dn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>dn</var>, <emu-val>undefined</emu-val>).</li><li>Append <var>dn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li><li>If <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, then<ol><li>Let <var>fo</var> be InstantiateFunctionObject of <var>d</var> with argument <var>env</var>.</li><li>Call <var>env</var>.InitializeBinding(<var>dn</var>, <var>fo</var>).</li></ol></li></ol></li></ol></li><li>Remove <var>moduleContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-reflection": {"num": "26", "title": "#sec-reflection Reflection", "html": "<emu-clause id=\"sec-reflection\">\n  <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-reflection\">#sec-reflection</span> Reflection</h1>\n\n  <div id=\"excluded-sec-reflect-object\"><h1><span class=\"secnum\">26.1</span>#sec-reflect-object The Reflect Object</h1>...</div><div id=\"excluded-sec-proxy-objects\"><h1><span class=\"secnum\">26.2</span>#sec-proxy-objects Proxy Objects</h1>...</div><div id=\"excluded-sec-module-namespace-objects\"><h1><span class=\"secnum\">26.3</span>#sec-module-namespace-objects Module Namespace Objects</h1>...</div></emu-clause>\n\n\n"}, "sec-source-text-module-record-execute-module": {"num": "15.2.1.17.5", "title": "#sec-source-text-module-record-execute-module ExecuteModule ( ) Concrete Method", "html": "<emu-clause id=\"sec-source-text-module-record-execute-module\" aoid=\"ExecuteModule\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-source-text-module-record-execute-module\">#sec-source-text-module-record-execute-module</span> ExecuteModule ( ) Concrete Method</h1>\n          <p>The ExecuteModule concrete method of a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> abstract method.</p>\n          <p>This abstract method performs the following steps:</p>\n\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>moduleContext</var> be <var>module</var>.[[Context]].</li><li>Push <var>moduleContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>moduleContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>result</var> be the result of evaluating <var>module</var>.[[ECMAScriptCode]].</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>moduleContext</var> and remove it from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li><li>Resume the context that is now on the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-%typedarray%-intrinsic-object": {"num": "22.2.1", "title": "#sec-%typedarray%-intrinsic-object The %TypedArray% Intrinsic Object", "html": "<emu-clause id=\"sec-%typedarray%-intrinsic-object\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-%typedarray%-intrinsic-object\">#sec-%typedarray%-intrinsic-object</span> The %TypedArray% Intrinsic Object</h1>\n      <p>The <dfn>%TypedArray%</dfn> intrinsic object:</p>\n      <ul>\n        <li>is a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> that all of the <var>TypedArray</var> <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> objects inherit from.</li>\n        <li>along with its corresponding prototype object, provides common properties that are inherited by all <var>TypedArray</var> constructors and their instances.</li>\n        <li>does not have a global name or appear as a property of the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref>.</li>\n        <li>acts as the abstract superclass of the various <var>TypedArray</var> constructors.</li>\n        <li>will throw an error when invoked, because it is an abstract class <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>. The <var>TypedArray</var> constructors do not perform a <code>super</code> call to it.</li>\n      </ul>\n\n      <div id=\"excluded-sec-%typedarray%\"><h1><span class=\"secnum\">22.2.1.1</span>#sec-%typedarray% %TypedArray% ( )</h1>...</div></emu-clause>\n\n\n    "}, "sec-async-from-sync-iterator-value-unwrap-functions": {"num": "25.1.4.2.4", "title": "#sec-async-from-sync-iterator-value-unwrap-functions Async-from-Sync Iterator Value Unwrap Functions", "html": "<emu-clause id=\"sec-async-from-sync-iterator-value-unwrap-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-from-sync-iterator-value-unwrap-functions\">#sec-async-from-sync-iterator-value-unwrap-functions</span> Async-from-Sync Iterator Value Unwrap Functions</h1>\n          <p>An async-from-sync iterator value unwrap function is an anonymous built-in function that is used by <emu-xref aoid=\"AsyncFromSyncIteratorContinuation\"><a href=\"#sec-asyncfromsynciteratorcontinuation\">AsyncFromSyncIteratorContinuation</a></emu-xref> when processing the <emu-val>\"value\"</emu-val> property of an <i>IteratorResult</i> object, in order to wait for its value if it is a promise and re-package the result in a new \"unwrapped\" <i>IteratorResult</i> object. Each async-from-sync iterator value unwrap function has a [[Done]] internal slot.</p>\n          <p>When an async-from-sync iterator value unwrap function is called with argument <var>value</var>, the following steps are taken:</p>\n\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Return !&#160;<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <var>F</var>.[[Done]]).</li></ol></emu-alg>\n        </emu-clause>\n      "}}, "figData": {"table-8": "Table 9"}}, "to": {"secList": ["sec-async-function-constructor-arguments", "sec-asyncgeneratorresumenext", "sec-completion-record-specification-type", "sec-moduledeclarationlinking", "sec-getmodulenamespace", "sec-typeof-operator", "sec-hostimportmoduledynamically", "sec-innermoduleevaluation", "sec-hostensurecancompilestrings", "sec-runtime-semantics-destructuringassignmentevaluation", "sec-InnerModuleLinking", "sec-moduleevaluation", "sec-host-promise-rejection-tracker", "sec-asyncgenerator-prototype-tostringtag", "sec-copydataproperties", "sec-forward-progress", "sec-array.prototype.includes", "sec-parse-script", "sec-numericvalue", "sec-finishdynamicimport", "sec-source-text-module-record-initialize-environment", "sec-reflection", "sec-source-text-module-record-execute-module", "sec-%typedarray%-intrinsic-object", "sec-async-from-sync-iterator-value-unwrap-functions"], "secData": {"sec-async-function-constructor-arguments": {"num": "25.7.1.1", "title": "#sec-async-function-constructor-arguments AsyncFunction ( p1, p2, \u2026 , pn, body )", "html": "<emu-clause id=\"sec-async-function-constructor-arguments\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-function-constructor-arguments\">#sec-async-function-constructor-arguments</span> AsyncFunction ( <var>p1</var>, <var>p2</var>, &#8230; , <var>pn</var>, <var>body</var> )</h1>\n        <p>The last argument specifies the body (executable code) of an async function. Any preceding arguments specify formal parameters.</p>\n        <p>When the <code>AsyncFunction</code> function is called with some arguments <var>p1</var>, <var>p2</var>, &#8230; , <var>pn</var>, <var>body</var> (where <var>n</var> might be 0, that is, there are no <var>p</var> arguments, and where <var>body</var> might also not be provided), the following steps are taken:</p>\n\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>args</var> be the <var>argumentsList</var> that was passed to this function by [[Call]] or [[Construct]].</li><li>Return <emu-xref aoid=\"CreateDynamicFunction\"><a href=\"#sec-createdynamicfunction\">CreateDynamicFunction</a></emu-xref>(<var>C</var>, NewTarget, <emu-const>async</emu-const>, <var>args</var>).</li></ol></emu-alg>\n\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">See NOTE for <emu-xref href=\"#sec-function-p1-p2-pn-body\"><a href=\"#sec-function-p1-p2-pn-body\" class=\"excluded-xref\" excluded-id=\"sec-function-p1-p2-pn-body\">#sec-function-p1-p2-pn-body</a></emu-xref>.</div></emu-note>\n      </emu-clause>\n    "}, "sec-asyncgeneratorresumenext": {"num": "25.5.3.5", "title": "#sec-asyncgeneratorresumenext AsyncGeneratorResumeNext ( generator )", "html": "<emu-clause id=\"sec-asyncgeneratorresumenext\" aoid=\"AsyncGeneratorResumeNext\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgeneratorresumenext\">#sec-asyncgeneratorresumenext</span> AsyncGeneratorResumeNext ( <var>generator</var> )</h1>\n        <p>The abstract operation AsyncGeneratorResumeNext takes argument <var>generator</var>. It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>generator</var> is an AsyncGenerator instance.</li><li>Let <var>state</var> be <var>generator</var>.[[AsyncGeneratorState]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>state</var> is not <emu-const>executing</emu-const>.</li><li>If <var>state</var> is <emu-const>awaiting-return</emu-const>, return <emu-val>undefined</emu-val>.</li><li>Let <var>queue</var> be <var>generator</var>.[[AsyncGeneratorQueue]].</li><li>If <var>queue</var> is an empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>, return <emu-val>undefined</emu-val>.</li><li>Let <var>next</var> be the value of the first element of <var>queue</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>next</var> is an AsyncGeneratorRequest record.</li><li>Let <var>completion</var> be <var>next</var>.[[Completion]].</li><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>state</var> is <emu-const>suspendedStart</emu-const>, then<ol><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>completed</emu-const>.</li><li>Set <var>state</var> to <emu-const>completed</emu-const>.</li></ol></li><li>If <var>state</var> is <emu-const>completed</emu-const>, then<ol><li>If <var>completion</var>.[[Type]] is <emu-const>return</emu-const>, then<ol><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>awaiting-return</emu-const>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>completion</var>.[[Value]]).</li><li>Let <var>stepsFulfilled</var> be the algorithm steps defined in <emu-xref href=\"#async-generator-resume-next-return-processor-fulfilled\" title=\"\"><a href=\"#async-generator-resume-next-return-processor-fulfilled\">AsyncGeneratorResumeNext Return Processor Fulfilled Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsFulfilled</var>, &#171; [[Generator]] &#187;).</li><li>Set <var>onFulfilled</var>.[[Generator]] to <var>generator</var>.</li><li>Let <var>stepsRejected</var> be the algorithm steps defined in <emu-xref href=\"#async-generator-resume-next-return-processor-rejected\" title=\"\"><a href=\"#async-generator-resume-next-return-processor-rejected\">AsyncGeneratorResumeNext Return Processor Rejected Functions</a></emu-xref>.</li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsRejected</var>, &#171; [[Generator]] &#187;).</li><li>Set <var>onRejected</var>.[[Generator]] to <var>generator</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var>.[[Type]] is <emu-const>throw</emu-const>.</li><li>Perform !&#160;<emu-xref aoid=\"AsyncGeneratorReject\"><a href=\"#sec-asyncgeneratorreject\">AsyncGeneratorReject</a></emu-xref>(<var>generator</var>, <var>completion</var>.[[Value]]).</li><li>Return <emu-val>undefined</emu-val>.</li></ol></li></ol></li></ol></li><li>Else if <var>state</var> is <emu-const>completed</emu-const>, return !&#160;<emu-xref aoid=\"AsyncGeneratorResolve\"><a href=\"#sec-asyncgeneratorresolve\">AsyncGeneratorResolve</a></emu-xref>(<var>generator</var>, <emu-val>undefined</emu-val>, <emu-val>true</emu-val>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>state</var> is either <emu-const>suspendedStart</emu-const> or <emu-const>suspendedYield</emu-const>.</li><li>Let <var>genContext</var> be <var>generator</var>.[[AsyncGeneratorContext]].</li><li>Let <var>callerContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>callerContext</var>.</li><li>Set <var>generator</var>.[[AsyncGeneratorState]] to <emu-const>executing</emu-const>.</li><li>Push <var>genContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>genContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>genContext</var> using <var>completion</var> as the result of the operation that suspended it. Let <var>result</var> be the completion record returned by the resumed computation.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>result</var> is never an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we return here, <var>genContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>callerContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n        <emu-clause id=\"async-generator-resume-next-return-processor-fulfilled\">\n          <h1><span class=\"secnum\">25.5.3.5.1</span> AsyncGeneratorResumeNext Return Processor Fulfilled Functions</h1>\n          <p>An <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> specification device to unwrap promises passed in to the <emu-xref href=\"#sec-asyncgenerator-prototype-return\" title=\"\"><a href=\"#sec-asyncgenerator-prototype-return\">AsyncGenerator.prototype.return ( <var>value</var> )</a></emu-xref> method. Each <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function has a [[Generator]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function is called with argument <var>value</var>, the following steps are taken:</p>\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Set <var>F</var>.[[Generator]].[[AsyncGeneratorState]] to <emu-const>completed</emu-const>.</li><li>Return !&#160;<emu-xref aoid=\"AsyncGeneratorResolve\"><a href=\"#sec-asyncgeneratorresolve\">AsyncGeneratorResolve</a></emu-xref>(<var>F</var>.[[Generator]], <var>value</var>, <emu-val>true</emu-val>).</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor fulfilled function is 1.</p>\n        </emu-clause>\n\n        <emu-clause id=\"async-generator-resume-next-return-processor-rejected\">\n          <h1><span class=\"secnum\">25.5.3.5.2</span> AsyncGeneratorResumeNext Return Processor Rejected Functions</h1>\n          <p>An <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> specification device to unwrap promises passed in to the <emu-xref href=\"#sec-asyncgenerator-prototype-return\" title=\"\"><a href=\"#sec-asyncgenerator-prototype-return\">AsyncGenerator.prototype.return ( <var>value</var> )</a></emu-xref> method. Each <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function has a [[Generator]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function is called with argument <var>reason</var>, the following steps are taken:</p>\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Set <var>F</var>.[[Generator]].[[AsyncGeneratorState]] to <emu-const>completed</emu-const>.</li><li>Return !&#160;<emu-xref aoid=\"AsyncGeneratorReject\"><a href=\"#sec-asyncgeneratorreject\">AsyncGeneratorReject</a></emu-xref>(<var>F</var>.[[Generator]], <var>reason</var>).</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"AsyncGeneratorResumeNext\"><a href=\"#sec-asyncgeneratorresumenext\">AsyncGeneratorResumeNext</a></emu-xref> return processor rejected function is 1.</p>\n        </emu-clause>\n      </emu-clause>\n\n      "}, "sec-completion-record-specification-type": {"num": "6.2.3", "title": "#sec-completion-record-specification-type The Completion Record Specification Type", "html": "<emu-clause id=\"sec-completion-record-specification-type\" aoid=\"Completion\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-completion-record-specification-type\">#sec-completion-record-specification-type</span> The Completion Record Specification Type</h1>\n      <p>The Completion type is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> used to explain the runtime propagation of values and control flow such as the behaviour of statements (<code>break</code>, <code>continue</code>, <code>return</code> and <code>throw</code>) that perform nonlocal transfers of control.</p>\n      <p>Values of the Completion type are <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> values whose fields are defined as by <emu-xref href=\"#table-8\"><a href=\"#table-8\" class=\"excluded-xref\" excluded-id=\"table-8\">#table-8</a></emu-xref>. Such values are referred to as <dfn>Completion Record</dfn>s.</p>\n      <emu-table id=\"table-8\" caption=\"Completion Record Fields\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-8\">#table-8</span>: <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">Completion Record</a></emu-xref> Fields</figcaption>\n        <table>\n          <tbody>\n          <tr>\n            <th>\n              Field Name\n            </th>\n            <th>\n              Value\n            </th>\n            <th>\n              Meaning\n            </th>\n          </tr>\n          <tr>\n            <td>\n              [[Type]]\n            </td>\n            <td>\n              One of <emu-const>normal</emu-const>, <emu-const>break</emu-const>, <emu-const>continue</emu-const>, <emu-const>return</emu-const>, or <emu-const>throw</emu-const>\n            </td>\n            <td>\n              The type of completion that occurred.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Value]]\n            </td>\n            <td>\n              any <emu-xref href=\"#sec-ecmascript-language-types\"><a href=\"#sec-ecmascript-language-types\">ECMAScript language value</a></emu-xref> or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The value that was produced.\n            </td>\n          </tr>\n          <tr>\n            <td>\n              [[Target]]\n            </td>\n            <td>\n              any ECMAScript string or <emu-const>empty</emu-const>\n            </td>\n            <td>\n              The target label for directed control transfers.\n            </td>\n          </tr>\n          </tbody>\n        </table>\n      </figure></emu-table>\n      <p>The term &#8220;<dfn>abrupt completion</dfn>&#8221; refers to any completion with a [[Type]] value other than <emu-const>normal</emu-const>.</p>\n\n      <emu-clause id=\"await\" aoid=\"Await\">\n        <h1><span class=\"secnum\">6.2.3.1</span> Await</h1>\n\n        <p>Algorithm steps that say</p>\n\n        <emu-alg><ol><li>Let <var>completion</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n        <p>mean the same thing as:</p>\n\n        <emu-alg><ol><li>Let <var>asyncContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>promise</var> be ?&#160;<emu-xref aoid=\"PromiseResolve\"><a href=\"#sec-promise-resolve\">PromiseResolve</a></emu-xref>(<emu-xref href=\"#sec-promise-constructor\"><a href=\"#sec-promise-constructor\">%Promise%</a></emu-xref>, <var>value</var>).</li><li>Let <var>stepsFulfilled</var> be the algorithm steps defined in <emu-xref href=\"#await-fulfilled\" title=\"\"><a href=\"#await-fulfilled\">Await Fulfilled Functions</a></emu-xref>.</li><li>Let <var>onFulfilled</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsFulfilled</var>, &#171; [[AsyncContext]] &#187;).</li><li>Set <var>onFulfilled</var>.[[AsyncContext]] to <var>asyncContext</var>.</li><li>Let <var>stepsRejected</var> be the algorithm steps defined in <emu-xref href=\"#await-rejected\" title=\"\"><a href=\"#await-rejected\">Await Rejected Functions</a></emu-xref>.</li><li>Let <var>onRejected</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>stepsRejected</var>, &#171; [[AsyncContext]] &#187;).</li><li>Set <var>onRejected</var>.[[AsyncContext]] to <var>asyncContext</var>.</li><li>Perform !&#160;<emu-xref aoid=\"PerformPromiseThen\"><a href=\"#sec-performpromisethen\">PerformPromiseThen</a></emu-xref>(<var>promise</var>, <var>onFulfilled</var>, <var>onRejected</var>).</li><li>Remove <var>asyncContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and restore the <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref> that is at the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Set the code evaluation state of <var>asyncContext</var> such that when evaluation is resumed with a <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref> <var>completion</var>, the following steps of the algorithm that invoked <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> will be performed, with <var>completion</var> available.</li><li>Return.</li><li>NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of <var>asyncContext</var>.</li></ol></emu-alg>\n\n        <p>where all aliases in the above steps, with the exception of <var>completion</var>, are ephemeral and visible only in the steps pertaining to Await.</p>\n\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Await can be combined with the <code>?</code> and <code>!</code> prefixes, so that for example</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be ?&#160;<emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li></ol></emu-alg>\n\n          <p>means the same thing as:</p>\n\n          <emu-alg><ol><li>Let <var>result</var> be <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref>(<var>value</var>).</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </div></emu-note>\n\n        <emu-clause id=\"await-fulfilled\">\n          <h1><span class=\"secnum\">6.2.3.1.1</span> Await Fulfilled Functions</h1>\n          <p>An <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> specification device to deliver the promise fulfillment value to the caller as a normal completion. Each <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function has an [[AsyncContext]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function is called with argument <var>value</var>, the following steps are taken:</p>\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>asyncContext</var> be <var>F</var>.[[AsyncContext]].</li><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<var>value</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> fulfilled function is 1.</p>\n        </emu-clause>\n\n        <emu-clause id=\"await-rejected\">\n          <h1><span class=\"secnum\">6.2.3.1.2</span> Await Rejected Functions</h1>\n          <p>An <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function is an anonymous built-in function that is used as part of the <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> specification device to deliver the promise rejection reason to the caller as an abrupt throw completion. Each <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function has an [[AsyncContext]] internal slot.</p>\n          <p>When an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function is called with argument <var>reason</var>, the following steps are taken:</p>\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Let <var>asyncContext</var> be <var>F</var>.[[AsyncContext]].</li><li>Let <var>prevContext</var> be the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>prevContext</var>.</li><li>Push <var>asyncContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>asyncContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Resume the suspended evaluation of <var>asyncContext</var> using <emu-xref aoid=\"ThrowCompletion\"><a href=\"#sec-throwcompletion\">ThrowCompletion</a></emu-xref>(<var>reason</var>) as the result of the operation that suspended it.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: When we reach this step, <var>asyncContext</var> has already been removed from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> and <var>prevContext</var> is the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <p>The <emu-val>\"length\"</emu-val> property of an <emu-xref aoid=\"Await\"><a href=\"#await\">Await</a></emu-xref> rejected function is 1.</p>\n        </emu-clause>\n      </emu-clause>\n\n      <div id=\"excluded-sec-normalcompletion\"><h1><span class=\"secnum\">6.2.3.2</span>#sec-normalcompletion NormalCompletion</h1>...</div><div id=\"excluded-sec-throwcompletion\"><h1><span class=\"secnum\">6.2.3.3</span>#sec-throwcompletion ThrowCompletion</h1>...</div><div id=\"excluded-sec-updateempty\"><h1><span class=\"secnum\">6.2.3.4</span>#sec-updateempty UpdateEmpty ( completionRecord, value )</h1>...</div></emu-clause>\n\n    "}, "sec-moduledeclarationlinking": {"num": "15.2.1.16.1", "title": "#sec-moduledeclarationlinking Link ( ) Concrete Method", "html": "<emu-clause id=\"sec-moduledeclarationlinking\" oldids=\"sec-moduledeclarationinstantiation\">\n          <span id=\"sec-moduledeclarationinstantiation\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-moduledeclarationlinking\">#sec-moduledeclarationlinking</span> Link ( ) Concrete Method</h1>\n          <p>The Link concrete method of a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> abstract method.</p>\n          <p>On success, Link transitions this module's [[Status]] from <emu-const>unlinked</emu-const> to <emu-const>linked</emu-const>. On failure, an exception is thrown and this module's [[Status]] remains <emu-const>unlinked</emu-const>.</p>\n          <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>):</p>\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is not <emu-const>linking</emu-const> or <emu-const>evaluating</emu-const>.</li><li>Let <var>stack</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>(<var>module</var>, <var>stack</var>, 0).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> in <var>stack</var>, do<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[Status]] is <emu-const>linking</emu-const>.</li><li>Set <var>m</var>.[[Status]] to <emu-const>unlinked</emu-const>.</li><li>Set <var>m</var>.[[Environment]] to <emu-val>undefined</emu-val>.</li><li>Set <var>m</var>.[[DFSIndex]] to <emu-val>undefined</emu-val>.</li><li>Set <var>m</var>.[[DFSAncestorIndex]] to <emu-val>undefined</emu-val>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>unlinked</emu-const>.</li><li>Return <var>result</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>linked</emu-const> or <emu-const>evaluated</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>stack</var> is empty.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <div id=\"excluded-sec-InnerModuleLinking\"><h1><span class=\"secnum\">15.2.1.16.1.1</span>#sec-InnerModuleLinking InnerModuleLinking ( module, stack, index )</h1>...</div></emu-clause>\n\n        "}, "sec-getmodulenamespace": {"num": "15.2.1.21", "title": "#sec-getmodulenamespace Runtime Semantics: GetModuleNamespace ( module )", "html": "<emu-clause id=\"sec-getmodulenamespace\" aoid=\"GetModuleNamespace\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getmodulenamespace\">#sec-getmodulenamespace</span> Runtime Semantics: GetModuleNamespace ( <var>module</var> )</h1>\n        <p>The abstract operation GetModuleNamespace takes argument <var>module</var>. It retrieves the Module Namespace Object representing <var>module</var>'s exports, lazily creating it the first time it was requested, and storing it in <var>module</var>.[[Namespace]] for future retrieval. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var> is an instance of a concrete subclass of <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>module</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then <var>module</var>.[[Status]] is not <emu-const>unlinked</emu-const>.</li><li>Let <var>namespace</var> be <var>module</var>.[[Namespace]].</li><li>If <var>namespace</var> is <emu-val>undefined</emu-val>, then<ol><li>Let <var>exportedNames</var> be ? <var>module</var>.GetExportedNames().</li><li>Let <var>unambiguousNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <var>name</var> that is an element of <var>exportedNames</var>, do<ol><li>Let <var>resolution</var> be ? <var>module</var>.ResolveExport(<var>name</var>).</li><li>If <var>resolution</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>, append <var>name</var> to <var>unambiguousNames</var>.</li></ol></li><li>Set <var>namespace</var> to <emu-xref aoid=\"ModuleNamespaceCreate\"><a href=\"#sec-modulenamespacecreate\">ModuleNamespaceCreate</a></emu-xref>(<var>module</var>, <var>unambiguousNames</var>).</li></ol></li><li>Return <var>namespace</var>.</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The only way GetModuleNamespace can throw is via one of the triggered <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> calls. Unresolvable names are simply excluded from the namespace at this point. They will lead to a real linking error later unless they are all ambiguous star exports that are not explicitly requested anywhere.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-typeof-operator": {"num": "12.5.5", "title": "#sec-typeof-operator The typeof Operator", "html": "<emu-clause id=\"sec-typeof-operator\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-typeof-operator\">#sec-typeof-operator</span> The <code>typeof</code> Operator</h1>\n\n      <div id=\"excluded-sec-typeof-operator-runtime-semantics-evaluation\"><h1><span class=\"secnum\">12.5.5.1</span>#sec-typeof-operator-runtime-semantics-evaluation Runtime Semantics: Evaluation</h1>...</div></emu-clause>\n\n    "}, "sec-hostimportmoduledynamically": {"num": "15.2.1.19", "title": "#sec-hostimportmoduledynamically Runtime Semantics: HostImportModuleDynamically ( referencingScriptOrModule, specifier, promiseCapability )", "html": "<emu-clause id=\"sec-hostimportmoduledynamically\" aoid=\"HostImportModuleDynamically\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-hostimportmoduledynamically\">#sec-hostimportmoduledynamically</span> Runtime Semantics: HostImportModuleDynamically ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var> )</h1>\n        <p>HostImportModuleDynamically is an implementation-defined abstract operation that performs any necessary setup work in order to make available the module corresponding to the <emu-nt><a href=\"#prod-ModuleSpecifier\">ModuleSpecifier</a></emu-nt> String, <var>specifier</var>, occurring within the context of the script or module represented by the <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> or <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> <var>referencingScriptOrModule</var>. (<var>referencingScriptOrModule</var> may also be <emu-val>null</emu-val>, if there is no active script or module when the <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> expression occurs.) It then performs <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref> to finish the dynamic import process.</p>\n\n        <p>The implementation of HostImportModuleDynamically must conform to the following requirements:</p>\n\n        <ul>\n          <li>\n            The abstract operation must always complete normally with <emu-val>undefined</emu-val>. Success or failure must instead be signaled as discussed below.\n          </li>\n          <li>\n            The host environment must conform to one of the two following sets of requirements:\n            <dl>\n              <dt>Success path</dt>\n\n              <dd>\n                <ul>\n                  <li>At some future time, the host environment must perform <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>)).</li>\n\n                  <li>Any subsequent call to <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> after <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref> has completed, given the arguments <var>referencingScriptOrModule</var> and <var>specifier</var>, must complete normally.</li>\n\n                  <li>The completion value of any subsequent call to <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> after <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref> has completed, given the arguments <var>referencingScriptOrModule</var> and <var>specifier</var>, must be a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>\n                </ul>\n              </dd>\n\n              <dt>Failure path</dt>\n\n              <dd>\n                <ul>\n                  <li>At some future time, the host environment must perform <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>), with the <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref> representing the cause of failure.</li>\n                </ul>\n              </dd>\n            </dl>\n          </li>\n          <li>\n            If the host environment takes the success path once for a given <var>referencingScriptOrModule</var>, <var>specifier</var> pair, it must always do so for subsequent calls.\n          </li>\n          <li>\n            The operation must not call <var>promiseCapability</var>.[[Resolve]] or <var>promiseCapability</var>.[[Reject]], but instead must treat <var>promiseCapability</var> as an opaque identifying value to be passed through to <emu-xref aoid=\"FinishDynamicImport\"><a href=\"#sec-finishdynamicimport\">FinishDynamicImport</a></emu-xref>.\n          </li>\n        </ul>\n\n        <p>The actual process performed is implementation-defined, but typically consists of performing whatever I/O operations are necessary to allow <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> to synchronously retrieve the appropriate <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, and then calling its Evaluate concrete method. This might require performing similar normalization as <emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref> does.</p>\n      </emu-clause>\n\n      "}, "sec-innermoduleevaluation": {"num": "15.2.1.16.2.1", "title": "#sec-innermoduleevaluation InnerModuleEvaluation ( module, stack, index )", "html": "<emu-clause id=\"sec-innermoduleevaluation\" aoid=\"InnerModuleEvaluation\">\n            <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-innermoduleevaluation\">#sec-innermoduleevaluation</span> InnerModuleEvaluation ( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>\n            <p>The abstract operation InnerModuleEvaluation takes arguments <var>module</var> (a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>), <var>stack</var>, and <var>index</var>. It is used by Evaluate to perform the actual evaluation process for <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as <var>module</var>'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in <emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>. It performs the following steps when called:</p>\n\n            <emu-alg><ol><li>If <var>module</var> is not a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li>Perform ? <var>module</var>.Evaluate().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const>, then<ol><li>If <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>, return <var>index</var>.</li><li>Otherwise, return <var>module</var>.[[EvaluationError]].</li></ol></li><li>If <var>module</var>.[[Status]] is <emu-const>evaluating</emu-const>, return <var>index</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>linked</emu-const>.</li><li>Set <var>module</var>.[[Status]] to <emu-const>evaluating</emu-const>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>NOTE: Link must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.</li><li>Set <var>index</var> to ?&#160;<emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>If <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is either <emu-const>evaluating</emu-const> or <emu-const>evaluated</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is <emu-const>evaluating</emu-const> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <emu-const>evaluating</emu-const>, then<ol><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li></ol></li><li>Perform ? <var>module</var>.<emu-xref aoid=\"ExecuteModule\"><a href=\"#sec-source-text-module-record-execute-module\">ExecuteModule</a></emu-xref>().</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var> occurs exactly once in <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li>Set <var>requiredModule</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <var>index</var>.</li></ol></emu-alg>\n          </emu-clause>\n        "}, "sec-hostensurecancompilestrings": {"num": "18.2.1.2", "title": "#sec-hostensurecancompilestrings HostEnsureCanCompileStrings ( callerRealm, calleeRealm )", "html": "<emu-clause id=\"sec-hostensurecancompilestrings\" aoid=\"HostEnsureCanCompileStrings\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-hostensurecancompilestrings\">#sec-hostensurecancompilestrings</span> HostEnsureCanCompileStrings ( <var>callerRealm</var>, <var>calleeRealm</var> )</h1>\n        <p>HostEnsureCanCompileStrings is an implementation-defined abstract operation that allows host environments to block certain ECMAScript functions which allow developers to compile strings into ECMAScript code.</p>\n\n        <p>An implementation of HostEnsureCanCompileStrings may complete normally or abruptly. Any abrupt completions will be propagated to its callers. The default implementation of HostEnsureCanCompileStrings is to unconditionally return an empty normal completion.</p>\n      </emu-clause>\n\n      "}, "sec-runtime-semantics-destructuringassignmentevaluation": {"num": "12.15.7.2", "title": "#sec-runtime-semantics-destructuringassignmentevaluation Runtime Semantics: DestructuringAssignmentEvaluation", "html": "<emu-clause id=\"sec-runtime-semantics-destructuringassignmentevaluation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-destructuringassignmentevaluation\">#sec-runtime-semantics-destructuringassignmentevaluation</span> Runtime Semantics: DestructuringAssignmentEvaluation</h1>\n        <p>With parameter <var>value</var>.</p>\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"81ba5a4a\"><emu-t>{</emu-t><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"02d75808\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n    <emu-rhs a=\"831120ec\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt><emu-t>,</emu-t><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Perform ? PropertyDestructuringAssignmentEvaluation for <emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt> using <var>value</var> as the argument.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"99d85234\"><emu-t>[</emu-t><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>)).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"31ffe6b2\"><emu-t>[</emu-t><emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Let <var>result</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"72641904\"><emu-t>[</emu-t><emu-nt optional=\"\"><a href=\"#prod-Elision\">Elision</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>If <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> is present, then<ol><li>Let <var>status</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iteratorRecord</var>.[[Done]] is <emu-val>true</emu-val>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li></ol></li><li>Let <var>result</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"815ecab3\"><emu-t>[</emu-t><emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Let <var>result</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li>Return <var>result</var>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ArrayAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ArrayAssignmentPattern\">ArrayAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"cd334403\"><emu-t>[</emu-t><emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt><emu-t>,</emu-t><emu-nt optional=\"\"><a href=\"#prod-Elision\">Elision</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-nt optional=\"\"><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a><emu-mods><emu-opt>opt</emu-opt></emu-mods></emu-nt><emu-t>]</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>iteratorRecord</var> be ?&#160;<emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>value</var>).</li><li>Let <var>status</var> be IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentElementList\">AssignmentElementList</a></emu-nt> with argument <var>iteratorRecord</var>.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li><li>If <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> is present, then<ol><li>Set <var>status</var> to the result of performing IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-Elision\">Elision</a></emu-nt> with <var>iteratorRecord</var> as the argument.</li><li>If <var>status</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>iteratorRecord</var>.[[Done]] is <emu-val>true</emu-val>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></li></ol></li><li>If <emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt> is present, then<ol><li>Set <var>status</var> to the result of performing IteratorDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestElement\">AssignmentRestElement</a></emu-nt> with <var>iteratorRecord</var> as the argument.</li></ol></li><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, return ?&#160;<emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>status</var>).</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>status</var>).</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"d3f69c83\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Let <var>excludedNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Return the result of performing RestDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt> with <var>value</var> and <var>excludedNames</var> as the arguments.</li></ol></emu-alg>\n\n        <emu-grammar><emu-production name=\"ObjectAssignmentPattern\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-ObjectAssignmentPattern\">ObjectAssignmentPattern</a></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"b3c2d7a5\"><emu-t>{</emu-t><emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt><emu-t>,</emu-t><emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt><emu-t>}</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Perform ?&#160;<emu-xref aoid=\"RequireObjectCoercible\"><a href=\"#sec-requireobjectcoercible\">RequireObjectCoercible</a></emu-xref>(<var>value</var>).</li><li>Let <var>excludedNames</var> be ? PropertyDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentPropertyList\">AssignmentPropertyList</a></emu-nt> with argument <var>value</var>.</li><li>Return the result of performing RestDestructuringAssignmentEvaluation of <emu-nt><a href=\"#prod-AssignmentRestProperty\">AssignmentRestProperty</a></emu-nt> with arguments <var>value</var> and <var>excludedNames</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-InnerModuleLinking": {"num": "15.2.1.16.1.1", "title": "#sec-InnerModuleLinking InnerModuleLinking ( module, stack, index )", "html": "<emu-clause id=\"sec-InnerModuleLinking\" oldids=\"sec-innermoduleinstantiation\" aoid=\"InnerModuleLinking\">\n            <span id=\"sec-innermoduleinstantiation\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-InnerModuleLinking\">#sec-InnerModuleLinking</span> InnerModuleLinking ( <var>module</var>, <var>stack</var>, <var>index</var> )</h1>\n            <p>The abstract operation InnerModuleLinking takes arguments <var>module</var> (a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>), <var>stack</var>, and <var>index</var>. It is used by Link to perform the actual linking process for <var>module</var>, as well as recursively on all other modules in the dependency graph. The <var>stack</var> and <var>index</var> parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to <emu-const>linked</emu-const> together. It performs the following steps when called:</p>\n\n            <emu-alg><ol><li>If <var>module</var> is not a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li>Perform ? <var>module</var>.Link().</li><li>Return <var>index</var>.</li></ol></li><li>If <var>module</var>.[[Status]] is <emu-const>linking</emu-const>, <emu-const>linked</emu-const>, or <emu-const>evaluated</emu-const>, then<ol><li>Return <var>index</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>unlinked</emu-const>.</li><li>Set <var>module</var>.[[Status]] to <emu-const>linking</emu-const>.</li><li>Set <var>module</var>.[[DFSIndex]] to <var>index</var>.</li><li>Set <var>module</var>.[[DFSAncestorIndex]] to <var>index</var>.</li><li>Set <var>index</var> to <var>index</var> + 1.</li><li>Append <var>module</var> to <var>stack</var>.</li><li>For each String <var>required</var> that is an element of <var>module</var>.[[RequestedModules]], do<ol><li>Let <var>requiredModule</var> be ?&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>required</var>).</li><li>Set <var>index</var> to ?&#160;<emu-xref aoid=\"InnerModuleLinking\"><a href=\"#sec-InnerModuleLinking\">InnerModuleLinking</a></emu-xref>(<var>requiredModule</var>, <var>stack</var>, <var>index</var>).</li><li>If <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is either <emu-const>linking</emu-const>, <emu-const>linked</emu-const>, or <emu-const>evaluated</emu-const>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var>.[[Status]] is <emu-const>linking</emu-const> if and only if <var>requiredModule</var> is in <var>stack</var>.</li><li>If <var>requiredModule</var>.[[Status]] is <emu-const>linking</emu-const>, then<ol><li>Set <var>module</var>.[[DFSAncestorIndex]] to <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>module</var>.[[DFSAncestorIndex]], <var>requiredModule</var>.[[DFSAncestorIndex]]).</li></ol></li></ol></li></ol></li><li>Perform ? <var>module</var>.<emu-xref aoid=\"InitializeEnvironment\"><a href=\"#sec-source-text-module-record-initialize-environment\">InitializeEnvironment</a></emu-xref>().</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var> occurs exactly once in <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[DFSAncestorIndex]] is less than or equal to <var>module</var>.[[DFSIndex]].</li><li>If <var>module</var>.[[DFSAncestorIndex]] equals <var>module</var>.[[DFSIndex]], then<ol><li>Let <var>done</var> be <emu-val>false</emu-val>.</li><li>Repeat, while <var>done</var> is <emu-val>false</emu-val>,<ol><li>Let <var>requiredModule</var> be the last element in <var>stack</var>.</li><li>Remove the last element of <var>stack</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>requiredModule</var> is a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li>Set <var>requiredModule</var>.[[Status]] to <emu-const>linked</emu-const>.</li><li>If <var>requiredModule</var> and <var>module</var> are the same <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref>, set <var>done</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>Return <var>index</var>.</li></ol></emu-alg>\n          </emu-clause>\n        "}, "sec-moduleevaluation": {"num": "15.2.1.16.2", "title": "#sec-moduleevaluation Evaluate ( ) Concrete Method", "html": "<emu-clause id=\"sec-moduleevaluation\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-moduleevaluation\">#sec-moduleevaluation</span> Evaluate ( ) Concrete Method</h1>\n          <p>The Evaluate concrete method of a <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#sec-abstract-module-records\"><a href=\"#sec-abstract-module-records\">Module Record</a></emu-xref> abstract method.</p>\n          <p>Evaluate transitions this module's [[Status]] from <emu-const>linked</emu-const> to <emu-const>evaluated</emu-const>.</p>\n          <p>If execution results in an exception, that exception is recorded in the [[EvaluationError]] field and rethrown by future invocations of Evaluate.</p>\n          <p>This abstract method performs the following steps (most of the work is done by the auxiliary function <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>):</p>\n\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: This call to Evaluate is not happening at the same time as another call to Evaluate within the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>.</li><li>Let <var>module</var> be this <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>linked</emu-const> or <emu-const>evaluated</emu-const>.</li><li>Let <var>stack</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>result</var> be <emu-xref aoid=\"InnerModuleEvaluation\"><a href=\"#sec-innermoduleevaluation\">InnerModuleEvaluation</a></emu-xref>(<var>module</var>, <var>stack</var>, 0).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>For each <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> <var>m</var> in <var>stack</var>, do<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>m</var>.[[Status]] is <emu-const>evaluating</emu-const>.</li><li>Set <var>m</var>.[[Status]] to <emu-const>evaluated</emu-const>.</li><li>Set <var>m</var>.[[EvaluationError]] to <var>result</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const> and <var>module</var>.[[EvaluationError]] is <var>result</var>.</li><li>Return <var>result</var>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Status]] is <emu-const>evaluated</emu-const> and <var>module</var>.[[EvaluationError]] is <emu-val>undefined</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>stack</var> is empty.</li><li>Return <emu-val>undefined</emu-val>.</li></ol></emu-alg>\n\n          <div id=\"excluded-sec-innermoduleevaluation\"><h1><span class=\"secnum\">15.2.1.16.2.1</span>#sec-innermoduleevaluation InnerModuleEvaluation ( module, stack, index )</h1>...</div></emu-clause>\n\n        "}, "sec-host-promise-rejection-tracker": {"num": "25.6.1.9", "title": "#sec-host-promise-rejection-tracker HostPromiseRejectionTracker ( promise, operation )", "html": "<emu-clause id=\"sec-host-promise-rejection-tracker\" aoid=\"HostPromiseRejectionTracker\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-host-promise-rejection-tracker\">#sec-host-promise-rejection-tracker</span> HostPromiseRejectionTracker ( <var>promise</var>, <var>operation</var> )</h1>\n        <p>HostPromiseRejectionTracker is an implementation-defined abstract operation that allows host environments to track promise rejections.</p>\n\n        <p>An implementation of HostPromiseRejectionTracker must complete normally in all cases. The default implementation of HostPromiseRejectionTracker is to unconditionally return an empty normal completion.</p>\n\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>HostPromiseRejectionTracker is called in two scenarios:</p>\n\n          <ul>\n            <li>When a promise is rejected without any handlers, it is called with its <var>operation</var> argument set to <emu-val>\"reject\"</emu-val>.</li>\n            <li>When a handler is added to a rejected promise for the first time, it is called with its <var>operation</var> argument set to <emu-val>\"handle\"</emu-val>.</li>\n          </ul>\n\n          <p>A typical implementation of HostPromiseRejectionTracker might try to notify developers of unhandled rejections, while also being careful to notify them if such previous notifications are later invalidated by new handlers being attached.</p>\n        </div></emu-note>\n\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>If <var>operation</var> is <emu-val>\"handle\"</emu-val>, an implementation should not hold a reference to <var>promise</var> in a way that would interfere with garbage collection. An implementation may hold a reference to <var>promise</var> if <var>operation</var> is <emu-val>\"reject\"</emu-val>, since it is expected that rejections will be rare and not on hot code paths.</p>\n        </div></emu-note>\n      </emu-clause>\n    "}, "sec-asyncgenerator-prototype-tostringtag": {"num": "25.5.1.5", "title": "#sec-asyncgenerator-prototype-tostringtag AsyncGenerator.prototype [ @@toStringTag ]", "html": "<emu-clause id=\"sec-asyncgenerator-prototype-tostringtag\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-asyncgenerator-prototype-tostringtag\">#sec-asyncgenerator-prototype-tostringtag</span> AsyncGenerator.prototype [ @@toStringTag ]</h1>\n        <p>The initial value of the @@toStringTag property is the String value <emu-val>\"AsyncGenerator\"</emu-val>.</p>\n        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>\n      </emu-clause>\n    "}, "sec-copydataproperties": {"num": "7.3.25", "title": "#sec-copydataproperties CopyDataProperties ( target, source, excludedItems )", "html": "<emu-clause id=\"sec-copydataproperties\" aoid=\"CopyDataProperties\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-copydataproperties\">#sec-copydataproperties</span> CopyDataProperties ( <var>target</var>, <var>source</var>, <var>excludedItems</var> )</h1>\n      <p>The abstract operation CopyDataProperties takes arguments <var>target</var>, <var>source</var>, and <var>excludedItems</var>. It performs the following steps when called:</p>\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>target</var>) is Object.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>excludedItems</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of property keys.</li><li>If <var>source</var> is <emu-val>undefined</emu-val> or <emu-val>null</emu-val>, return <var>target</var>.</li><li>Let <var>from</var> be !&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<var>source</var>).</li><li>Let <var>keys</var> be ? <var>from</var>.[[OwnPropertyKeys]]().</li><li>For each element <var>nextKey</var> of <var>keys</var> in <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> order, do<ol><li>Let <var>excluded</var> be <emu-val>false</emu-val>.</li><li>For each element <var>e</var> of <var>excludedItems</var> in <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> order, do<ol><li>If <emu-xref aoid=\"SameValue\"><a href=\"#sec-samevalue\">SameValue</a></emu-xref>(<var>e</var>, <var>nextKey</var>) is <emu-val>true</emu-val>, then<ol><li>Set <var>excluded</var> to <emu-val>true</emu-val>.</li></ol></li></ol></li><li>If <var>excluded</var> is <emu-val>false</emu-val>, then<ol><li>Let <var>desc</var> be ? <var>from</var>.[[GetOwnProperty]](<var>nextKey</var>).</li><li>If <var>desc</var> is not <emu-val>undefined</emu-val> and <var>desc</var>.[[Enumerable]] is <emu-val>true</emu-val>, then<ol><li>Let <var>propValue</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>from</var>, <var>nextKey</var>).</li><li>Perform !&#160;<emu-xref aoid=\"CreateDataPropertyOrThrow\"><a href=\"#sec-createdatapropertyorthrow\">CreateDataPropertyOrThrow</a></emu-xref>(<var>target</var>, <var>nextKey</var>, <var>propValue</var>).</li></ol></li></ol></li></ol></li><li>Return <var>target</var>.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The target passed in here is always a newly created object which is not directly accessible in case of an error being thrown.</p>\n      </div></emu-note>\n    </emu-clause>\n  "}, "sec-forward-progress": {"num": "8.8", "title": "#sec-forward-progress Forward Progress", "html": "<emu-clause id=\"sec-forward-progress\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-forward-progress\">#sec-forward-progress</span> Forward Progress</h1>\n    <p>For an <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> to <em>make forward progress</em> is for it to perform an evaluation step according to this specification.</p>\n    <p>An <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> becomes <em>blocked</em> when its <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref> waits synchronously and indefinitely for an external event. Only agents whose <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>'s [[CanBlock]] property is <emu-val>true</emu-val> can become blocked in this sense.  An <em>unblocked</em> <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> is one that is not blocked.</p>\n\n    <p>Implementations must ensure that:</p>\n    <ul>\n      <li>every unblocked <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> with a dedicated <emu-xref href=\"#executing-thread\"><a href=\"#executing-thread\">executing thread</a></emu-xref> eventually makes forward progress</li>\n      <li>in a set of agents that share an <emu-xref href=\"#executing-thread\"><a href=\"#executing-thread\">executing thread</a></emu-xref>, one <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> eventually makes forward progress</li>\n      <li>an <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> does not cause another <emu-xref href=\"#agent\"><a href=\"#agent\">agent</a></emu-xref> to become blocked except via explicit APIs that provide blocking.</li>\n    </ul>\n\n    <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n      <p>This, along with the liveness guarantee in the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>, ensures that all <emu-const>SeqCst</emu-const> writes eventually become observable to all agents.</p>\n    </div></emu-note>\n  </emu-clause>\n"}, "sec-array.prototype.includes": {"num": "22.1.3.13", "title": "#sec-array.prototype.includes Array.prototype.includes ( searchElement [ , fromIndex ] )", "html": "<emu-clause id=\"sec-array.prototype.includes\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-array.prototype.includes\">#sec-array.prototype.includes</span> Array.prototype.includes ( <var>searchElement</var> [ , <var>fromIndex</var> ] )</h1>\n\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p><code>includes</code> compares <var>searchElement</var> to the elements of the array, in ascending order, using the <emu-xref aoid=\"SameValueZero\"><a href=\"#sec-samevaluezero\">SameValueZero</a></emu-xref> algorithm, and if found at any position, returns <emu-val>true</emu-val>; otherwise, <emu-val>false</emu-val> is returned.</p>\n\n          <p>The optional second argument <var>fromIndex</var> defaults to 0 (i.e. the whole array is searched). If it is greater than or equal to the length of the array, <emu-val>false</emu-val> is returned, i.e. the array will not be searched. If it is negative, it is used as the offset from the end of the array to compute <var>fromIndex</var>. If the computed index is less than 0, the whole array will be searched.</p>\n        </div></emu-note>\n        <p>When the <code>includes</code> method is called, the following steps are taken:</p>\n\n        <emu-alg><ol><li>Let <var>O</var> be ?&#160;<emu-xref aoid=\"ToObject\"><a href=\"#sec-toobject\">ToObject</a></emu-xref>(<emu-val>this</emu-val> value).</li><li>Let <var>len</var> be ?&#160;<emu-xref aoid=\"LengthOfArrayLike\"><a href=\"#sec-lengthofarraylike\">LengthOfArrayLike</a></emu-xref>(<var>O</var>).</li><li>If <var>len</var> is 0, return <emu-val>false</emu-val>.</li><li>Let <var>n</var> be ?&#160;<emu-xref aoid=\"ToInteger\"><a href=\"#sec-tointeger\">ToInteger</a></emu-xref>(<var>fromIndex</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>fromIndex</var> is <emu-val>undefined</emu-val>, then <var>n</var> is 0.</li><li>If <var>n</var> &#8805; 0, then<ol><li>Let <var>k</var> be <var>n</var>.</li></ol></li><li>Else,<ol><li>Let <var>k</var> be <var>len</var> + <var>n</var>.</li><li>If <var>k</var> &lt; 0, set <var>k</var> to 0.</li></ol></li><li>Repeat, while <var>k</var> &lt; <var>len</var>,<ol><li>Let <var>elementK</var> be the result of ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>O</var>, !&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>k</var>)).</li><li>If <emu-xref aoid=\"SameValueZero\"><a href=\"#sec-samevaluezero\">SameValueZero</a></emu-xref>(<var>searchElement</var>, <var>elementK</var>) is <emu-val>true</emu-val>, return <emu-val>true</emu-val>.</li><li>Set <var>k</var> to <var>k</var> + 1.</li></ol></li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>includes</code> function is intentionally generic; it does not require that its <emu-val>this</emu-val> value be an Array object. Therefore it can be transferred to other kinds of objects for use as a method.</p>\n        </div></emu-note>\n\n        <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n          <p>The <code>includes</code> method intentionally differs from the similar <code>indexOf</code> method in two ways. First, it uses the <emu-xref aoid=\"SameValueZero\"><a href=\"#sec-samevaluezero\">SameValueZero</a></emu-xref> algorithm, instead of <emu-xref aoid=\"Strict Equality Comparison\"><a href=\"#sec-strict-equality-comparison\">Strict Equality Comparison</a></emu-xref>, allowing it to detect <emu-val>NaN</emu-val> array elements. Second, it does not skip missing array elements, instead treating them as <emu-val>undefined</emu-val>.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-parse-script": {"num": "15.1.9", "title": "#sec-parse-script ParseScript ( sourceText, realm, hostDefined )", "html": "<emu-clause id=\"sec-parse-script\" aoid=\"ParseScript\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-parse-script\">#sec-parse-script</span> ParseScript ( <var>sourceText</var>, <var>realm</var>, <var>hostDefined</var> )</h1>\n      <p>The abstract operation ParseScript takes arguments <var>sourceText</var>, <var>realm</var>, and <var>hostDefined</var>. It creates a <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> based upon the result of parsing <var>sourceText</var> as a <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt>. It performs the following steps when called:</p>\n\n      <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>sourceText</var> is an ECMAScript source text (see clause <emu-xref href=\"#sec-ecmascript-language-source-code\"><a href=\"#sec-ecmascript-language-source-code\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-source-code\">#sec-ecmascript-language-source-code</a></emu-xref>).</li><li>Parse <var>sourceText</var> using <emu-nt><a href=\"#prod-Script\">Script</a></emu-nt> as the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> and analyse the parse result for any Early Error conditions. If the parse was successful and no early errors were found, let <var>body</var> be the resulting parse tree. Otherwise, let <var>body</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of one or more <emu-val>SyntaxError</emu-val> objects representing the parsing errors and/or early errors. Parsing and <emu-xref href=\"#early-error\"><a href=\"#early-error\">early error</a></emu-xref> detection may be interweaved in an implementation-dependent manner. If more than one parsing error or <emu-xref href=\"#early-error\"><a href=\"#early-error\">early error</a></emu-xref> is present, the number and ordering of error objects in the list is implementation-dependent, but at least one must be present.</li><li>If <var>body</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of errors, return <var>body</var>.</li><li>Return <emu-xref href=\"#script-record\"><a href=\"#script-record\">Script Record</a></emu-xref> { [[Realm]]: <var>realm</var>, [[Environment]]: <emu-val>undefined</emu-val>, [[ECMAScriptCode]]: <var>body</var>, [[HostDefined]]: <var>hostDefined</var> }.</li></ol></emu-alg>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>An implementation may parse script source text and analyse it for Early Error conditions prior to evaluation of ParseScript for that script source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseScript upon that source text.</p>\n      </div></emu-note>\n    </emu-clause>\n\n    "}, "sec-numericvalue": {"num": "11.8.3.2", "title": "#sec-numericvalue Static Semantics: NumericValue", "html": "<emu-clause id=\"sec-numericvalue\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numericvalue\">#sec-numericvalue</span> Static Semantics: NumericValue</h1>\n        <emu-grammar><emu-production name=\"NumericLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-NumericLiteral\">NumericLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"18c0356f\"><emu-nt><a href=\"#prod-DecimalLiteral\">DecimalLiteral</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that results from rounding the MV of <emu-nt><a href=\"#prod-DecimalLiteral\">DecimalLiteral</a></emu-nt> as described below.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"NumericLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-NumericLiteral\">NumericLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e867b70b\"><emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that results from rounding the MV of <emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt> as described below.</li></ol></emu-alg>\n        <p>Once the exact MV for a numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0<sub>&#8477;</sub>, then the rounded value is <emu-val>+0</emu-val>; otherwise, the rounded value must be the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the MV (as specified in <emu-xref href=\"#sec-ecmascript-language-types-number-type\"><a href=\"#sec-ecmascript-language-types-number-type\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-types-number-type\">#sec-ecmascript-language-types-number-type</a></emu-xref>), unless the literal is a <emu-nt><a href=\"#prod-DecimalLiteral\">DecimalLiteral</a></emu-nt> and the literal has more than 20 significant digits, in which case the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> may be either the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the MV of a literal produced by replacing each significant digit after the 20th with a <code>0</code> digit or the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> for the MV of a literal produced by replacing each significant digit after the 20th with a <code>0</code> digit and then incrementing the literal at the 20th significant digit position. A digit is <em>significant</em> if it is not part of an <emu-nt><a href=\"#prod-ExponentPart\">ExponentPart</a></emu-nt> and</p>\n        <ul>\n          <li>\n            it is not <code>0</code>; or\n          </li>\n          <li>\n            there is a nonzero digit to its left and there is a nonzero digit, not in the <emu-nt><a href=\"#prod-ExponentPart\">ExponentPart</a></emu-nt>, to its right.\n          </li>\n        </ul>\n\n        <emu-grammar><emu-production name=\"NumericLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-NumericLiteral\">NumericLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"68def506\"><emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the BigInt value that represents the MV of <emu-nt><a href=\"#prod-NonDecimalIntegerLiteral\">NonDecimalIntegerLiteral</a></emu-nt>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"DecimalBigIntegerLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-DecimalBigIntegerLiteral\">DecimalBigIntegerLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"ddee4872\"><emu-t>0</emu-t><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the BigInt value that represents 0<sub>&#8477;</sub>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"DecimalBigIntegerLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-DecimalBigIntegerLiteral\">DecimalBigIntegerLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"7641418e\"><emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Return the BigInt value that represents the MV of <emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt>.</li></ol></emu-alg>\n        <emu-grammar><emu-production name=\"DecimalBigIntegerLiteral\" type=\"lexical\" collapsed=\"\">\n    <emu-nt><a href=\"#prod-DecimalBigIntegerLiteral\">DecimalBigIntegerLiteral</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"93069ccc\"><emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt><emu-nt><a href=\"#prod-DecimalDigits\">DecimalDigits</a></emu-nt><emu-nt><a href=\"#prod-BigIntLiteralSuffix\">BigIntLiteralSuffix</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar>\n        <emu-alg><ol><li>Let <var>n</var> be the <emu-xref href=\"#mathematical%20integer\"><a href=\"#mathematical%20integer\">mathematical integer</a></emu-xref> number of code points in <emu-nt><a href=\"#prod-DecimalDigits\">DecimalDigits</a></emu-nt>.</li><li>Let <var>mv</var> be (the MV of <emu-nt><a href=\"#prod-NonZeroDigit\">NonZeroDigit</a></emu-nt> &#215; 10<sub>&#8477;</sub><sup><var>n</var></sup>) plus the MV of <emu-nt><a href=\"#prod-DecimalDigits\">DecimalDigits</a></emu-nt>.</li><li>Return the BigInt value that represents <var>mv</var>.</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-finishdynamicimport": {"num": "15.2.1.20", "title": "#sec-finishdynamicimport Runtime Semantics: FinishDynamicImport ( referencingScriptOrModule, specifier, promiseCapability, completion )", "html": "<emu-clause id=\"sec-finishdynamicimport\" aoid=\"FinishDynamicImport\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-finishdynamicimport\">#sec-finishdynamicimport</span> Runtime Semantics: FinishDynamicImport ( <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, <var>completion</var> )</h1>\n        <p>The abstract operation FinishDynamicImport takes arguments <var>referencingScriptOrModule</var>, <var>specifier</var>, <var>promiseCapability</var>, and <var>completion</var>. FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href=\"#sec-import-calls\"><a href=\"#sec-import-calls\"><code>import()</code></a></emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to <var>completion</var>. It is performed by host environments as part of <emu-xref aoid=\"HostImportModuleDynamically\"><a href=\"#sec-hostimportmoduledynamically\">HostImportModuleDynamically</a></emu-xref>. It performs the following steps when called:</p>\n\n        <emu-alg><ol><li>If <var>completion</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>completion</var>.[[Value]] &#187;).</li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>completion</var> is a normal completion and <var>completion</var>.[[Value]] is <emu-val>undefined</emu-val>.</li><li>Let <var>moduleRecord</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>referencingScriptOrModule</var>, <var>specifier</var>).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: Evaluate has already been invoked on <var>moduleRecord</var> and successfully completed.</li><li>Let <var>namespace</var> be <emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>moduleRecord</var>).</li><li>If <var>namespace</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Reject]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li><li>Else, perform !&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>namespace</var>.[[Value]] &#187;).</li></ol></li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-source-text-module-record-initialize-environment": {"num": "15.2.1.17.4", "title": "#sec-source-text-module-record-initialize-environment InitializeEnvironment ( ) Concrete Method", "html": "<emu-clause id=\"sec-source-text-module-record-initialize-environment\" aoid=\"InitializeEnvironment\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-source-text-module-record-initialize-environment\">#sec-source-text-module-record-initialize-environment</span> InitializeEnvironment ( ) Concrete Method</h1>\n          <p>The InitializeEnvironment concrete method of a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> abstract method.</p>\n          <p>This abstract method performs the following steps:</p>\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>.</li><li>For each <emu-xref href=\"#exportentry-record\"><a href=\"#exportentry-record\">ExportEntry Record</a></emu-xref> <var>e</var> in <var>module</var>.[[IndirectExportEntries]], do<ol><li>Let <var>resolution</var> be ? <var>module</var>.ResolveExport(<var>e</var>.[[ExportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resolution</var> is a <emu-xref href=\"#resolvedbinding-record\"><a href=\"#resolvedbinding-record\">ResolvedBinding Record</a></emu-xref>.</li></ol></li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: All named exports from <var>module</var> are resolvable.</li><li>Let <var>realm</var> be <var>module</var>.[[Realm]].</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>realm</var> is not <emu-val>undefined</emu-val>.</li><li>Let <var>env</var> be <emu-xref aoid=\"NewModuleEnvironment\"><a href=\"#sec-newmoduleenvironment\">NewModuleEnvironment</a></emu-xref>(<var>realm</var>.[[GlobalEnv]]).</li><li>Set <var>module</var>.[[Environment]] to <var>env</var>.</li><li>For each <emu-xref href=\"#importentry-record\"><a href=\"#importentry-record\">ImportEntry Record</a></emu-xref> <var>in</var> in <var>module</var>.[[ImportEntries]], do<ol><li>Let <var>importedModule</var> be !&#160;<emu-xref aoid=\"HostResolveImportedModule\"><a href=\"#sec-hostresolveimportedmodule\">HostResolveImportedModule</a></emu-xref>(<var>module</var>, <var>in</var>.[[ModuleRequest]]).</li><li>NOTE: The above call cannot fail because imported module requests are a subset of <var>module</var>.[[RequestedModules]], and these have been resolved earlier in this algorithm.</li><li>If <var>in</var>.[[ImportName]] is <emu-val>\"*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>importedModule</var>).</li><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Let <var>resolution</var> be ? <var>importedModule</var>.ResolveExport(<var>in</var>.[[ImportName]]).</li><li>If <var>resolution</var> is <emu-val>null</emu-val> or <emu-val>\"ambiguous\"</emu-val>, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>resolution</var>.[[BindingName]] is <emu-val>\"*namespace*\"</emu-val>, then<ol><li>Let <var>namespace</var> be ?&#160;<emu-xref aoid=\"GetModuleNamespace\"><a href=\"#sec-getmodulenamespace\">GetModuleNamespace</a></emu-xref>(<var>resolution</var>.[[Module]]).</li><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>in</var>.[[LocalName]], <emu-val>true</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>in</var>.[[LocalName]], <var>namespace</var>).</li></ol></li><li>Else,<ol><li>Call <var>env</var>.CreateImportBinding(<var>in</var>.[[LocalName]], <var>resolution</var>.[[Module]], <var>resolution</var>.[[BindingName]]).</li></ol></li></ol></li></ol></li><li>Let <var>moduleContext</var> be a new ECMAScript code <emu-xref href=\"#sec-execution-contexts\"><a href=\"#sec-execution-contexts\">execution context</a></emu-xref>.</li><li>Set the Function of <var>moduleContext</var> to <emu-val>null</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>module</var>.[[Realm]] is not <emu-val>undefined</emu-val>.</li><li>Set the <emu-xref href=\"#realm\"><a href=\"#realm\">Realm</a></emu-xref> of <var>moduleContext</var> to <var>module</var>.[[Realm]].</li><li>Set the ScriptOrModule of <var>moduleContext</var> to <var>module</var>.</li><li>Set the VariableEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set the LexicalEnvironment of <var>moduleContext</var> to <var>module</var>.[[Environment]].</li><li>Set <var>module</var>.[[Context]] to <var>moduleContext</var>.</li><li>Push <var>moduleContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>moduleContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>code</var> be <var>module</var>.[[ECMAScriptCode]].</li><li>Let <var>varDeclarations</var> be the VarScopedDeclarations of <var>code</var>.</li><li>Let <var>declaredVarNames</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each element <var>d</var> in <var>varDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If <var>dn</var> is not an element of <var>declaredVarNames</var>, then<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li><li>Call <var>env</var>.InitializeBinding(<var>dn</var>, <emu-val>undefined</emu-val>).</li><li>Append <var>dn</var> to <var>declaredVarNames</var>.</li></ol></li></ol></li></ol></li><li>Let <var>lexDeclarations</var> be the LexicallyScopedDeclarations of <var>code</var>.</li><li>For each element <var>d</var> in <var>lexDeclarations</var>, do<ol><li>For each element <var>dn</var> of the BoundNames of <var>d</var>, do<ol><li>If IsConstantDeclaration of <var>d</var> is <emu-val>true</emu-val>, then<ol><li>Perform ! <var>env</var>.CreateImmutableBinding(<var>dn</var>, <emu-val>true</emu-val>).</li></ol></li><li>Else,<ol><li>Perform ! <var>env</var>.CreateMutableBinding(<var>dn</var>, <emu-val>false</emu-val>).</li></ol></li><li>If <var>d</var> is a <emu-nt><a href=\"#prod-FunctionDeclaration\">FunctionDeclaration</a></emu-nt>, a <emu-nt><a href=\"#prod-GeneratorDeclaration\">GeneratorDeclaration</a></emu-nt>, an <emu-nt><a href=\"#prod-AsyncFunctionDeclaration\">AsyncFunctionDeclaration</a></emu-nt>, or an <emu-nt><a href=\"#prod-AsyncGeneratorDeclaration\">AsyncGeneratorDeclaration</a></emu-nt>, then<ol><li>Let <var>fo</var> be InstantiateFunctionObject of <var>d</var> with argument <var>env</var>.</li><li>Call <var>env</var>.InitializeBinding(<var>dn</var>, <var>fo</var>).</li></ol></li></ol></li></ol></li><li>Remove <var>moduleContext</var> from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).</li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-reflection": {"num": "26", "title": "#sec-reflection Reflection", "html": "<emu-clause id=\"sec-reflection\">\n  <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-reflection\">#sec-reflection</span> Reflection</h1>\n\n  <div id=\"excluded-sec-reflect-object\"><h1><span class=\"secnum\">26.1</span>#sec-reflect-object The Reflect Object</h1>...</div><div id=\"excluded-sec-proxy-objects\"><h1><span class=\"secnum\">26.2</span>#sec-proxy-objects Proxy Objects</h1>...</div><div id=\"excluded-sec-module-namespace-objects\"><h1><span class=\"secnum\">26.3</span>#sec-module-namespace-objects Module Namespace Objects</h1>...</div></emu-clause>\n\n"}, "sec-source-text-module-record-execute-module": {"num": "15.2.1.17.5", "title": "#sec-source-text-module-record-execute-module ExecuteModule ( ) Concrete Method", "html": "<emu-clause id=\"sec-source-text-module-record-execute-module\" aoid=\"ExecuteModule\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-source-text-module-record-execute-module\">#sec-source-text-module-record-execute-module</span> ExecuteModule ( ) Concrete Method</h1>\n          <p>The ExecuteModule concrete method of a <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref> implements the corresponding <emu-xref href=\"#cyclic-module-record\"><a href=\"#cyclic-module-record\">Cyclic Module Record</a></emu-xref> abstract method.</p>\n          <p>This abstract method performs the following steps:</p>\n\n          <emu-alg><ol><li>Let <var>module</var> be this <emu-xref href=\"#sourctextmodule-record\"><a href=\"#sourctextmodule-record\">Source Text Module Record</a></emu-xref>.</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> the currently <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>moduleContext</var> be <var>module</var>.[[Context]].</li><li>Push <var>moduleContext</var> onto the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>; <var>moduleContext</var> is now the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Let <var>result</var> be the result of evaluating <var>module</var>.[[ECMAScriptCode]].</li><li><emu-xref aoid=\"Suspend\"><a href=\"#sec-suspend\">Suspend</a></emu-xref> <var>moduleContext</var> and remove it from the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref>.</li><li>Resume the context that is now on the top of the <emu-xref href=\"#execution-context-stack\"><a href=\"#execution-context-stack\">execution context stack</a></emu-xref> as the <emu-xref href=\"#running-execution-context\"><a href=\"#running-execution-context\">running execution context</a></emu-xref>.</li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-%typedarray%-intrinsic-object": {"num": "22.2.1", "title": "#sec-%typedarray%-intrinsic-object The %TypedArray% Intrinsic Object", "html": "<emu-clause id=\"sec-%typedarray%-intrinsic-object\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-%typedarray%-intrinsic-object\">#sec-%typedarray%-intrinsic-object</span> The %TypedArray% Intrinsic Object</h1>\n      <p>The <dfn>%TypedArray%</dfn> intrinsic object:</p>\n      <ul>\n        <li>is a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> <emu-xref href=\"#function-object\"><a href=\"#function-object\">function object</a></emu-xref> that all of the <var>TypedArray</var> <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> objects inherit from.</li>\n        <li>along with its corresponding prototype object, provides common properties that are inherited by all <var>TypedArray</var> constructors and their instances.</li>\n        <li>does not have a global name or appear as a property of the <emu-xref href=\"#sec-global-object\"><a href=\"#sec-global-object\">global object</a></emu-xref>.</li>\n        <li>acts as the abstract superclass of the various <var>TypedArray</var> constructors.</li>\n        <li>will throw an error when invoked, because it is an abstract class <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>. The <var>TypedArray</var> constructors do not perform a <code>super</code> call to it.</li>\n      </ul>\n\n      <div id=\"excluded-sec-%typedarray%\"><h1><span class=\"secnum\">22.2.1.1</span>#sec-%typedarray% %TypedArray% ( )</h1>...</div></emu-clause>\n\n    "}, "sec-async-from-sync-iterator-value-unwrap-functions": {"num": "25.1.4.2.4", "title": "#sec-async-from-sync-iterator-value-unwrap-functions Async-from-Sync Iterator Value Unwrap Functions", "html": "<emu-clause id=\"sec-async-from-sync-iterator-value-unwrap-functions\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-async-from-sync-iterator-value-unwrap-functions\">#sec-async-from-sync-iterator-value-unwrap-functions</span> Async-from-Sync Iterator Value Unwrap Functions</h1>\n          <p>An async-from-sync iterator value unwrap function is an anonymous built-in function that is used by <emu-xref aoid=\"AsyncFromSyncIteratorContinuation\"><a href=\"#sec-asyncfromsynciteratorcontinuation\">AsyncFromSyncIteratorContinuation</a></emu-xref> when processing the <emu-val>\"value\"</emu-val> property of an <i>IteratorResult</i> object, in order to wait for its value if it is a promise and re-package the result in a new \"unwrapped\" <i>IteratorResult</i> object. Each async-from-sync iterator value unwrap function has a [[Done]] internal slot.</p>\n          <p>When an async-from-sync iterator value unwrap function is called with argument <var>value</var>, the following steps are taken:</p>\n\n          <emu-alg><ol><li>Let <var>F</var> be the <emu-xref href=\"#active-function-object\"><a href=\"#active-function-object\">active function object</a></emu-xref>.</li><li>Return !&#160;<emu-xref aoid=\"CreateIterResultObject\"><a href=\"#sec-createiterresultobject\">CreateIterResultObject</a></emu-xref>(<var>value</var>, <var>F</var>.[[Done]]).</li></ol></emu-alg>\n        </emu-clause>\n      "}}, "figData": {"table-8": "Table 9"}}}