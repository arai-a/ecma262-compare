{"from": {"secList": ["sec-backreference-matcher", "sec-ecmascript-specification-types", "sec-pattern", "sec-data-blocks", "sec-atom", "sec-disjunction", "sec-pattern-semantics", "sec-runtime-semantics-repeatmatcher-abstract-operation", "sec-term", "sec-notation", "sec-escaperegexppattern", "sec-regexpinitialize", "sec-assertion", "sec-alternative", "sec-runtime-semantics-canonicalize-ch", "sec-runtime-semantics-charactersetmatcher-abstract-operation", "sec-properties-of-regexp-instances"], "secData": {"sec-backreference-matcher": {"num": "21.2.2.9.1", "title": "#sec-backreference-matcher Runtime Semantics: BackreferenceMatcher ( n, direction )", "html": "<emu-clause id=\"sec-backreference-matcher\" aoid=\"BackreferenceMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-backreference-matcher\">#sec-backreference-matcher</span> Runtime Semantics: BackreferenceMatcher ( <var>n</var>, <var>direction</var> )</h1>\n          <p>The abstract operation BackreferenceMatcher takes two arguments, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>n</var> and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>direction</var>, and performs the following steps:</p>\n          <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>s</var> be <var>cap</var>[<var>n</var>].</li><li>If <var>s</var> is <emu-val>undefined</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>len</var> be the number of elements in <var>s</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var> &#215; <var>len</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>g</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>If there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> between 0 (inclusive) and <var>len</var> (exclusive) such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>s</var>[<var>i</var>]) is not the same character value as <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>Input</var>[<var>g</var> + <var>i</var>]), return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>y</var>) and return its result.\n          </li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-ecmascript-specification-types": {"num": "6.2", "title": "#sec-ecmascript-specification-types ECMAScript Specification Types", "html": "<emu-clause id=\"sec-ecmascript-specification-types\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-specification-types\">#sec-ecmascript-specification-types</span> ECMAScript Specification Types</h1>\n    <p>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types include <emu-xref href=\"#sec-reference-specification-type\"><a href=\"#sec-reference-specification-type\">Reference</a></emu-xref>, <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>, <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>, <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref>, <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>, <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, and <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref>. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.</p>\n\n    <div id=\"excluded-sec-list-and-record-specification-type\"><h1><span class=\"secnum\">6.2.1</span>#sec-list-and-record-specification-type The List and Record Specification Types</h1>...</div><div id=\"excluded-sec-set-and-relation-specification-type\"><h1><span class=\"secnum\">6.2.2</span>#sec-set-and-relation-specification-type The Set and Relation Specification Types</h1>...</div><div id=\"excluded-sec-completion-record-specification-type\"><h1><span class=\"secnum\">6.2.3</span>#sec-completion-record-specification-type The Completion Record Specification Type</h1>...</div><div id=\"excluded-sec-reference-specification-type\"><h1><span class=\"secnum\">6.2.4</span>#sec-reference-specification-type The Reference Specification Type</h1>...</div><div id=\"excluded-sec-property-descriptor-specification-type\"><h1><span class=\"secnum\">6.2.5</span>#sec-property-descriptor-specification-type The Property Descriptor Specification Type</h1>...</div><div id=\"excluded-sec-lexical-environment-and-environment-record-specification-types\"><h1><span class=\"secnum\">6.2.6</span>#sec-lexical-environment-and-environment-record-specification-types The Lexical Environment and Environment Record Specification Types</h1>...</div><div id=\"excluded-sec-data-blocks\"><h1><span class=\"secnum\">6.2.7</span>#sec-data-blocks Data Blocks</h1>...</div></emu-clause>\n"}, "sec-pattern": {"num": "21.2.2.2", "title": "#sec-pattern Pattern", "html": "<emu-clause id=\"sec-pattern\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-pattern\">#sec-pattern</span> Pattern</h1>\n        <p>The production  <emu-grammar><emu-production name=\"Pattern\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"79a5bbd0\"><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal closure that takes two arguments, a String <var>str</var> and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>index</var>, and performs the following steps:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>index</var> &#8804; the length of <var>str</var>.</li><li>If <var>Unicode</var> is <emu-val>true</emu-val>, let <var>Input</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the sequence of code points of !&#160;<emu-xref aoid=\"UTF16DecodeString\"><a href=\"#sec-utf16decodestring\">UTF16DecodeString</a></emu-xref>(<var>str</var>). Otherwise, let <var>Input</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the sequence of code units that are the elements of <var>str</var>. <var>Input</var> will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>. Each element of <var>Input</var> is considered to be a character.</li><li>Let <var>InputLength</var> be the number of characters contained in <var>Input</var>. This variable will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>.</li><li>Let <var>listIndex</var> be the index into <var>Input</var> of the character that was obtained from element <var>index</var> of <var>str</var>.</li><li>Let <var>c</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Let <var>cap</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> <emu-val>undefined</emu-val> values, indexed 1 through <var>NcapturingParens</var>.</li><li>Let <var>x</var> be the State (<var>listIndex</var>, <var>cap</var>).</li><li>Call <var>m</var>(<var>x</var>, <var>c</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>A Pattern evaluates (&#8220;compiles&#8221;) to an internal procedure value. <emu-xref aoid=\"RegExpBuiltinExec\"><a href=\"#sec-regexpbuiltinexec\">RegExpBuiltinExec</a></emu-xref> can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms in  <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref> are designed so that compiling a pattern may throw a <emu-val>SyntaxError</emu-val> exception; on the other hand, once the pattern is successfully compiled, applying the resulting internal procedure to find a match in a String cannot throw an exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory).</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-data-blocks": {"num": "6.2.7", "title": "#sec-data-blocks Data Blocks", "html": "<emu-clause id=\"sec-data-blocks\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-data-blocks\">#sec-data-blocks</span> Data Blocks</h1>\n      <p>The  <dfn>Data Block</dfn> specification type is used to describe a distinct and mutable sequence of byte-sized (8 bit) numeric values. A Data Block value is created with a fixed number of bytes that each have the initial value 0.</p>\n      <p>For notational convenience within this specification, an array-like syntax can be used to access the individual bytes of a Data Block value. This notation presents a Data Block value as a 0-origined <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>-indexed sequence of bytes. For example, if <var>db</var> is a 5 byte Data Block value then <var>db</var>[2] can be used to access its 3<sup>rd</sup> byte.</p>\n      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a  <dfn>Shared Data Block</dfn>. A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is  <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents. Two data blocks are equal only if the sets of the locations they contain are equal; otherwise, they are not equal and the intersection of the sets of locations they contain is empty.  Finally, Shared Data Blocks can be distinguished from Data Blocks.</p>\n      <p>The semantics of Shared Data Blocks is defined using Shared Data Block events by the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>. <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">Abstract operations</a></emu-xref> below introduce Shared Data Block events and act as the interface between evaluation semantics and the event semantics of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>. The events form a <emu-xref href=\"#sec-candidate-executions\"><a href=\"#sec-candidate-executions\">candidate execution</a></emu-xref>, on which the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> acts as a filter. Please consult the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> for full semantics.</p>\n      <p>Shared Data Block events are modeled by Records, defined in the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>.</p>\n      <p>The following <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> are used in this specification to operate upon Data Block values:</p>\n\n      <div id=\"excluded-sec-createbytedatablock\"><h1><span class=\"secnum\">6.2.7.1</span>#sec-createbytedatablock CreateByteDataBlock ( size )</h1>...</div><div id=\"excluded-sec-createsharedbytedatablock\"><h1><span class=\"secnum\">6.2.7.2</span>#sec-createsharedbytedatablock CreateSharedByteDataBlock ( size )</h1>...</div><div id=\"excluded-sec-copydatablockbytes\"><h1><span class=\"secnum\">6.2.7.3</span>#sec-copydatablockbytes CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )</h1>...</div></emu-clause>\n  "}, "sec-atom": {"num": "21.2.2.8", "title": "#sec-atom Atom", "html": "<emu-clause id=\"sec-atom\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atom\">#sec-atom</span> Atom</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"beff52c4\"><emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Let <var>ch</var> be the character matched by <emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9658e473\"><emu-t>.</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>If <var>DotAll</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>A</var> be the set of all characters.</li></ol></li><li>Otherwise, let <var>A</var> be the set of all characters except <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9ce67ea4\"><emu-t>\\</emu-t><emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> with argument <var>direction</var>.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"66aaa8b9\"><emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt> to obtain a CharSet <var>A</var> and a Boolean <var>invert</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <var>invert</var>, <var>direction</var>) and return its Matcher result.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes prior to or enclosing this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be an internal Continuation closure that takes one State argument <var>y</var> and performs the following steps:<ol><li>Let <var>cap</var> be a copy of <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>ye</var> be <var>y</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> is equal to +1, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xe</var> &#8804; <var>ye</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>xe</var> (inclusive) through <var>ye</var> (exclusive).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is equal to -1.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ye</var> &#8804; <var>xe</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>ye</var> (inclusive) through <var>xe</var> (exclusive).</li></ol></li><li>Set <var>cap</var>[<var>parenIndex</var> + 1] to <var>s</var>.</li><li>Let <var>z</var> be the State (<var>ye</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"d76db7c5\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>:</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.\n        </li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-charactersetmatcher-abstract-operation\"><h1><span class=\"secnum\">21.2.2.8.1</span>#sec-runtime-semantics-charactersetmatcher-abstract-operation Runtime Semantics: CharacterSetMatcher ( A, invert, direction )</h1>...</div><div id=\"excluded-sec-runtime-semantics-canonicalize-ch\"><h1><span class=\"secnum\">21.2.2.8.2</span>#sec-runtime-semantics-canonicalize-ch Runtime Semantics: Canonicalize ( ch )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchproperty-p\"><h1><span class=\"secnum\">21.2.2.8.3</span>#sec-runtime-semantics-unicodematchproperty-p Runtime Semantics: UnicodeMatchProperty ( p )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchpropertyvalue-p-v\"><h1><span class=\"secnum\">21.2.2.8.4</span>#sec-runtime-semantics-unicodematchpropertyvalue-p-v Runtime Semantics: UnicodeMatchPropertyValue ( p, v )</h1>...</div></emu-clause>\n\n      "}, "sec-disjunction": {"num": "21.2.2.3", "title": "#sec-disjunction Disjunction", "html": "<emu-clause id=\"sec-disjunction\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-disjunction\">#sec-disjunction</span> Disjunction</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Disjunction\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"3b74e96e\"><emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Return <var>m</var>.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Disjunction\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"253d8b05\"><emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-t>|</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m1</var>.</li><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m2</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Call <var>m1</var>(<var>x</var>, <var>c</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <var>r</var>.</li><li>Call <var>m2</var>(<var>x</var>, <var>c</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The <code>|</code> regular expression operator separates two alternatives. The pattern first tries to match the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> (followed by the sequel of the regular expression); if it fails, it tries to match the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> (followed by the sequel of the regular expression). If the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. If choices in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> are exhausted, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> is tried instead of the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. Any capturing parentheses inside a portion of the pattern skipped by <code>|</code> produce <emu-val>undefined</emu-val> values instead of Strings. Thus, for example,</p>\n          <pre><code class=\"javascript hljs\">/a|ab/.exec(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the result <emu-val>\"a\"</emu-val> and not <emu-val>\"ab\"</emu-val>. Moreover,</p>\n          <pre><code class=\"javascript hljs\">/((a)|(ab))((c)|(bc))/.exec(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the array</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>]</code></pre>\n          <p>and not</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-literal\">undefined</span>]</code></pre>\n          <p>The order in which the two alternatives are tried is independent of the value of <var>direction</var>.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-pattern-semantics": {"num": "21.2.2", "title": "#sec-pattern-semantics Pattern Semantics", "html": "<emu-clause id=\"sec-pattern-semantics\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</span> Pattern Semantics</h1>\n      <p>A regular expression pattern is converted into an internal procedure using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The internal procedure is used as the value of a RegExp object's [[RegExpMatcher]] internal slot.</p>\n      <p>A <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> is either a BMP pattern or a Unicode pattern depending upon whether or not its associated flags contain a <code>u</code>. A BMP pattern matches against a String interpreted as consisting of a sequence of 16-bit values that are Unicode code points in the range of the Basic Multilingual Plane. A Unicode pattern matches against a String interpreted as consisting of Unicode code points encoded using UTF-16. In the context of describing the behaviour of a BMP pattern &#8220;character&#8221; means a single 16-bit Unicode BMP code point. In the context of describing the behaviour of a Unicode pattern &#8220;character&#8221; means a UTF-16 encoded code point (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"><a href=\"#sec-ecmascript-language-types-string-type\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-types-string-type\">#sec-ecmascript-language-types-string-type</a></emu-xref>). In either context, &#8220;character value&#8221; means the numeric value of the corresponding non-encoded code point.</p>\n      <p>The syntax and semantics of <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> is defined as if the source code for the <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> was a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> values where each <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> corresponds to a Unicode code point. If a BMP pattern contains a non-BMP <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> the entire pattern is encoded using UTF-16 and the individual code units of that encoding are used as the elements of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>For example, consider a pattern expressed in source text as the single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a Unicode pattern, it would be a single element (character) <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the single code point 0x1D11E. However, interpreted as a BMP pattern, it is first UTF-16 encoded to produce a two element <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the code units 0xD834 and 0xDD1E.</p>\n        <p>Patterns are passed to the RegExp <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> as ECMAScript String values in which non-BMP characters are UTF-16 encoded. For example, the single character MUSICAL SYMBOL G CLEF pattern, expressed as a String value, is a String of length 2 whose elements were the code units 0xD834 and 0xDD1E. So no further translation of the string would be necessary to process it as a BMP pattern consisting of two pattern characters. However, to process it as a Unicode pattern <emu-xref aoid=\"UTF16DecodeSurrogatePair\"><a href=\"#sec-utf16decodesurrogatepair\">UTF16DecodeSurrogatePair</a></emu-xref> must be used in producing a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of a single pattern character, the code point U+1D11E.</p>\n        <p>An implementation may not actually perform such translations to or from UTF-16, but the semantics of this specification requires that the result of pattern matching be as if such translations were performed.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-notation\"><h1><span class=\"secnum\">21.2.2.1</span>#sec-notation Notation</h1>...</div><div id=\"excluded-sec-pattern\"><h1><span class=\"secnum\">21.2.2.2</span>#sec-pattern Pattern</h1>...</div><div id=\"excluded-sec-disjunction\"><h1><span class=\"secnum\">21.2.2.3</span>#sec-disjunction Disjunction</h1>...</div><div id=\"excluded-sec-alternative\"><h1><span class=\"secnum\">21.2.2.4</span>#sec-alternative Alternative</h1>...</div><div id=\"excluded-sec-term\"><h1><span class=\"secnum\">21.2.2.5</span>#sec-term Term</h1>...</div><div id=\"excluded-sec-assertion\"><h1><span class=\"secnum\">21.2.2.6</span>#sec-assertion Assertion</h1>...</div><div id=\"excluded-sec-quantifier\"><h1><span class=\"secnum\">21.2.2.7</span>#sec-quantifier Quantifier</h1>...</div><div id=\"excluded-sec-atom\"><h1><span class=\"secnum\">21.2.2.8</span>#sec-atom Atom</h1>...</div><div id=\"excluded-sec-atomescape\"><h1><span class=\"secnum\">21.2.2.9</span>#sec-atomescape AtomEscape</h1>...</div><div id=\"excluded-sec-characterescape\"><h1><span class=\"secnum\">21.2.2.10</span>#sec-characterescape CharacterEscape</h1>...</div><div id=\"excluded-sec-decimalescape\"><h1><span class=\"secnum\">21.2.2.11</span>#sec-decimalescape DecimalEscape</h1>...</div><div id=\"excluded-sec-characterclassescape\"><h1><span class=\"secnum\">21.2.2.12</span>#sec-characterclassescape CharacterClassEscape</h1>...</div><div id=\"excluded-sec-characterclass\"><h1><span class=\"secnum\">21.2.2.13</span>#sec-characterclass CharacterClass</h1>...</div><div id=\"excluded-sec-classranges\"><h1><span class=\"secnum\">21.2.2.14</span>#sec-classranges ClassRanges</h1>...</div><div id=\"excluded-sec-nonemptyclassranges\"><h1><span class=\"secnum\">21.2.2.15</span>#sec-nonemptyclassranges NonemptyClassRanges</h1>...</div><div id=\"excluded-sec-nonemptyclassrangesnodash\"><h1><span class=\"secnum\">21.2.2.16</span>#sec-nonemptyclassrangesnodash NonemptyClassRangesNoDash</h1>...</div><div id=\"excluded-sec-classatom\"><h1><span class=\"secnum\">21.2.2.17</span>#sec-classatom ClassAtom</h1>...</div><div id=\"excluded-sec-classatomnodash\"><h1><span class=\"secnum\">21.2.2.18</span>#sec-classatomnodash ClassAtomNoDash</h1>...</div><div id=\"excluded-sec-classescape\"><h1><span class=\"secnum\">21.2.2.19</span>#sec-classescape ClassEscape</h1>...</div></emu-clause>\n\n    "}, "sec-runtime-semantics-repeatmatcher-abstract-operation": {"num": "21.2.2.5.1", "title": "#sec-runtime-semantics-repeatmatcher-abstract-operation Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )", "html": "<emu-clause id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\" aoid=\"RepeatMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\">#sec-runtime-semantics-repeatmatcher-abstract-operation</span> Runtime Semantics: RepeatMatcher ( <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var> )</h1>\n          <p>The abstract operation RepeatMatcher takes eight parameters, a Matcher <var>m</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>min</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> (or &#8734;) <var>max</var>, a Boolean <var>greedy</var>, a State <var>x</var>, a Continuation <var>c</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>parenIndex</var>, and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>parenCount</var>, and performs the following steps:</p>\n          <emu-alg><ol><li>If <var>max</var> is zero, return <var>c</var>(<var>x</var>).</li><li>Let <var>d</var> be an internal Continuation closure that takes one State argument <var>y</var> and performs the following steps:<ol><li>If <var>min</var> is zero and <var>y</var>'s <var>endIndex</var> is equal to <var>x</var>'s <var>endIndex</var>, return <emu-const>failure</emu-const>.</li><li>If <var>min</var> is zero, let <var>min2</var> be zero; otherwise let <var>min2</var> be <var>min</var> - 1.</li><li>If <var>max</var> is &#8734;, let <var>max2</var> be &#8734;; otherwise let <var>max2</var> be <var>max</var> - 1.</li><li>Call <emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>min2</var>, <var>max2</var>, <var>greedy</var>, <var>y</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>) and return its result.</li></ol></li><li>Let <var>cap</var> be a copy of <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>k</var> that satisfies <var>parenIndex</var> &lt; <var>k</var> and <var>k</var> &#8804; <var>parenIndex</var> + <var>parenCount</var>, set <var>cap</var>[<var>k</var>] to <emu-val>undefined</emu-val>.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>xr</var> be the State (<var>e</var>, <var>cap</var>).</li><li>If <var>min</var> is not zero, return <var>m</var>(<var>xr</var>, <var>d</var>).</li><li>If <var>greedy</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>An <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> followed by a <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> is repeated the number of times specified by the <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>. A <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> can be non-greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as many times as possible while still matching the sequel. The <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated rather than the input character sequence that it matches, so different repetitions of the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> can match different input substrings.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>If the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and the sequel of the regular expression all have choice points, the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. All choices in the last (n<sup>th</sup>) repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>; at which point it may turn out that more or fewer repetitions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and so on.</p>\n            <p>Compare</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}/.exec(<span class=\"hljs-string\">\"abcdefghi\"</span>)</code></pre>\n            <p>which returns <emu-val>\"abcde\"</emu-val> with</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}?<span class=\"hljs-regexp\">/.exec(\"abcdefghi\")</span></code></pre>\n            <p>which returns <emu-val>\"abc\"</emu-val>.</p>\n            <p>Consider also</p>\n            <pre><code class=\"javascript hljs\">/(aa|aabaac|ba|b|c)*<span class=\"hljs-regexp\">/.exec(\"aabaac\")</span></code></pre>\n            <p>which, by the choice point ordering above, returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aaba\"</span>, <span class=\"hljs-string\">\"ba\"</span>]</code></pre>\n            <p>and not any of:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"aabaac\"</span>]\n[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>\n            <pre><code class=\"javascript hljs\"><span class=\"hljs-string\">\"aaaaaaaaaa,aaaaaaaaaaaaaaa\"</span>.replace(<span class=\"hljs-regexp\">/^(a+)\\1*,\\1+$/</span>, <span class=\"hljs-string\">\"$1\"</span>)</code></pre>\n            <p>which returns the gcd in unary notation <emu-val>\"aaaaa\"</emu-val>.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>Step 4 of the RepeatMatcher clears <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>'s captures each time <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is repeated. We can see its behaviour in the regular expression</p>\n            <pre><code class=\"javascript hljs\">/(z)((a+)?(b+)?(c))*<span class=\"hljs-regexp\">/.exec(\"zaacbbbcac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>and not</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"bbb\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>because each iteration of the outermost <code>*</code> clears all captured Strings contained in the quantified <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n            <p>Step 2.a of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>\n            <pre><code class=\"javascript hljs\">/(a*)*<span class=\"hljs-regexp\">/.exec(\"b\")</span></code></pre>\n            <p>or the slightly more complicated:</p>\n            <pre><code class=\"javascript hljs\">/(a*)b\\<span class=\"hljs-number\">1</span>+<span class=\"hljs-regexp\">/.exec(\"baaaac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"\"</span>]</code></pre>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-term": {"num": "21.2.2.5", "title": "#sec-term Term", "html": "<emu-clause id=\"sec-term\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-term\">#sec-term</span> Term</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e03dc251\"><emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt>.\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The resulting Matcher is independent of <var>direction</var>.</p>\n        </div></emu-note>\n        <p>The production  <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"41dded41\"><emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var>.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"44aed0a4\"><emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Evaluate <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> to obtain the three results: an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>min</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> (or &#8734;) <var>max</var>, and Boolean <var>greedy</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>max</var> is finite, then <var>max</var> is not less than <var>min</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes prior to or enclosing this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>.</li><li>Let <var>parenCount</var> be the number of left-capturing parentheses in <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes enclosed by <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Call <emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-repeatmatcher-abstract-operation\"><h1><span class=\"secnum\">21.2.2.5.1</span>#sec-runtime-semantics-repeatmatcher-abstract-operation Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )</h1>...</div></emu-clause>\n\n      "}, "sec-notation": {"num": "21.2.2.1", "title": "#sec-notation Notation", "html": "<emu-clause id=\"sec-notation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-notation\">#sec-notation</span> Notation</h1>\n        <p>The descriptions below use the following variables:</p>\n        <ul>\n          <li>\n            <var>Input</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of all of the characters, in order, of the String being matched by the regular expression pattern. Each character is either a code unit or a code point, depending upon the kind of pattern involved. The notation <var>Input</var>[<var>n</var>] means the <var>n</var><sup>th</sup> character of <var>Input</var>, where <var>n</var> can range between 0 (inclusive) and <var>InputLength</var> (exclusive).\n          \n          </li>\n          <li>\n            <var>InputLength</var> is the number of characters in <var>Input</var>.\n          \n          </li>\n          <li>\n            <var>NcapturingParens</var> is the total number of left-capturing parentheses (i.e. the total number of  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes) in the pattern. A left-capturing parenthesis is any <code>(</code> pattern character that is matched by the <code>(</code> terminal of the  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> production.\n          \n          </li>\n          <li>\n            <var>DotAll</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"s\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            <var>IgnoreCase</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"i\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            <var>Multiline</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"m\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            <var>Unicode</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"u\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n        </ul>\n        <p>Furthermore, the descriptions below use the following internal data structures:</p>\n        <ul>\n          <li>\n            A  <em>CharSet</em> is a mathematical set of characters, either code units or code points depending up the state of the <var>Unicode</var> flag. &#8220;All characters&#8221; means either all code unit values or all code point values also depending upon the state of <var>Unicode</var>.\n          \n          </li>\n          <li>\n            A  <em>State</em> is an ordered pair (<var>endIndex</var>, <var>captures</var>) where <var>endIndex</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> and <var>captures</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> values. States are used to represent partial match states in the regular expression matching algorithms. The <var>endIndex</var> is one plus the index of the last input character matched so far by the pattern, while <var>captures</var> holds the results of capturing parentheses. The <var>n</var><sup>th</sup> element of <var>captures</var> is either a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that represents the value obtained by the <var>n</var><sup>th</sup> set of capturing parentheses or <emu-val>undefined</emu-val> if the <var>n</var><sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many States may be in use at any time during the matching process.\n          \n          </li>\n          <li>\n            A  <em>MatchResult</em> is either a State or the special token <emu-const>failure</emu-const> that indicates that the match failed.\n          \n          </li>\n          <li>\n            A  <em>Continuation</em> procedure is an internal closure (i.e. an internal procedure with some arguments already bound to values) that takes one State argument and returns a MatchResult result. If an internal closure references variables which are bound in the function that creates the closure, the closure uses the values that these variables had at the time the closure was created. The Continuation attempts to match the remaining portion (specified by the closure's already-bound arguments) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. If the match succeeds, the Continuation returns the final State that it reached; if the match fails, the Continuation returns <emu-const>failure</emu-const>.\n          \n          </li>\n          <li>\n            A  <em>Matcher</em> procedure is an internal closure that takes two arguments&#8212;a State and a Continuation&#8212;and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure's already-bound arguments) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. The Continuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State, the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as well. If it can, the Matcher returns the State returned by Continuation; if not, the Matcher may try different choices at its choice points, repeatedly calling Continuation until it either succeeds or all possibilities have been exhausted.\n          \n          </li>\n        </ul>\n      </emu-clause>\n\n      "}, "sec-escaperegexppattern": {"num": "21.2.3.2.4", "title": "#sec-escaperegexppattern Runtime Semantics: EscapeRegExpPattern ( P, F )", "html": "<emu-clause id=\"sec-escaperegexppattern\" aoid=\"EscapeRegExpPattern\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-escaperegexppattern\">#sec-escaperegexppattern</span> Runtime Semantics: EscapeRegExpPattern ( <var>P</var>, <var>F</var> )</h1>\n          <p>When the abstract operation EscapeRegExpPattern with arguments <var>P</var> and <var>F</var> is called, the following occurs:</p>\n          <emu-alg><ol><li>Let <var>S</var> be a String in the form of a <emu-nt params=\"~U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U]</emu-params></emu-mods></emu-nt> (<emu-nt params=\"+U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[+U]</emu-params></emu-mods></emu-nt> if <var>F</var> contains <emu-val>\"u\"</emu-val>) equivalent to <var>P</var> interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"><a href=\"#sec-ecmascript-language-types-string-type\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-types-string-type\">#sec-ecmascript-language-types-string-type</a></emu-xref>), in which certain code points are escaped as described below. <var>S</var> may or may not be identical to <var>P</var>; however, the internal procedure that would result from evaluating <var>S</var> as a <emu-nt params=\"~U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U]</emu-params></emu-mods></emu-nt> (<emu-nt params=\"+U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[+U]</emu-params></emu-mods></emu-nt> if <var>F</var> contains <emu-val>\"u\"</emu-val>) must behave identically to the internal procedure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for <var>P</var> and <var>F</var> must produce identical results.</li><li>The code points <code>/</code> or any <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt> occurring in the pattern shall be escaped in <var>S</var> as necessary to ensure that the <emu-xref href=\"#sec-ecmascript-language-types-string-type\"><a href=\"#sec-ecmascript-language-types-string-type\">string-concatenation</a></emu-xref> of <emu-val>\"/\"</emu-val>, <var>S</var>, <emu-val>\"/\"</emu-val>, and <var>F</var> can be parsed (in an appropriate lexical context) as a <emu-nt><a href=\"#prod-RegularExpressionLiteral\">RegularExpressionLiteral</a></emu-nt> that behaves identically to the constructed regular expression. For example, if <var>P</var> is <emu-val>\"/\"</emu-val>, then <var>S</var> could be <emu-val>\"\\/\"</emu-val> or <emu-val>\"\\u002F\"</emu-val>, among other possibilities, but not <emu-val>\"/\"</emu-val>, because <code>///</code> followed by <var>F</var> would be parsed as a <emu-nt><a href=\"#prod-SingleLineComment\">SingleLineComment</a></emu-nt> rather than a <emu-nt><a href=\"#prod-RegularExpressionLiteral\">RegularExpressionLiteral</a></emu-nt>. If <var>P</var> is the empty String, this specification can be met by letting <var>S</var> be <emu-val>\"(?:)\"</emu-val>.</li><li>Return <var>S</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-regexpinitialize": {"num": "21.2.3.2.2", "title": "#sec-regexpinitialize Runtime Semantics: RegExpInitialize ( obj, pattern, flags )", "html": "<emu-clause id=\"sec-regexpinitialize\" aoid=\"RegExpInitialize\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-regexpinitialize\">#sec-regexpinitialize</span> Runtime Semantics: RegExpInitialize ( <var>obj</var>, <var>pattern</var>, <var>flags</var> )</h1>\n          <p>When the abstract operation RegExpInitialize with arguments <var>obj</var>, <var>pattern</var>, and <var>flags</var> is called, the following steps are taken:</p>\n          <emu-alg><ol><li>If <var>pattern</var> is <emu-val>undefined</emu-val>, let <var>P</var> be the empty String.</li><li>Else, let <var>P</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>pattern</var>).</li><li>If <var>flags</var> is <emu-val>undefined</emu-val>, let <var>F</var> be the empty String.</li><li>Else, let <var>F</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>flags</var>).</li><li>If <var>F</var> contains any code unit other than <emu-val>\"g\"</emu-val>, <emu-val>\"i\"</emu-val>, <emu-val>\"m\"</emu-val>, <emu-val>\"s\"</emu-val>, <emu-val>\"u\"</emu-val>, or <emu-val>\"y\"</emu-val> or if it contains the same code unit more than once, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>F</var> contains <emu-val>\"u\"</emu-val>, let <var>BMP</var> be <emu-val>false</emu-val>; else let <var>BMP</var> be <emu-val>true</emu-val>.</li><li>If <var>BMP</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>pText</var> be the sequence of code points resulting from interpreting each of the 16-bit elements of <var>P</var> as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.</li><li>Parse <var>pText</var> using the grammars in <emu-xref href=\"#sec-patterns\"><a href=\"#sec-patterns\" class=\"excluded-xref\" excluded-id=\"sec-patterns\">#sec-patterns</a></emu-xref>. The <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> for the parse is <emu-nt params=\"~U, ~N\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U, ~N]</emu-params></emu-mods></emu-nt>. If the result of parsing contains a <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>, reparse with the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> <emu-nt params=\"~U, +N\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U, +N]</emu-params></emu-mods></emu-nt> and use this result instead. Throw a <emu-val>SyntaxError</emu-val> exception if <var>pText</var> did not conform to the grammar, if any elements of <var>pText</var> were not matched by the parse, or if any Early Error conditions exist.</li><li>Let <var>patternCharacters</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the code unit elements of <var>P</var>.</li></ol></li><li>Else,<ol><li>Let <var>pText</var> be !&#160;<emu-xref aoid=\"UTF16DecodeString\"><a href=\"#sec-utf16decodestring\">UTF16DecodeString</a></emu-xref>(<var>P</var>).</li><li>Parse <var>pText</var> using the grammars in <emu-xref href=\"#sec-patterns\"><a href=\"#sec-patterns\" class=\"excluded-xref\" excluded-id=\"sec-patterns\">#sec-patterns</a></emu-xref>. The <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> for the parse is <emu-nt params=\"+U, +N\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[+U, +N]</emu-params></emu-mods></emu-nt>. Throw a <emu-val>SyntaxError</emu-val> exception if <var>pText</var> did not conform to the grammar, if any elements of <var>pText</var> were not matched by the parse, or if any Early Error conditions exist.</li><li>Let <var>patternCharacters</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the code points of <var>pText</var>.</li></ol></li><li>Set <var>obj</var>.[[OriginalSource]] to <var>P</var>.</li><li>Set <var>obj</var>.[[OriginalFlags]] to <var>F</var>.</li><li>Set <var>obj</var>.[[RegExpMatcher]] to the internal procedure that evaluates the above parse by applying the semantics provided in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref> using <var>patternCharacters</var> as the pattern's <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> values and <var>F</var> as the flag parameters.</li><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>obj</var>, <emu-val>\"lastIndex\"</emu-val>, 0, <emu-val>true</emu-val>).</li><li>Return <var>obj</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-assertion": {"num": "21.2.2.6", "title": "#sec-assertion Assertion", "html": "<emu-clause id=\"sec-assertion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-assertion\">#sec-assertion</span> Assertion</h1>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e5878811\"><emu-t>^</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is zero, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var> - 1] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Even when the <code>y</code> flag is used with a pattern, <code>^</code> always matches only at the beginning of <var>Input</var>, or (if <var>Multiline</var> is <emu-val>true</emu-val>) at the beginning of a line.</p>\n        </div></emu-note>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1262cc92\"><emu-t>$</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is equal to <var>InputLength</var>, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var>] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1e228da5\"><emu-t>\\</emu-t><emu-t>b</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"a5dc97fa\"><emu-t>\\</emu-t><emu-t>B</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>true</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"cfb94f94\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"ba98f6e2\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"8db9fbbe\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1b07b2c0\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that always returns its State argument as a successful MatchResult.</li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-wordcharacters-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.1</span>#sec-runtime-semantics-wordcharacters-abstract-operation Runtime Semantics: WordCharacters ( )</h1>...</div><div id=\"excluded-sec-runtime-semantics-iswordchar-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.2</span>#sec-runtime-semantics-iswordchar-abstract-operation Runtime Semantics: IsWordChar ( e )</h1>...</div></emu-clause>\n      "}, "sec-alternative": {"num": "21.2.2.4", "title": "#sec-alternative Alternative", "html": "<emu-clause id=\"sec-alternative\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-alternative\">#sec-alternative</span> Alternative</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"37b9c04c\"><emu-gann>[empty]</emu-gann></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return a Matcher that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and returns the result of calling <var>c</var>(<var>x</var>).\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"bdc4c1a6\"><emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-nt><a href=\"#prod-Term\">Term</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m1</var>.</li><li>Evaluate <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m2</var>.</li><li>If <var>direction</var> is equal to +1, then<ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that takes a State argument <var>y</var> and returns the result of calling <var>m2</var>(<var>y</var>, <var>c</var>).</li><li>Call <var>m1</var>(<var>x</var>, <var>d</var>) and return its result.</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is equal to -1.</li><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>d</var> be a Continuation that takes a State argument <var>y</var> and returns the result of calling <var>m1</var>(<var>y</var>, <var>c</var>).</li><li>Call <var>m2</var>(<var>x</var>, <var>d</var>) and return its result.\n        </li></ol></li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Consecutive <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>s try to simultaneously match consecutive portions of <var>Input</var>. When <var>direction</var> is equal to +1, if the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and all choices in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. When <var>direction</var> is equal to -1, the evaluation order of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> and <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are reversed.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-runtime-semantics-canonicalize-ch": {"num": "21.2.2.8.2", "title": "#sec-runtime-semantics-canonicalize-ch Runtime Semantics: Canonicalize ( ch )", "html": "<emu-clause id=\"sec-runtime-semantics-canonicalize-ch\" aoid=\"Canonicalize\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-canonicalize-ch\">#sec-runtime-semantics-canonicalize-ch</span> Runtime Semantics: Canonicalize ( <var>ch</var> )</h1>\n          <p>The abstract operation Canonicalize takes a character parameter <var>ch</var> and performs the following steps:</p>\n          <emu-alg><ol><li>If <var>IgnoreCase</var> is <emu-val>false</emu-val>, return <var>ch</var>.</li><li>If <var>Unicode</var> is <emu-val>true</emu-val>, then<ol><li>If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for <var>ch</var>, return the result of applying that mapping to <var>ch</var>.</li><li>Return <var>ch</var>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ch</var> is a UTF-16 code unit.</li><li>Let <var>s</var> be the String value consisting of the single code unit <var>ch</var>.</li><li>Let <var>u</var> be the same result produced as if by performing the algorithm for <code>String.prototype.toUpperCase</code> using <var>s</var> as the <emu-val>this</emu-val> value.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>u</var>) is String.</li><li>If <var>u</var> does not consist of a single code unit, return <var>ch</var>.</li><li>Let <var>cu</var> be <var>u</var>'s single code unit element.</li><li>If the numeric value of <var>ch</var> &#8805; 128 and the numeric value of <var>cu</var> &lt; 128, return <var>ch</var>.</li><li>Return <var>cu</var>.\n          </li></ol></li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>Parentheses of the form <code>(</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> serve both to group the components of the <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> pattern together and to save the result of the match. The result can be used either in a backreference (<code>\\</code> followed by a nonzero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching internal procedure. To inhibit the capturing behaviour of parentheses, use the form <code>(?:</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> instead.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>The form <code>(?=</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> must match at the current position, but the current position is not advanced before matching the sequel. If <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a <code>(?=</code> form (this unusual behaviour is inherited from Perl). This only matters when the <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.</p>\n            <p>For example,</p>\n            <pre><code class=\"javascript hljs\">/(?=(a+))/.exec(<span class=\"hljs-string\">\"baaabac\"</span>)</code></pre>\n            <p>matches the empty String immediately after the first <code>b</code> and therefore returns the array:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-string\">\"aaa\"</span>]</code></pre>\n            <p>To illustrate the lack of backtracking into the lookahead, consider:</p>\n            <pre><code class=\"javascript hljs\">/(?=(a+))a*b\\<span class=\"hljs-number\">1</span>/.exec(<span class=\"hljs-string\">\"baaabac\"</span>)</code></pre>\n            <p>This expression returns</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aba\"</span>, <span class=\"hljs-string\">\"a\"</span>]</code></pre>\n            <p>and not:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aaaba\"</span>, <span class=\"hljs-string\">\"a\"</span>]</code></pre>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>The form <code>(?!</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> must fail to match at the current position. The current position is not advanced before matching the sequel. <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> can contain capturing parentheses, but backreferences to them only make sense from within <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return <emu-val>undefined</emu-val> because the negative lookahead must fail for the pattern to succeed. For example,</p>\n            <pre><code class=\"javascript hljs\">/(.*?)a(?!(a+)b\\<span class=\"hljs-number\">2</span>c)\\<span class=\"hljs-number\">2</span>(.*)/.exec(<span class=\"hljs-string\">\"baaabaac\"</span>)</code></pre>\n            <p>looks for an <code>a</code> not immediately followed by some positive number n of <code>a</code>'s, a <code>b</code>, another n <code>a</code>'s (specified by the first <code>\\2</code>) and a <code>c</code>. The second <code>\\2</code> is outside the negative lookahead, so it matches against <emu-val>undefined</emu-val> and therefore always succeeds. The whole expression returns the array:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"baaabaac\"</span>, <span class=\"hljs-string\">\"ba\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"abaac\"</span>]</code></pre>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n            <p>In case-insignificant matches when <var>Unicode</var> is <emu-val>true</emu-val>, all characters are implicitly case-folded using the simple mapping provided by the Unicode standard immediately before they are compared. The simple mapping always maps to a single code point, so it does not map, for example, <code>&#223;</code> (U+00DF) to <code>SS</code>. It may however map a code point outside the Basic Latin range to a character within, for example, <code>&#383;</code> (U+017F) to <code>s</code>. Such characters are not mapped if <var>Unicode</var> is <emu-val>false</emu-val>. This prevents Unicode code points such as U+017F and U+212A from matching regular expressions such as <code>/[a-z]/i</code>, but they will match <code>/[a-z]/ui</code>.</p>\n          </div></emu-note>\n        </emu-clause>\n        "}, "sec-runtime-semantics-charactersetmatcher-abstract-operation": {"num": "21.2.2.8.1", "title": "#sec-runtime-semantics-charactersetmatcher-abstract-operation Runtime Semantics: CharacterSetMatcher ( A, invert, direction )", "html": "<emu-clause id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\" aoid=\"CharacterSetMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\">#sec-runtime-semantics-charactersetmatcher-abstract-operation</span> Runtime Semantics: CharacterSetMatcher ( <var>A</var>, <var>invert</var>, <var>direction</var> )</h1>\n          <p>The abstract operation CharacterSetMatcher takes three arguments, a CharSet <var>A</var>, a Boolean flag <var>invert</var>, and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>direction</var>, and performs the following steps:</p>\n          <emu-alg><ol><li>Return an internal Matcher closure that takes two arguments, a State <var>x</var> and a Continuation <var>c</var>, and performs the following steps:<ol><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>index</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>Let <var>ch</var> be the character <var>Input</var>[<var>index</var>].</li><li>Let <var>cc</var> be <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>ch</var>).</li><li>If <var>invert</var> is <emu-val>false</emu-val>, then<ol><li>If there does not exist a member <var>a</var> of set <var>A</var> such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>a</var>) is <var>cc</var>, return <emu-const>failure</emu-const>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>invert</var> is <emu-val>true</emu-val>.</li><li>If there exists a member <var>a</var> of set <var>A</var> such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>a</var>) is <var>cc</var>, return <emu-const>failure</emu-const>.</li></ol></li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>y</var>) and return its result.\n          </li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-properties-of-regexp-instances": {"num": "21.2.6", "title": "#sec-properties-of-regexp-instances Properties of RegExp Instances", "html": "<emu-clause id=\"sec-properties-of-regexp-instances\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-properties-of-regexp-instances\">#sec-properties-of-regexp-instances</span> Properties of RegExp Instances</h1>\n      <p>RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp instances have internal slots [[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value of the [[RegExpMatcher]] internal slot is an implementation-dependent representation of the <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> of the RegExp object.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>Prior to ECMAScript 2015, <code>RegExp</code> instances were specified as having the own data properties <emu-val>\"source\"</emu-val>, <emu-val>\"global\"</emu-val>, <emu-val>\"ignoreCase\"</emu-val>, and <emu-val>\"multiline\"</emu-val>. Those properties are now specified as accessor properties of <code>RegExp.prototype</code>.</p>\n      </div></emu-note>\n      <p>RegExp instances also have the following property:</p>\n\n      <div id=\"excluded-sec-lastindex\"><h1><span class=\"secnum\">21.2.6.1</span>#sec-lastindex lastIndex</h1>...</div></emu-clause>\n\n    "}}, "figData": {}}, "to": {"secList": ["sec-backreference-matcher", "sec-ecmascript-specification-types", "sec-pattern", "sec-data-blocks", "sec-atom", "sec-disjunction", "sec-pattern-semantics", "sec-runtime-semantics-repeatmatcher-abstract-operation", "sec-term", "sec-notation", "sec-escaperegexppattern", "sec-regexpinitialize", "sec-assertion", "sec-alternative", "sec-runtime-semantics-canonicalize-ch", "sec-runtime-semantics-charactersetmatcher-abstract-operation", "sec-properties-of-regexp-instances"], "secData": {"sec-backreference-matcher": {"num": "21.2.2.9.1", "title": "#sec-backreference-matcher Runtime Semantics: BackreferenceMatcher ( n, direction )", "html": "<emu-clause id=\"sec-backreference-matcher\" aoid=\"BackreferenceMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-backreference-matcher\">#sec-backreference-matcher</span> Runtime Semantics: BackreferenceMatcher ( <var>n</var>, <var>direction</var> )</h1>\n          <p>The abstract operation BackreferenceMatcher takes two arguments, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>n</var> and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>direction</var>, and performs the following steps:</p>\n          <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>n</var> and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>s</var> be <var>cap</var>[<var>n</var>].</li><li>If <var>s</var> is <emu-val>undefined</emu-val>, return <var>c</var>(<var>x</var>).</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>len</var> be the number of elements in <var>s</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var> &#215; <var>len</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>g</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>If there exists an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>i</var> between 0 (inclusive) and <var>len</var> (exclusive) such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>s</var>[<var>i</var>]) is not the same character value as <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>Input</var>[<var>g</var> + <var>i</var>]), return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>y</var>) and return its result.\n          </li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-ecmascript-specification-types": {"num": "6.2", "title": "#sec-ecmascript-specification-types ECMAScript Specification Types", "html": "<emu-clause id=\"sec-ecmascript-specification-types\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-ecmascript-specification-types\">#sec-ecmascript-specification-types</span> ECMAScript Specification Types</h1>\n    <p>A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types include <emu-xref href=\"#sec-reference-specification-type\"><a href=\"#sec-reference-specification-type\">Reference</a></emu-xref>, <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>, <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>, <emu-xref href=\"#sec-property-descriptor-specification-type\"><a href=\"#sec-property-descriptor-specification-type\">Property Descriptor</a></emu-xref>, <emu-xref href=\"#sec-lexical-environments\"><a href=\"#sec-lexical-environments\">Lexical Environment</a></emu-xref>, <emu-xref href=\"#sec-environment-records\"><a href=\"#sec-environment-records\">Environment Record</a></emu-xref>, Abstract Closure, and <emu-xref href=\"#sec-data-blocks\"><a href=\"#sec-data-blocks\">Data Block</a></emu-xref>. Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.</p>\n\n    <div id=\"excluded-sec-list-and-record-specification-type\"><h1><span class=\"secnum\">6.2.1</span>#sec-list-and-record-specification-type The List and Record Specification Types</h1>...</div><div id=\"excluded-sec-set-and-relation-specification-type\"><h1><span class=\"secnum\">6.2.2</span>#sec-set-and-relation-specification-type The Set and Relation Specification Types</h1>...</div><div id=\"excluded-sec-completion-record-specification-type\"><h1><span class=\"secnum\">6.2.3</span>#sec-completion-record-specification-type The Completion Record Specification Type</h1>...</div><div id=\"excluded-sec-reference-specification-type\"><h1><span class=\"secnum\">6.2.4</span>#sec-reference-specification-type The Reference Specification Type</h1>...</div><div id=\"excluded-sec-property-descriptor-specification-type\"><h1><span class=\"secnum\">6.2.5</span>#sec-property-descriptor-specification-type The Property Descriptor Specification Type</h1>...</div><div id=\"excluded-sec-lexical-environment-and-environment-record-specification-types\"><h1><span class=\"secnum\">6.2.6</span>#sec-lexical-environment-and-environment-record-specification-types The Lexical Environment and Environment Record Specification Types</h1>...</div><div id=\"excluded-sec-abstract-closure\"><h1><span class=\"secnum\">6.2.7</span>#sec-abstract-closure The Abstract Closure Specification Type</h1>...</div><div id=\"excluded-sec-data-blocks\"><h1><span class=\"secnum\">6.2.8</span>#sec-data-blocks Data Blocks</h1>...</div></emu-clause>\n"}, "sec-pattern": {"num": "21.2.2.2", "title": "#sec-pattern Pattern", "html": "<emu-clause id=\"sec-pattern\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-pattern\">#sec-pattern</span> Pattern</h1>\n        <p>The production  <emu-grammar><emu-production name=\"Pattern\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"79a5bbd0\"><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return a new <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> with parameters (<var>str</var>, <var>index</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>str</var> is a String.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: !&#160;<emu-xref aoid=\"IsNonNegativeInteger\"><a href=\"#sec-isnonnegativeinteger\">IsNonNegativeInteger</a></emu-xref>(<var>index</var>) is <emu-val>true</emu-val> and <var>index</var> &#8804; the length of <var>str</var>.</li><li>If <var>Unicode</var> is <emu-val>true</emu-val>, let <var>Input</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the sequence of code points of !&#160;<emu-xref aoid=\"UTF16DecodeString\"><a href=\"#sec-utf16decodestring\">UTF16DecodeString</a></emu-xref>(<var>str</var>). Otherwise, let <var>Input</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the sequence of code units that are the elements of <var>str</var>. <var>Input</var> will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>. Each element of <var>Input</var> is considered to be a character.</li><li>Let <var>InputLength</var> be the number of characters contained in <var>Input</var>. This variable will be used throughout the algorithms in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref>.</li><li>Let <var>listIndex</var> be the index into <var>Input</var> of the character that was obtained from element <var>index</var> of <var>str</var>.</li><li>Let <var>c</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Let <var>cap</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> <emu-val>undefined</emu-val> values, indexed 1 through <var>NcapturingParens</var>.</li><li>Let <var>x</var> be the State (<var>listIndex</var>, <var>cap</var>).</li><li>Call <var>m</var>(<var>x</var>, <var>c</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>A Pattern evaluates (&#8220;compiles&#8221;) to an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> value. <emu-xref aoid=\"RegExpBuiltinExec\"><a href=\"#sec-regexpbuiltinexec\">RegExpBuiltinExec</a></emu-xref> can then apply this procedure to a String and an offset within the String to determine whether the pattern would match starting at exactly that offset within the String, and, if it does match, what the values of the capturing parentheses would be. The algorithms in  <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref> are designed so that compiling a pattern may throw a <emu-val>SyntaxError</emu-val> exception; on the other hand, once the pattern is successfully compiled, applying the resulting <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> to find a match in a String cannot throw an exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory).</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-data-blocks": {"num": "6.2.8", "title": "#sec-data-blocks Data Blocks", "html": "<emu-clause id=\"sec-data-blocks\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-data-blocks\">#sec-data-blocks</span> Data Blocks</h1>\n      <p>The  <dfn>Data Block</dfn> specification type is used to describe a distinct and mutable sequence of byte-sized (8 bit) numeric values. A Data Block value is created with a fixed number of bytes that each have the initial value 0.</p>\n      <p>For notational convenience within this specification, an array-like syntax can be used to access the individual bytes of a Data Block value. This notation presents a Data Block value as a 0-origined <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>-indexed sequence of bytes. For example, if <var>db</var> is a 5 byte Data Block value then <var>db</var>[2] can be used to access its 3<sup>rd</sup> byte.</p>\n      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a  <dfn>Shared Data Block</dfn>. A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is  <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents. Two data blocks are equal only if the sets of the locations they contain are equal; otherwise, they are not equal and the intersection of the sets of locations they contain is empty.  Finally, Shared Data Blocks can be distinguished from Data Blocks.</p>\n      <p>The semantics of Shared Data Blocks is defined using Shared Data Block events by the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>. <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">Abstract operations</a></emu-xref> below introduce Shared Data Block events and act as the interface between evaluation semantics and the event semantics of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>. The events form a <emu-xref href=\"#sec-candidate-executions\"><a href=\"#sec-candidate-executions\">candidate execution</a></emu-xref>, on which the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> acts as a filter. Please consult the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> for full semantics.</p>\n      <p>Shared Data Block events are modeled by Records, defined in the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref>.</p>\n      <p>The following <emu-xref href=\"#sec-algorithm-conventions-abstract-operations\"><a href=\"#sec-algorithm-conventions-abstract-operations\">abstract operations</a></emu-xref> are used in this specification to operate upon Data Block values:</p>\n\n      <div id=\"excluded-sec-createbytedatablock\"><h1><span class=\"secnum\">6.2.8.1</span>#sec-createbytedatablock CreateByteDataBlock ( size )</h1>...</div><div id=\"excluded-sec-createsharedbytedatablock\"><h1><span class=\"secnum\">6.2.8.2</span>#sec-createsharedbytedatablock CreateSharedByteDataBlock ( size )</h1>...</div><div id=\"excluded-sec-copydatablockbytes\"><h1><span class=\"secnum\">6.2.8.3</span>#sec-copydatablockbytes CopyDataBlockBytes ( toBlock, toIndex, fromBlock, fromIndex, count )</h1>...</div></emu-clause>\n  "}, "sec-atom": {"num": "21.2.2.8", "title": "#sec-atom Atom", "html": "<emu-clause id=\"sec-atom\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-atom\">#sec-atom</span> Atom</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"beff52c4\"><emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Let <var>ch</var> be the character matched by <emu-nt><a href=\"#prod-PatternCharacter\">PatternCharacter</a></emu-nt>.</li><li>Let <var>A</var> be a one-element CharSet containing the character <var>ch</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9658e473\"><emu-t>.</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>If <var>DotAll</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>A</var> be the set of all characters.</li></ol></li><li>Otherwise, let <var>A</var> be the set of all characters except <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <emu-val>false</emu-val>, <var>direction</var>) and return its Matcher result.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"9ce67ea4\"><emu-t>\\</emu-t><emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-AtomEscape\">AtomEscape</a></emu-nt> with argument <var>direction</var>.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"66aaa8b9\"><emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-CharacterClass\">CharacterClass</a></emu-nt> to obtain a CharSet <var>A</var> and a Boolean <var>invert</var>.</li><li>Call <emu-xref aoid=\"CharacterSetMatcher\"><a href=\"#sec-runtime-semantics-charactersetmatcher-abstract-operation\">CharacterSetMatcher</a></emu-xref>(<var>A</var>, <var>invert</var>, <var>direction</var>) and return its Matcher result.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes prior to or enclosing this <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>direction</var>, <var>m</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>x</var>, <var>c</var>, <var>direction</var>, and <var>parenIndex</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Let <var>cap</var> be a copy of <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>ye</var> be <var>y</var>'s <var>endIndex</var>.</li><li>If <var>direction</var> is equal to +1, then<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>xe</var> &#8804; <var>ye</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>xe</var> (inclusive) through <var>ye</var> (exclusive).</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is equal to -1.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ye</var> &#8804; <var>xe</var>.</li><li>Let <var>s</var> be a new <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the characters of <var>Input</var> at indices <var>ye</var> (inclusive) through <var>xe</var> (exclusive).</li></ol></li><li>Set <var>cap</var>[<var>parenIndex</var> + 1] to <var>s</var>.</li><li>Let <var>z</var> be the State (<var>ye</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"d76db7c5\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>:</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var>.\n        </li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-charactersetmatcher-abstract-operation\"><h1><span class=\"secnum\">21.2.2.8.1</span>#sec-runtime-semantics-charactersetmatcher-abstract-operation Runtime Semantics: CharacterSetMatcher ( A, invert, direction )</h1>...</div><div id=\"excluded-sec-runtime-semantics-canonicalize-ch\"><h1><span class=\"secnum\">21.2.2.8.2</span>#sec-runtime-semantics-canonicalize-ch Runtime Semantics: Canonicalize ( ch )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchproperty-p\"><h1><span class=\"secnum\">21.2.2.8.3</span>#sec-runtime-semantics-unicodematchproperty-p Runtime Semantics: UnicodeMatchProperty ( p )</h1>...</div><div id=\"excluded-sec-runtime-semantics-unicodematchpropertyvalue-p-v\"><h1><span class=\"secnum\">21.2.2.8.4</span>#sec-runtime-semantics-unicodematchpropertyvalue-p-v Runtime Semantics: UnicodeMatchPropertyValue ( p, v )</h1>...</div></emu-clause>\n\n      "}, "sec-disjunction": {"num": "21.2.2.3", "title": "#sec-disjunction Disjunction", "html": "<emu-clause id=\"sec-disjunction\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-disjunction\">#sec-disjunction</span> Disjunction</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Disjunction\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"3b74e96e\"><emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Return <var>m</var>.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Disjunction\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"253d8b05\"><emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-t>|</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m1</var>.</li><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m2</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Call <var>m1</var>(<var>x</var>, <var>c</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <var>r</var>.</li><li>Call <var>m2</var>(<var>x</var>, <var>c</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The <code>|</code> regular expression operator separates two alternatives. The pattern first tries to match the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> (followed by the sequel of the regular expression); if it fails, it tries to match the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> (followed by the sequel of the regular expression). If the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt>, and the sequel all have choice points, all choices in the sequel are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. If choices in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> are exhausted, the right <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> is tried instead of the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. Any capturing parentheses inside a portion of the pattern skipped by <code>|</code> produce <emu-val>undefined</emu-val> values instead of Strings. Thus, for example,</p>\n          <pre><code class=\"javascript hljs\">/a|ab/.exec(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the result <emu-val>\"a\"</emu-val> and not <emu-val>\"ab\"</emu-val>. Moreover,</p>\n          <pre><code class=\"javascript hljs\">/((a)|(ab))((c)|(bc))/.exec(<span class=\"hljs-string\">\"abc\"</span>)</code></pre>\n          <p>returns the array</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"bc\"</span>]</code></pre>\n          <p>and not</p>\n          <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"abc\"</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"ab\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-literal\">undefined</span>]</code></pre>\n          <p>The order in which the two alternatives are tried is independent of the value of <var>direction</var>.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-pattern-semantics": {"num": "21.2.2", "title": "#sec-pattern-semantics Pattern Semantics", "html": "<emu-clause id=\"sec-pattern-semantics\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</span> Pattern Semantics</h1>\n      <p>A regular expression pattern is converted into an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> using the process described below. An implementation is encouraged to use more efficient algorithms than the ones listed below, as long as the results are the same. The <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> is used as the value of a RegExp object's [[RegExpMatcher]] internal slot.</p>\n      <p>A <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> is either a BMP pattern or a Unicode pattern depending upon whether or not its associated flags contain a <code>u</code>. A BMP pattern matches against a String interpreted as consisting of a sequence of 16-bit values that are Unicode code points in the range of the Basic Multilingual Plane. A Unicode pattern matches against a String interpreted as consisting of Unicode code points encoded using UTF-16. In the context of describing the behaviour of a BMP pattern &#8220;character&#8221; means a single 16-bit Unicode BMP code point. In the context of describing the behaviour of a Unicode pattern &#8220;character&#8221; means a UTF-16 encoded code point (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"><a href=\"#sec-ecmascript-language-types-string-type\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-types-string-type\">#sec-ecmascript-language-types-string-type</a></emu-xref>). In either context, &#8220;character value&#8221; means the numeric value of the corresponding non-encoded code point.</p>\n      <p>The syntax and semantics of <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> is defined as if the source code for the <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> was a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> values where each <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> corresponds to a Unicode code point. If a BMP pattern contains a non-BMP <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> the entire pattern is encoded using UTF-16 and the individual code units of that encoding are used as the elements of the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>For example, consider a pattern expressed in source text as the single non-BMP character U+1D11E (MUSICAL SYMBOL G CLEF). Interpreted as a Unicode pattern, it would be a single element (character) <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the single code point 0x1D11E. However, interpreted as a BMP pattern, it is first UTF-16 encoded to produce a two element <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of the code units 0xD834 and 0xDD1E.</p>\n        <p>Patterns are passed to the RegExp <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> as ECMAScript String values in which non-BMP characters are UTF-16 encoded. For example, the single character MUSICAL SYMBOL G CLEF pattern, expressed as a String value, is a String of length 2 whose elements were the code units 0xD834 and 0xDD1E. So no further translation of the string would be necessary to process it as a BMP pattern consisting of two pattern characters. However, to process it as a Unicode pattern <emu-xref aoid=\"UTF16DecodeSurrogatePair\"><a href=\"#sec-utf16decodesurrogatepair\">UTF16DecodeSurrogatePair</a></emu-xref> must be used in producing a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of a single pattern character, the code point U+1D11E.</p>\n        <p>An implementation may not actually perform such translations to or from UTF-16, but the semantics of this specification requires that the result of pattern matching be as if such translations were performed.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-notation\"><h1><span class=\"secnum\">21.2.2.1</span>#sec-notation Notation</h1>...</div><div id=\"excluded-sec-pattern\"><h1><span class=\"secnum\">21.2.2.2</span>#sec-pattern Pattern</h1>...</div><div id=\"excluded-sec-disjunction\"><h1><span class=\"secnum\">21.2.2.3</span>#sec-disjunction Disjunction</h1>...</div><div id=\"excluded-sec-alternative\"><h1><span class=\"secnum\">21.2.2.4</span>#sec-alternative Alternative</h1>...</div><div id=\"excluded-sec-term\"><h1><span class=\"secnum\">21.2.2.5</span>#sec-term Term</h1>...</div><div id=\"excluded-sec-assertion\"><h1><span class=\"secnum\">21.2.2.6</span>#sec-assertion Assertion</h1>...</div><div id=\"excluded-sec-quantifier\"><h1><span class=\"secnum\">21.2.2.7</span>#sec-quantifier Quantifier</h1>...</div><div id=\"excluded-sec-atom\"><h1><span class=\"secnum\">21.2.2.8</span>#sec-atom Atom</h1>...</div><div id=\"excluded-sec-atomescape\"><h1><span class=\"secnum\">21.2.2.9</span>#sec-atomescape AtomEscape</h1>...</div><div id=\"excluded-sec-characterescape\"><h1><span class=\"secnum\">21.2.2.10</span>#sec-characterescape CharacterEscape</h1>...</div><div id=\"excluded-sec-decimalescape\"><h1><span class=\"secnum\">21.2.2.11</span>#sec-decimalescape DecimalEscape</h1>...</div><div id=\"excluded-sec-characterclassescape\"><h1><span class=\"secnum\">21.2.2.12</span>#sec-characterclassescape CharacterClassEscape</h1>...</div><div id=\"excluded-sec-characterclass\"><h1><span class=\"secnum\">21.2.2.13</span>#sec-characterclass CharacterClass</h1>...</div><div id=\"excluded-sec-classranges\"><h1><span class=\"secnum\">21.2.2.14</span>#sec-classranges ClassRanges</h1>...</div><div id=\"excluded-sec-nonemptyclassranges\"><h1><span class=\"secnum\">21.2.2.15</span>#sec-nonemptyclassranges NonemptyClassRanges</h1>...</div><div id=\"excluded-sec-nonemptyclassrangesnodash\"><h1><span class=\"secnum\">21.2.2.16</span>#sec-nonemptyclassrangesnodash NonemptyClassRangesNoDash</h1>...</div><div id=\"excluded-sec-classatom\"><h1><span class=\"secnum\">21.2.2.17</span>#sec-classatom ClassAtom</h1>...</div><div id=\"excluded-sec-classatomnodash\"><h1><span class=\"secnum\">21.2.2.18</span>#sec-classatomnodash ClassAtomNoDash</h1>...</div><div id=\"excluded-sec-classescape\"><h1><span class=\"secnum\">21.2.2.19</span>#sec-classescape ClassEscape</h1>...</div></emu-clause>\n\n    "}, "sec-runtime-semantics-repeatmatcher-abstract-operation": {"num": "21.2.2.5.1", "title": "#sec-runtime-semantics-repeatmatcher-abstract-operation Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )", "html": "<emu-clause id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\" aoid=\"RepeatMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-repeatmatcher-abstract-operation\">#sec-runtime-semantics-repeatmatcher-abstract-operation</span> Runtime Semantics: RepeatMatcher ( <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var> )</h1>\n          <p>The abstract operation RepeatMatcher takes eight parameters, a Matcher <var>m</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>min</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> (or &#8734;) <var>max</var>, a Boolean <var>greedy</var>, a State <var>x</var>, a Continuation <var>c</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>parenIndex</var>, and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>parenCount</var>, and performs the following steps:</p>\n          <emu-alg><ol><li>If <var>max</var> is zero, return <var>c</var>(<var>x</var>).</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, and <var>parenCount</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>If <var>min</var> is zero and <var>y</var>'s <var>endIndex</var> is equal to <var>x</var>'s <var>endIndex</var>, return <emu-const>failure</emu-const>.</li><li>If <var>min</var> is zero, let <var>min2</var> be zero; otherwise let <var>min2</var> be <var>min</var> - 1.</li><li>If <var>max</var> is &#8734;, let <var>max2</var> be &#8734;; otherwise let <var>max2</var> be <var>max</var> - 1.</li><li>Call <emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>min2</var>, <var>max2</var>, <var>greedy</var>, <var>y</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>) and return its result.</li></ol></li><li>Let <var>cap</var> be a copy of <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>For each <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>k</var> that satisfies <var>parenIndex</var> &lt; <var>k</var> and <var>k</var> &#8804; <var>parenIndex</var> + <var>parenCount</var>, set <var>cap</var>[<var>k</var>] to <emu-val>undefined</emu-val>.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>xr</var> be the State (<var>e</var>, <var>cap</var>).</li><li>If <var>min</var> is not zero, return <var>m</var>(<var>xr</var>, <var>d</var>).</li><li>If <var>greedy</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and return its result.</li></ol></li><li>Call <var>m</var>(<var>xr</var>, <var>d</var>) and let <var>z</var> be its result.</li><li>If <var>z</var> is not <emu-const>failure</emu-const>, return <var>z</var>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>An <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> followed by a <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> is repeated the number of times specified by the <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt>. A <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> can be non-greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated as many times as possible while still matching the sequel. The <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> pattern is repeated rather than the input character sequence that it matches, so different repetitions of the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> can match different input substrings.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>If the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and the sequel of the regular expression all have choice points, the <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. All choices in the last (n<sup>th</sup>) repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are tried before moving on to the next choice in the next-to-last (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>; at which point it may turn out that more or fewer repetitions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n - 1)<sup>st</sup> repetition of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> and so on.</p>\n            <p>Compare</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}/.exec(<span class=\"hljs-string\">\"abcdefghi\"</span>)</code></pre>\n            <p>which returns <emu-val>\"abcde\"</emu-val> with</p>\n            <pre><code class=\"javascript hljs\">/a[a-z]{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>}?<span class=\"hljs-regexp\">/.exec(\"abcdefghi\")</span></code></pre>\n            <p>which returns <emu-val>\"abc\"</emu-val>.</p>\n            <p>Consider also</p>\n            <pre><code class=\"javascript hljs\">/(aa|aabaac|ba|b|c)*<span class=\"hljs-regexp\">/.exec(\"aabaac\")</span></code></pre>\n            <p>which, by the choice point ordering above, returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aaba\"</span>, <span class=\"hljs-string\">\"ba\"</span>]</code></pre>\n            <p>and not any of:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"aabaac\"</span>]\n[<span class=\"hljs-string\">\"aabaac\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:</p>\n            <pre><code class=\"javascript hljs\"><span class=\"hljs-string\">\"aaaaaaaaaa,aaaaaaaaaaaaaaa\"</span>.replace(<span class=\"hljs-regexp\">/^(a+)\\1*,\\1+$/</span>, <span class=\"hljs-string\">\"$1\"</span>)</code></pre>\n            <p>which returns the gcd in unary notation <emu-val>\"aaaaa\"</emu-val>.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>Step 4 of the RepeatMatcher clears <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>'s captures each time <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> is repeated. We can see its behaviour in the regular expression</p>\n            <pre><code class=\"javascript hljs\">/(z)((a+)?(b+)?(c))*<span class=\"hljs-regexp\">/.exec(\"zaacbbbcac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>and not</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"zaacbbbcac\"</span>, <span class=\"hljs-string\">\"z\"</span>, <span class=\"hljs-string\">\"ac\"</span>, <span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"bbb\"</span>, <span class=\"hljs-string\">\"c\"</span>]</code></pre>\n            <p>because each iteration of the outermost <code>*</code> clears all captured Strings contained in the quantified <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n            <p>Step 2.a of the RepeatMatcher states that once the minimum number of repetitions has been satisfied, any more expansions of <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> that match the empty character sequence are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:</p>\n            <pre><code class=\"javascript hljs\">/(a*)*<span class=\"hljs-regexp\">/.exec(\"b\")</span></code></pre>\n            <p>or the slightly more complicated:</p>\n            <pre><code class=\"javascript hljs\">/(a*)b\\<span class=\"hljs-number\">1</span>+<span class=\"hljs-regexp\">/.exec(\"baaaac\")</span></code></pre>\n            <p>which returns the array</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"\"</span>]</code></pre>\n          </div></emu-note>\n        </emu-clause>\n      "}, "sec-term": {"num": "21.2.2.5", "title": "#sec-term Term", "html": "<emu-clause id=\"sec-term\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-term\">#sec-term</span> Term</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e03dc251\"><emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt>.\n        </li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The resulting Matcher is independent of <var>direction</var>.</p>\n        </div></emu-note>\n        <p>The production  <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"41dded41\"><emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return the Matcher that is the result of evaluating <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var>.\n        </li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Term\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"44aed0a4\"><emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m</var>.</li><li>Evaluate <emu-nt><a href=\"#prod-Quantifier\">Quantifier</a></emu-nt> to obtain the three results: an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>min</var>, an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> (or &#8734;) <var>max</var>, and Boolean <var>greedy</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: If <var>max</var> is finite, then <var>max</var> is not less than <var>min</var>.</li><li>Let <var>parenIndex</var> be the number of left-capturing parentheses in the entire regular expression that occur to the left of this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes prior to or enclosing this <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>.</li><li>Let <var>parenCount</var> be the number of left-capturing parentheses in <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>. This is the total number of <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes enclosed by <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>parenIndex</var>, and <var>parenCount</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Call <emu-xref aoid=\"RepeatMatcher\"><a href=\"#sec-runtime-semantics-repeatmatcher-abstract-operation\">RepeatMatcher</a></emu-xref>(<var>m</var>, <var>min</var>, <var>max</var>, <var>greedy</var>, <var>x</var>, <var>c</var>, <var>parenIndex</var>, <var>parenCount</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-repeatmatcher-abstract-operation\"><h1><span class=\"secnum\">21.2.2.5.1</span>#sec-runtime-semantics-repeatmatcher-abstract-operation Runtime Semantics: RepeatMatcher ( m, min, max, greedy, x, c, parenIndex, parenCount )</h1>...</div></emu-clause>\n\n      "}, "sec-notation": {"num": "21.2.2.1", "title": "#sec-notation Notation", "html": "<emu-clause id=\"sec-notation\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-notation\">#sec-notation</span> Notation</h1>\n        <p>The descriptions below use the following variables:</p>\n        <ul>\n          <li>\n            <var>Input</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> consisting of all of the characters, in order, of the String being matched by the regular expression pattern. Each character is either a code unit or a code point, depending upon the kind of pattern involved. The notation <var>Input</var>[<var>n</var>] means the <var>n</var><sup>th</sup> character of <var>Input</var>, where <var>n</var> can range between 0 (inclusive) and <var>InputLength</var> (exclusive).\n          \n          </li>\n          <li>\n            <var>InputLength</var> is the number of characters in <var>Input</var>.\n          \n          </li>\n          <li>\n            <var>NcapturingParens</var> is the total number of left-capturing parentheses (i.e. the total number of  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> Parse Nodes) in the pattern. A left-capturing parenthesis is any <code>(</code> pattern character that is matched by the <code>(</code> terminal of the  <emu-grammar><emu-production name=\"Atom\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Atom\">Atom</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"59aa089b\"><emu-t>(</emu-t><emu-nt><a href=\"#prod-GroupSpecifier\">GroupSpecifier</a></emu-nt><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> production.\n          \n          </li>\n          <li>\n            <var>DotAll</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"s\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            <var>IgnoreCase</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"i\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            <var>Multiline</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"m\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n          <li>\n            <var>Unicode</var> is <emu-val>true</emu-val> if the RegExp object's [[OriginalFlags]] internal slot contains <emu-val>\"u\"</emu-val> and otherwise is <emu-val>false</emu-val>.\n          \n          </li>\n        </ul>\n        <p>Furthermore, the descriptions below use the following internal data structures:</p>\n        <ul>\n          <li>\n            A  <em>CharSet</em> is a mathematical set of characters, either code units or code points depending up the state of the <var>Unicode</var> flag. &#8220;All characters&#8221; means either all code unit values or all code point values also depending upon the state of <var>Unicode</var>.\n          \n          </li>\n          <li>\n            A  <em>State</em> is an ordered pair (<var>endIndex</var>, <var>captures</var>) where <var>endIndex</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> and <var>captures</var> is a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <var>NcapturingParens</var> values. States are used to represent partial match states in the regular expression matching algorithms. The <var>endIndex</var> is one plus the index of the last input character matched so far by the pattern, while <var>captures</var> holds the results of capturing parentheses. The <var>n</var><sup>th</sup> element of <var>captures</var> is either a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> that represents the value obtained by the <var>n</var><sup>th</sup> set of capturing parentheses or <emu-val>undefined</emu-val> if the <var>n</var><sup>th</sup> set of capturing parentheses hasn't been reached yet. Due to backtracking, many States may be in use at any time during the matching process.\n          \n          </li>\n          <li>\n            A  <em>MatchResult</em> is either a State or the special token <emu-const>failure</emu-const> that indicates that the match failed.\n          \n          </li>\n          <li>\n            A  <em>Continuation</em> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> that takes one State argument and returns a MatchResult result. The Continuation attempts to match the remaining portion (specified by the closure's captured values) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. If the match succeeds, the Continuation returns the final State that it reached; if the match fails, the Continuation returns <emu-const>failure</emu-const>.\n          \n          </li>\n          <li>\n            A  <em>Matcher</em> is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> that takes two arguments&#8212;a State and a Continuation&#8212;and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified by the closure's captured values) of the pattern against <var>Input</var>, starting at the intermediate state given by its State argument. The Continuation argument should be a closure that matches the rest of the pattern. After matching the subpattern of a pattern to obtain a new State, the Matcher then calls Continuation on that new State to test if the rest of the pattern can match as well. If it can, the Matcher returns the State returned by Continuation; if not, the Matcher may try different choices at its choice points, repeatedly calling Continuation until it either succeeds or all possibilities have been exhausted.\n          \n          </li>\n        </ul>\n      </emu-clause>\n\n      "}, "sec-escaperegexppattern": {"num": "21.2.3.2.4", "title": "#sec-escaperegexppattern Runtime Semantics: EscapeRegExpPattern ( P, F )", "html": "<emu-clause id=\"sec-escaperegexppattern\" aoid=\"EscapeRegExpPattern\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-escaperegexppattern\">#sec-escaperegexppattern</span> Runtime Semantics: EscapeRegExpPattern ( <var>P</var>, <var>F</var> )</h1>\n          <p>When the abstract operation EscapeRegExpPattern with arguments <var>P</var> and <var>F</var> is called, the following occurs:</p>\n          <emu-alg><ol><li>Let <var>S</var> be a String in the form of a <emu-nt params=\"~U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U]</emu-params></emu-mods></emu-nt> (<emu-nt params=\"+U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[+U]</emu-params></emu-mods></emu-nt> if <var>F</var> contains <emu-val>\"u\"</emu-val>) equivalent to <var>P</var> interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"><a href=\"#sec-ecmascript-language-types-string-type\" class=\"excluded-xref\" excluded-id=\"sec-ecmascript-language-types-string-type\">#sec-ecmascript-language-types-string-type</a></emu-xref>), in which certain code points are escaped as described below. <var>S</var> may or may not be identical to <var>P</var>; however, the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> that would result from evaluating <var>S</var> as a <emu-nt params=\"~U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U]</emu-params></emu-mods></emu-nt> (<emu-nt params=\"+U\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[+U]</emu-params></emu-mods></emu-nt> if <var>F</var> contains <emu-val>\"u\"</emu-val>) must behave identically to the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for <var>P</var> and <var>F</var> must produce identical results.</li><li>The code points <code>/</code> or any <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt> occurring in the pattern shall be escaped in <var>S</var> as necessary to ensure that the <emu-xref href=\"#sec-ecmascript-language-types-string-type\"><a href=\"#sec-ecmascript-language-types-string-type\">string-concatenation</a></emu-xref> of <emu-val>\"/\"</emu-val>, <var>S</var>, <emu-val>\"/\"</emu-val>, and <var>F</var> can be parsed (in an appropriate lexical context) as a <emu-nt><a href=\"#prod-RegularExpressionLiteral\">RegularExpressionLiteral</a></emu-nt> that behaves identically to the constructed regular expression. For example, if <var>P</var> is <emu-val>\"/\"</emu-val>, then <var>S</var> could be <emu-val>\"\\/\"</emu-val> or <emu-val>\"\\u002F\"</emu-val>, among other possibilities, but not <emu-val>\"/\"</emu-val>, because <code>///</code> followed by <var>F</var> would be parsed as a <emu-nt><a href=\"#prod-SingleLineComment\">SingleLineComment</a></emu-nt> rather than a <emu-nt><a href=\"#prod-RegularExpressionLiteral\">RegularExpressionLiteral</a></emu-nt>. If <var>P</var> is the empty String, this specification can be met by letting <var>S</var> be <emu-val>\"(?:)\"</emu-val>.</li><li>Return <var>S</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-regexpinitialize": {"num": "21.2.3.2.2", "title": "#sec-regexpinitialize Runtime Semantics: RegExpInitialize ( obj, pattern, flags )", "html": "<emu-clause id=\"sec-regexpinitialize\" aoid=\"RegExpInitialize\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-regexpinitialize\">#sec-regexpinitialize</span> Runtime Semantics: RegExpInitialize ( <var>obj</var>, <var>pattern</var>, <var>flags</var> )</h1>\n          <p>When the abstract operation RegExpInitialize with arguments <var>obj</var>, <var>pattern</var>, and <var>flags</var> is called, the following steps are taken:</p>\n          <emu-alg><ol><li>If <var>pattern</var> is <emu-val>undefined</emu-val>, let <var>P</var> be the empty String.</li><li>Else, let <var>P</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>pattern</var>).</li><li>If <var>flags</var> is <emu-val>undefined</emu-val>, let <var>F</var> be the empty String.</li><li>Else, let <var>F</var> be ?&#160;<emu-xref aoid=\"ToString\"><a href=\"#sec-tostring\">ToString</a></emu-xref>(<var>flags</var>).</li><li>If <var>F</var> contains any code unit other than <emu-val>\"g\"</emu-val>, <emu-val>\"i\"</emu-val>, <emu-val>\"m\"</emu-val>, <emu-val>\"s\"</emu-val>, <emu-val>\"u\"</emu-val>, or <emu-val>\"y\"</emu-val> or if it contains the same code unit more than once, throw a <emu-val>SyntaxError</emu-val> exception.</li><li>If <var>F</var> contains <emu-val>\"u\"</emu-val>, let <var>BMP</var> be <emu-val>false</emu-val>; else let <var>BMP</var> be <emu-val>true</emu-val>.</li><li>If <var>BMP</var> is <emu-val>true</emu-val>, then<ol><li>Let <var>pText</var> be the sequence of code points resulting from interpreting each of the 16-bit elements of <var>P</var> as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.</li><li>Parse <var>pText</var> using the grammars in <emu-xref href=\"#sec-patterns\"><a href=\"#sec-patterns\" class=\"excluded-xref\" excluded-id=\"sec-patterns\">#sec-patterns</a></emu-xref>. The <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> for the parse is <emu-nt params=\"~U, ~N\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U, ~N]</emu-params></emu-mods></emu-nt>. If the result of parsing contains a <emu-nt><a href=\"#prod-GroupName\">GroupName</a></emu-nt>, reparse with the <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> <emu-nt params=\"~U, +N\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[~U, +N]</emu-params></emu-mods></emu-nt> and use this result instead. Throw a <emu-val>SyntaxError</emu-val> exception if <var>pText</var> did not conform to the grammar, if any elements of <var>pText</var> were not matched by the parse, or if any Early Error conditions exist.</li><li>Let <var>patternCharacters</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the code unit elements of <var>P</var>.</li></ol></li><li>Else,<ol><li>Let <var>pText</var> be !&#160;<emu-xref aoid=\"UTF16DecodeString\"><a href=\"#sec-utf16decodestring\">UTF16DecodeString</a></emu-xref>(<var>P</var>).</li><li>Parse <var>pText</var> using the grammars in <emu-xref href=\"#sec-patterns\"><a href=\"#sec-patterns\" class=\"excluded-xref\" excluded-id=\"sec-patterns\">#sec-patterns</a></emu-xref>. The <emu-xref href=\"#sec-context-free-grammars\"><a href=\"#sec-context-free-grammars\">goal symbol</a></emu-xref> for the parse is <emu-nt params=\"+U, +N\"><a href=\"#prod-Pattern\">Pattern</a><emu-mods><emu-params>[+U, +N]</emu-params></emu-mods></emu-nt>. Throw a <emu-val>SyntaxError</emu-val> exception if <var>pText</var> did not conform to the grammar, if any elements of <var>pText</var> were not matched by the parse, or if any Early Error conditions exist.</li><li>Let <var>patternCharacters</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the code points of <var>pText</var>.</li></ol></li><li>Set <var>obj</var>.[[OriginalSource]] to <var>P</var>.</li><li>Set <var>obj</var>.[[OriginalFlags]] to <var>F</var>.</li><li>Set <var>obj</var>.[[RegExpMatcher]] to the <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> that evaluates the above parse by applying the semantics provided in <emu-xref href=\"#sec-pattern-semantics\"><a href=\"#sec-pattern-semantics\" class=\"excluded-xref\" excluded-id=\"sec-pattern-semantics\">#sec-pattern-semantics</a></emu-xref> using <var>patternCharacters</var> as the pattern's <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of <emu-nt><a href=\"#prod-SourceCharacter\">SourceCharacter</a></emu-nt> values and <var>F</var> as the flag parameters.</li><li>Perform ?&#160;<emu-xref aoid=\"Set\"><a href=\"#sec-set-o-p-v-throw\">Set</a></emu-xref>(<var>obj</var>, <emu-val>\"lastIndex\"</emu-val>, 0, <emu-val>true</emu-val>).</li><li>Return <var>obj</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-assertion": {"num": "21.2.2.6", "title": "#sec-assertion Assertion", "html": "<emu-clause id=\"sec-assertion\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-assertion\">#sec-assertion</span> Assertion</h1>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"e5878811\"><emu-t>^</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is zero, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var> - 1] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Even when the <code>y</code> flag is used with a pattern, <code>^</code> always matches only at the beginning of <var>Input</var>, or (if <var>Multiline</var> is <emu-val>true</emu-val>) at the beginning of a line.</p>\n        </div></emu-note>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1262cc92\"><emu-t>$</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>If <var>e</var> is equal to <var>InputLength</var>, or if <var>Multiline</var> is <emu-val>true</emu-val> and the character <var>Input</var>[<var>e</var>] is one of <emu-nt><a href=\"#prod-LineTerminator\">LineTerminator</a></emu-nt>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1e228da5\"><emu-t>\\</emu-t><emu-t>b</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>false</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>true</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"a5dc97fa\"><emu-t>\\</emu-t><emu-t>B</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var> - 1) and let <var>a</var> be the Boolean result.</li><li>Call <emu-xref aoid=\"IsWordChar\"><a href=\"#sec-runtime-semantics-iswordchar-abstract-operation\">IsWordChar</a></emu-xref>(<var>e</var>) and let <var>b</var> be the Boolean result.</li><li>If <var>a</var> is <emu-val>true</emu-val> and <var>b</var> is <emu-val>true</emu-val>, or if <var>a</var> is <emu-val>false</emu-val> and <var>b</var> is <emu-val>false</emu-val>, then<ol><li>Call <var>c</var>(<var>x</var>) and return its result.</li></ol></li><li>Return <emu-const>failure</emu-const>.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"cfb94f94\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"ba98f6e2\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with +1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"8db9fbbe\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;=</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Let <var>y</var> be <var>r</var>'s State.</li><li>Let <var>cap</var> be <var>y</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>xe</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>z</var> be the State (<var>xe</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>z</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Assertion\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Assertion\">Assertion</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"1b07b2c0\"><emu-t>(</emu-t><emu-t>?</emu-t><emu-t>&lt;!</emu-t><emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt><emu-t>)</emu-t></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> with -1 as its <var>direction</var> argument to obtain a Matcher <var>m</var>.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Return <var>y</var>.</li></ol></li><li>Call <var>m</var>(<var>x</var>, <var>d</var>) and let <var>r</var> be its result.</li><li>If <var>r</var> is not <emu-const>failure</emu-const>, return <emu-const>failure</emu-const>.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n\n        <div id=\"excluded-sec-runtime-semantics-wordcharacters-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.1</span>#sec-runtime-semantics-wordcharacters-abstract-operation Runtime Semantics: WordCharacters ( )</h1>...</div><div id=\"excluded-sec-runtime-semantics-iswordchar-abstract-operation\"><h1><span class=\"secnum\">21.2.2.6.2</span>#sec-runtime-semantics-iswordchar-abstract-operation Runtime Semantics: IsWordChar ( e )</h1>...</div></emu-clause>\n      "}, "sec-alternative": {"num": "21.2.2.4", "title": "#sec-alternative Alternative", "html": "<emu-clause id=\"sec-alternative\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-alternative\">#sec-alternative</span> Alternative</h1>\n        <p>With parameter <var>direction</var>.</p>\n        <p>The production  <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"37b9c04c\"><emu-gann>[empty]</emu-gann></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures nothing and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Call <var>c</var>(<var>x</var>) and return its result.\n        </li></ol></li></ol></emu-alg>\n        <p>The production  <emu-grammar><emu-production name=\"Alternative\" type=\"lexical\" collapsed=\"\" class=\" inline\">\n    <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-geq>::</emu-geq><emu-rhs a=\"bdc4c1a6\"><emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt><emu-nt><a href=\"#prod-Term\">Term</a></emu-nt></emu-rhs>\n</emu-production></emu-grammar> evaluates as follows:</p>\n        <emu-alg><ol><li>Evaluate <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m1</var>.</li><li>Evaluate <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> with argument <var>direction</var> to obtain a Matcher <var>m2</var>.</li><li>If <var>direction</var> is equal to +1, then<ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>c</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Call <var>m2</var>(<var>y</var>, <var>c</var>) and return its result.</li></ol></li><li>Call <var>m1</var>(<var>x</var>, <var>d</var>) and return its result.</li></ol></li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>direction</var> is equal to -1.</li><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>m1</var> and <var>m2</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>d</var> be a new Continuation with parameters (<var>y</var>) that captures <var>c</var> and <var>m1</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>y</var> is a State.</li><li>Call <var>m1</var>(<var>y</var>, <var>c</var>) and return its result.</li></ol></li><li>Call <var>m2</var>(<var>x</var>, <var>d</var>) and return its result.\n        </li></ol></li></ol></li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>Consecutive <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>s try to simultaneously match consecutive portions of <var>Input</var>. When <var>direction</var> is equal to +1, if the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>, the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and the sequel of the regular expression all have choice points, all choices in the sequel are tried before moving on to the next choice in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt>, and all choices in the right <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are tried before moving on to the next choice in the left <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt>. When <var>direction</var> is equal to -1, the evaluation order of <emu-nt><a href=\"#prod-Alternative\">Alternative</a></emu-nt> and <emu-nt><a href=\"#prod-Term\">Term</a></emu-nt> are reversed.</p>\n        </div></emu-note>\n      </emu-clause>\n\n      "}, "sec-runtime-semantics-canonicalize-ch": {"num": "21.2.2.8.2", "title": "#sec-runtime-semantics-canonicalize-ch Runtime Semantics: Canonicalize ( ch )", "html": "<emu-clause id=\"sec-runtime-semantics-canonicalize-ch\" aoid=\"Canonicalize\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-canonicalize-ch\">#sec-runtime-semantics-canonicalize-ch</span> Runtime Semantics: Canonicalize ( <var>ch</var> )</h1>\n          <p>The abstract operation Canonicalize takes a character parameter <var>ch</var> and performs the following steps:</p>\n          <emu-alg><ol><li>If <var>IgnoreCase</var> is <emu-val>false</emu-val>, return <var>ch</var>.</li><li>If <var>Unicode</var> is <emu-val>true</emu-val>, then<ol><li>If the file CaseFolding.txt of the Unicode Character Database provides a simple or common case folding mapping for <var>ch</var>, return the result of applying that mapping to <var>ch</var>.</li><li>Return <var>ch</var>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>ch</var> is a UTF-16 code unit.</li><li>Let <var>s</var> be the String value consisting of the single code unit <var>ch</var>.</li><li>Let <var>u</var> be the same result produced as if by performing the algorithm for <code>String.prototype.toUpperCase</code> using <var>s</var> as the <emu-val>this</emu-val> value.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>u</var>) is String.</li><li>If <var>u</var> does not consist of a single code unit, return <var>ch</var>.</li><li>Let <var>cu</var> be <var>u</var>'s single code unit element.</li><li>If the numeric value of <var>ch</var> &#8805; 128 and the numeric value of <var>cu</var> &lt; 128, return <var>ch</var>.</li><li>Return <var>cu</var>.\n          </li></ol></li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n            <p>Parentheses of the form <code>(</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> serve both to group the components of the <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> pattern together and to save the result of the match. The result can be used either in a backreference (<code>\\</code> followed by a nonzero decimal number), referenced in a replace String, or returned as part of an array from the regular expression matching <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref>. To inhibit the capturing behaviour of parentheses, use the form <code>(?:</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> instead.</p>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n            <p>The form <code>(?=</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> specifies a zero-width positive lookahead. In order for it to succeed, the pattern inside <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> must match at the current position, but the current position is not advanced before matching the sequel. If <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> can match at the current position in several ways, only the first one is tried. Unlike other regular expression operators, there is no backtracking into a <code>(?=</code> form (this unusual behaviour is inherited from Perl). This only matters when the <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> contains capturing parentheses and the sequel of the pattern contains backreferences to those captures.</p>\n            <p>For example,</p>\n            <pre><code class=\"javascript hljs\">/(?=(a+))/.exec(<span class=\"hljs-string\">\"baaabac\"</span>)</code></pre>\n            <p>matches the empty String immediately after the first <code>b</code> and therefore returns the array:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"\"</span>, <span class=\"hljs-string\">\"aaa\"</span>]</code></pre>\n            <p>To illustrate the lack of backtracking into the lookahead, consider:</p>\n            <pre><code class=\"javascript hljs\">/(?=(a+))a*b\\<span class=\"hljs-number\">1</span>/.exec(<span class=\"hljs-string\">\"baaabac\"</span>)</code></pre>\n            <p>This expression returns</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aba\"</span>, <span class=\"hljs-string\">\"a\"</span>]</code></pre>\n            <p>and not:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"aaaba\"</span>, <span class=\"hljs-string\">\"a\"</span>]</code></pre>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 3</span><div class=\"note-contents\">\n            <p>The form <code>(?!</code> <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> <code>)</code> specifies a zero-width negative lookahead. In order for it to succeed, the pattern inside <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> must fail to match at the current position. The current position is not advanced before matching the sequel. <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> can contain capturing parentheses, but backreferences to them only make sense from within <emu-nt><a href=\"#prod-Disjunction\">Disjunction</a></emu-nt> itself. Backreferences to these capturing parentheses from elsewhere in the pattern always return <emu-val>undefined</emu-val> because the negative lookahead must fail for the pattern to succeed. For example,</p>\n            <pre><code class=\"javascript hljs\">/(.*?)a(?!(a+)b\\<span class=\"hljs-number\">2</span>c)\\<span class=\"hljs-number\">2</span>(.*)/.exec(<span class=\"hljs-string\">\"baaabaac\"</span>)</code></pre>\n            <p>looks for an <code>a</code> not immediately followed by some positive number n of <code>a</code>'s, a <code>b</code>, another n <code>a</code>'s (specified by the first <code>\\2</code>) and a <code>c</code>. The second <code>\\2</code> is outside the negative lookahead, so it matches against <emu-val>undefined</emu-val> and therefore always succeeds. The whole expression returns the array:</p>\n            <pre><code class=\"javascript hljs\">[<span class=\"hljs-string\">\"baaabaac\"</span>, <span class=\"hljs-string\">\"ba\"</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"abaac\"</span>]</code></pre>\n          </div></emu-note>\n          <emu-note><span class=\"note\">Note 4</span><div class=\"note-contents\">\n            <p>In case-insignificant matches when <var>Unicode</var> is <emu-val>true</emu-val>, all characters are implicitly case-folded using the simple mapping provided by the Unicode standard immediately before they are compared. The simple mapping always maps to a single code point, so it does not map, for example, <code>&#223;</code> (U+00DF) to <code>SS</code>. It may however map a code point outside the Basic Latin range to a character within, for example, <code>&#383;</code> (U+017F) to <code>s</code>. Such characters are not mapped if <var>Unicode</var> is <emu-val>false</emu-val>. This prevents Unicode code points such as U+017F and U+212A from matching regular expressions such as <code>/[a-z]/i</code>, but they will match <code>/[a-z]/ui</code>.</p>\n          </div></emu-note>\n        </emu-clause>\n        "}, "sec-runtime-semantics-charactersetmatcher-abstract-operation": {"num": "21.2.2.8.1", "title": "#sec-runtime-semantics-charactersetmatcher-abstract-operation Runtime Semantics: CharacterSetMatcher ( A, invert, direction )", "html": "<emu-clause id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\" aoid=\"CharacterSetMatcher\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-runtime-semantics-charactersetmatcher-abstract-operation\">#sec-runtime-semantics-charactersetmatcher-abstract-operation</span> Runtime Semantics: CharacterSetMatcher ( <var>A</var>, <var>invert</var>, <var>direction</var> )</h1>\n          <p>The abstract operation CharacterSetMatcher takes three arguments, a CharSet <var>A</var>, a Boolean flag <var>invert</var>, and an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> <var>direction</var>, and performs the following steps:</p>\n          <emu-alg><ol><li>Return a new Matcher with parameters (<var>x</var>, <var>c</var>) that captures <var>A</var>, <var>invert</var>, and <var>direction</var> and performs the following steps when called:<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>x</var> is a State.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>c</var> is a Continuation.</li><li>Let <var>e</var> be <var>x</var>'s <var>endIndex</var>.</li><li>Let <var>f</var> be <var>e</var> + <var>direction</var>.</li><li>If <var>f</var> &lt; 0 or <var>f</var> &gt; <var>InputLength</var>, return <emu-const>failure</emu-const>.</li><li>Let <var>index</var> be <emu-xref aoid=\"min\"><a href=\"#eqn-min\">min</a></emu-xref>(<var>e</var>, <var>f</var>).</li><li>Let <var>ch</var> be the character <var>Input</var>[<var>index</var>].</li><li>Let <var>cc</var> be <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>ch</var>).</li><li>If <var>invert</var> is <emu-val>false</emu-val>, then<ol><li>If there does not exist a member <var>a</var> of set <var>A</var> such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>a</var>) is <var>cc</var>, return <emu-const>failure</emu-const>.</li></ol></li><li>Else,<ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>invert</var> is <emu-val>true</emu-val>.</li><li>If there exists a member <var>a</var> of set <var>A</var> such that <emu-xref aoid=\"Canonicalize\"><a href=\"#sec-runtime-semantics-canonicalize-ch\">Canonicalize</a></emu-xref>(<var>a</var>) is <var>cc</var>, return <emu-const>failure</emu-const>.</li></ol></li><li>Let <var>cap</var> be <var>x</var>'s <var>captures</var> <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>y</var> be the State (<var>f</var>, <var>cap</var>).</li><li>Call <var>c</var>(<var>y</var>) and return its result.\n          </li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-properties-of-regexp-instances": {"num": "21.2.6", "title": "#sec-properties-of-regexp-instances Properties of RegExp Instances", "html": "<emu-clause id=\"sec-properties-of-regexp-instances\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-properties-of-regexp-instances\">#sec-properties-of-regexp-instances</span> Properties of RegExp Instances</h1>\n      <p>RegExp instances are ordinary objects that inherit properties from the RegExp prototype object. RegExp instances have internal slots [[RegExpMatcher]], [[OriginalSource]], and [[OriginalFlags]]. The value of the [[RegExpMatcher]] internal slot is an <emu-xref href=\"#sec-abstract-closure\"><a href=\"#sec-abstract-closure\">abstract closure</a></emu-xref> representation of the <emu-nt><a href=\"#prod-Pattern\">Pattern</a></emu-nt> of the RegExp object.</p>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>Prior to ECMAScript 2015, <code>RegExp</code> instances were specified as having the own data properties <emu-val>\"source\"</emu-val>, <emu-val>\"global\"</emu-val>, <emu-val>\"ignoreCase\"</emu-val>, and <emu-val>\"multiline\"</emu-val>. Those properties are now specified as accessor properties of <code>RegExp.prototype</code>.</p>\n      </div></emu-note>\n      <p>RegExp instances also have the following property:</p>\n\n      <div id=\"excluded-sec-lastindex\"><h1><span class=\"secnum\">21.2.6.1</span>#sec-lastindex lastIndex</h1>...</div></emu-clause>\n\n    "}}, "figData": {}}}