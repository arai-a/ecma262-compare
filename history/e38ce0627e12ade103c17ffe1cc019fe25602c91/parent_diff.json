{"from": {"secList": ["sec-numeric-types-number-unsignedRightShift", "sec-numeric-types-bigint-exponentiate", "sec-numeric-types-bigint-bitwiseXOR", "sec-numeric-types-number-leftShift", "sec-numeric-types-number-sameValueZero", "sec-numeric-types-number-bitwiseAND", "sec-numeric-types-bigint-remainder", "sec-numeric-types-number-sameValue", "sec-numeric-types-number-bitwiseNOT", "sec-numeric-types-bigint-bitwiseOR", "sec-numeric-types-number-bitwiseOR", "sec-subtraction-operator-minus", "sec-numeric-types-number-lessThan", "sec-numeric-types-bigint-divide", "sec-numeric-types-number-subtract", "sec-numeric-types-number-multiply", "sec-numeric-types-number-signedRightShift", "sec-numeric-types-number-divide", "sec-numeric-types-number-equal", "sec-numeric-types-bigint-unaryMinus", "sec-numeric-types-number-exponentiate", "sec-multiplicative-operators", "sec-numeric-types-number-remainder", "sec-numeric-types-number-bitwiseXOR", "sec-numeric-types-number-unaryMinus", "sec-numeric-types-bigint-bitwiseAND", "sec-numeric-types-number-add"], "secData": {"sec-numeric-types-number-unsignedRightShift": {"num": "6.1.6.1.11", "title": "#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unsignedRightShift\">#sec-numeric-types-number-unsignedRightShift</span> Number::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be the result of masking out all but the least significant 5 bits of <var>rnum</var>, that is, compute <var>rnum</var> &amp; 0x1F.</li><li>Return the result of performing a zero-filling right shift of <var>lnum</var> by <var>shiftCount</var> bits. Vacated bits are filled with zero. The result is an unsigned 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-exponentiate": {"num": "6.1.6.2.3", "title": "#sec-numeric-types-bigint-exponentiate BigInt::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-bigint-exponentiate\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-exponentiate\">#sec-numeric-types-bigint-exponentiate</span> BigInt::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <emu-alg><ol><li>If <var>exponent</var> &lt; <emu-val>0n</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>base</var> is <emu-val>0n</emu-val> and <var>exponent</var> is <emu-val>0n</emu-val>, return <emu-val>1n</emu-val>.</li><li>Return the BigInt value that represents the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>base</var> raised to the power <var>exponent</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseXOR": {"num": "6.1.6.2.21", "title": "#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseXOR\">#sec-numeric-types-bigint-bitwiseXOR</span> BigInt::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"^\"</emu-val>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-leftShift": {"num": "6.1.6.1.9", "title": "#sec-numeric-types-number-leftShift Number::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-leftShift\">#sec-numeric-types-number-leftShift</span> Number::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be the result of masking out all but the least significant 5 bits of <var>rnum</var>, that is, compute <var>rnum</var> &amp; 0x1F.</li><li>Return the result of left shifting <var>lnum</var> by <var>shiftCount</var> bits. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-sameValueZero": {"num": "6.1.6.1.15", "title": "#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValueZero\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValueZero\">#sec-numeric-types-number-sameValueZero</span> Number::sameValueZero ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseAND": {"num": "6.1.6.1.17", "title": "#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseAND\">#sec-numeric-types-number-bitwiseAND</span> Number::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-remainder": {"num": "6.1.6.2.6", "title": "#sec-numeric-types-bigint-remainder BigInt::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-bigint-remainder\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-remainder\">#sec-numeric-types-bigint-remainder</span> BigInt::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <emu-alg><ol><li>If <var>d</var> is <emu-val>0n</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>n</var> is <emu-val>0n</emu-val>, return <emu-val>0n</emu-val>.</li><li>Let <var>r</var> be the BigInt defined by the mathematical relation <var>r</var> = <var>n</var> - (<var>d</var> &#215; <var>q</var>) where <var>q</var> is a BigInt that is negative only if <var>n</var>/<var>d</var> is negative and positive only if <var>n</var>/<var>d</var> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <var>n</var> and <var>d</var>.</li><li>Return <var>r</var>.\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">The sign of the result equals the sign of the dividend.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-sameValue": {"num": "6.1.6.1.14", "title": "#sec-numeric-types-number-sameValue Number::sameValue ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValue\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValue\">#sec-numeric-types-number-sameValue</span> Number::sameValue ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseNOT": {"num": "6.1.6.1.2", "title": "#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseNOT\">#sec-numeric-types-number-bitwiseNOT</span> Number::bitwiseNOT ( <var>x</var> )</h1>\n          <emu-alg><ol><li>Let <var>oldValue</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Return the result of applying bitwise complement to <var>oldValue</var>. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseOR": {"num": "6.1.6.2.22", "title": "#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseOR\">#sec-numeric-types-bigint-bitwiseOR</span> BigInt::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"|\"</emu-val>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseOR": {"num": "6.1.6.1.19", "title": "#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseOR\">#sec-numeric-types-number-bitwiseOR</span> Number::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-subtraction-operator-minus": {"num": "12.8.4", "title": "#sec-subtraction-operator-minus The Subtraction Operator ( - )", "html": "<emu-clause id=\"sec-subtraction-operator-minus\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-subtraction-operator-minus\">#sec-subtraction-operator-minus</span> The Subtraction Operator ( <code>-</code> )</h1>\n\n      <div id=\"excluded-sec-subtraction-operator-minus-runtime-semantics-evaluation\"><h1><span class=\"secnum\">12.8.4.1</span>#sec-subtraction-operator-minus-runtime-semantics-evaluation Runtime Semantics: Evaluation</h1>...</div></emu-clause>\n  "}, "sec-numeric-types-number-lessThan": {"num": "6.1.6.1.12", "title": "#sec-numeric-types-number-lessThan Number::lessThan ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-lessThan\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-lessThan\">#sec-numeric-types-number-lessThan</span> Number::lessThan ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>x</var> and <var>y</var> are the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>y</var> is <emu-val>-&#8734;</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-&#8734;</emu-val>, return <emu-val>true</emu-val>.</li><li>If the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>x</var> is less than the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>y</var>&#8212;note that these mathematical values are both finite and not both zero&#8212;return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-divide": {"num": "6.1.6.2.5", "title": "#sec-numeric-types-bigint-divide BigInt::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-divide\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-divide\">#sec-numeric-types-bigint-divide</span> BigInt::divide ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>If <var>y</var> is <emu-val>0n</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>quotient</var> be the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>x</var> divided by <var>y</var>.</li><li>Return the BigInt value that represents <var>quotient</var> rounded towards 0 to the next integral value.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-subtract": {"num": "6.1.6.1.8", "title": "#sec-numeric-types-number-subtract Number::subtract ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-subtract\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-subtract\">#sec-numeric-types-number-subtract</span> Number::subtract ( <var>x</var>, <var>y</var> )</h1>\n          <p>The <code>-</code> operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; <var>x</var> is the minuend and <var>y</var> is the subtrahend. It is always the case that <code>x - y</code> produces the same result as <code>x + (-y)</code>.</p>\n          <p>The result of <code>-</code> operator is then <var>x</var> + (-<var>y</var>).</p>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-multiply": {"num": "6.1.6.1.4", "title": "#sec-numeric-types-number-multiply Number::multiply ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-multiply\" oldids=\"sec-applying-the-mul-operator\">\n          <span id=\"sec-applying-the-mul-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-multiply\">#sec-numeric-types-number-multiply</span> Number::multiply ( <var>x</var>, <var>y</var> )</h1>\n          <p>The <code>*</code> <emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt> performs multiplication, producing the product of <var>x</var> and <var>y</var>. Multiplication is commutative. Multiplication is not always associative in ECMAScript, because of finite precision.</p>\n          <p>The result of a floating-point multiplication is governed by the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n            \n            </li>\n            <li>\n              Multiplication of an infinity by a zero results in <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity nor <emu-val>NaN</emu-val> is involved, the product is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>.\n            \n            </li>\n          </ul>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-signedRightShift": {"num": "6.1.6.1.10", "title": "#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-signedRightShift\">#sec-numeric-types-number-signedRightShift</span> Number::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be the result of masking out all but the least significant 5 bits of <var>rnum</var>, that is, compute <var>rnum</var> &amp; 0x1F.</li><li>Return the result of performing a sign-extending right shift of <var>lnum</var> by <var>shiftCount</var> bits. The most significant bit is propagated. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-divide": {"num": "6.1.6.1.5", "title": "#sec-numeric-types-number-divide Number::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-divide\" oldids=\"sec-applying-the-div-operator\">\n          <span id=\"sec-applying-the-div-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-divide\">#sec-numeric-types-number-divide</span> Number::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The <code>/</code> <emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt> performs division, producing the quotient of <var>x</var> and <var>y</var>. <var>x</var> is the dividend and <var>y</var> is the divisor. ECMAScript does not perform <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> division. The operands and result of all division operations are double-precision floating-point numbers. The result of division is determined by the specification of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n            \n            </li>\n            <li>\n              Division of an infinity by an infinity results in <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of a zero by a zero results in <emu-val>NaN</emu-val>; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity, nor a zero, nor <emu-val>NaN</emu-val> is involved, the quotient is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode. If the magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of gradual underflow as defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>.\n            \n            </li>\n          </ul>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-equal": {"num": "6.1.6.1.13", "title": "#sec-numeric-types-number-equal Number::equal ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-equal\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-equal\">#sec-numeric-types-number-equal</span> Number::equal ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-unaryMinus": {"num": "6.1.6.2.1", "title": "#sec-numeric-types-bigint-unaryMinus BigInt::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-unaryMinus\">#sec-numeric-types-bigint-unaryMinus</span> BigInt::unaryMinus ( <var>x</var> )</h1>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>0n</emu-val>, return <emu-val>0n</emu-val>.</li><li>Return the BigInt value that represents the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of negating <var>x</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-exponentiate": {"num": "6.1.6.1.3", "title": "#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-number-exponentiate\" oldids=\"sec-applying-the-exp-operator\">\n          <span id=\"sec-applying-the-exp-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-exponentiate\">#sec-numeric-types-number-exponentiate</span> Number::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>\n            Returns an implementation-dependent approximation of the result of raising <var>base</var> to the power <var>exponent</var>.\n          \n          </p>\n          <ul>\n            <li>If <var>exponent</var> is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <var>exponent</var> is <emu-val>+0</emu-val>, the result is 1, even if <var>base</var> is <emu-val>NaN</emu-val>.</li>\n            <li>If <var>exponent</var> is <emu-val>-0</emu-val>, the result is 1, even if <var>base</var> is <emu-val>NaN</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>NaN</emu-val> and <var>exponent</var> is nonzero, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &gt; 1 and <var>exponent</var> is <emu-val>+&#8734;</emu-val>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &gt; 1 and <var>exponent</var> is <emu-val>-&#8734;</emu-val>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) is 1 and <var>exponent</var> is <emu-val>+&#8734;</emu-val>, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) is 1 and <var>exponent</var> is <emu-val>-&#8734;</emu-val>, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &lt; 1 and <var>exponent</var> is <emu-val>+&#8734;</emu-val>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &lt; 1 and <var>exponent</var> is <emu-val>-&#8734;</emu-val>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+&#8734;</emu-val> and <var>exponent</var> &gt; 0, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+&#8734;</emu-val> and <var>exponent</var> &lt; 0, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+0</emu-val> and <var>exponent</var> &gt; 0, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+0</emu-val> and <var>exponent</var> &lt; 0, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> &lt; 0 and <var>base</var> is finite and <var>exponent</var> is finite and <var>exponent</var> is not an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>NaN</emu-val>.</li>\n          </ul>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>The result of <var>base</var> <code>**</code> <var>exponent</var> when <var>base</var> is <emu-val>1</emu-val> or <emu-val>-1</emu-val> and <var>exponent</var> is <emu-val>+Infinity</emu-val> or <emu-val>-Infinity</emu-val> differs from <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The first edition of ECMAScript specified a result of <emu-val>NaN</emu-val> for this operation, whereas later versions of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> specified <emu-val>1</emu-val>. The historical ECMAScript behaviour is preserved for compatibility reasons.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-multiplicative-operators": {"num": "12.7", "title": "#sec-multiplicative-operators Multiplicative Operators", "html": "<emu-clause id=\"sec-multiplicative-operators\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-multiplicative-operators\">#sec-multiplicative-operators</span> Multiplicative Operators</h1>\n    <h2>Syntax</h2>\n    <emu-grammar type=\"definition\"><emu-production name=\"MultiplicativeExpression\" params=\"Yield, Await\" id=\"prod-MultiplicativeExpression\">\n    <emu-nt params=\"Yield, Await\"><a href=\"#prod-MultiplicativeExpression\">MultiplicativeExpression</a><emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"677909b0\"><emu-nt params=\"?Yield, ?Await\"><a href=\"#prod-ExponentiationExpression\">ExponentiationExpression</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>\n    <emu-rhs a=\"c0a3a33f\"><emu-nt params=\"?Yield, ?Await\"><a href=\"#prod-MultiplicativeExpression\">MultiplicativeExpression</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt><emu-nt params=\"?Yield, ?Await\"><a href=\"#prod-ExponentiationExpression\">ExponentiationExpression</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>\n</emu-production>\n<emu-production name=\"MultiplicativeOperator\" oneof=\"\" id=\"prod-MultiplicativeOperator\">\n    <emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt><emu-geq>:</emu-geq><emu-oneof>one of</emu-oneof><emu-rhs><emu-t>*</emu-t><emu-t>/</emu-t><emu-t>%</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n\n    <div id=\"excluded-sec-multiplicative-operators-static-semantics-isfunctiondefinition\"><h1><span class=\"secnum\">12.7.1</span>#sec-multiplicative-operators-static-semantics-isfunctiondefinition Static Semantics: IsFunctionDefinition</h1>...</div><div id=\"excluded-sec-multiplicative-operators-static-semantics-assignmenttargettype\"><h1><span class=\"secnum\">12.7.2</span>#sec-multiplicative-operators-static-semantics-assignmenttargettype Static Semantics: AssignmentTargetType</h1>...</div><div id=\"excluded-sec-multiplicative-operators-runtime-semantics-evaluation\"><h1><span class=\"secnum\">12.7.3</span>#sec-multiplicative-operators-runtime-semantics-evaluation Runtime Semantics: Evaluation</h1>...</div></emu-clause>\n\n  "}, "sec-numeric-types-number-remainder": {"num": "6.1.6.1.6", "title": "#sec-numeric-types-number-remainder Number::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-number-remainder\" oldids=\"sec-applying-the-mod-operator\">\n          <span id=\"sec-applying-the-mod-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-remainder\">#sec-numeric-types-number-remainder</span> Number::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The <code>%</code> <emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt> yields the remainder of its operands from an implied division; <var>n</var> is the dividend and <var>d</var> is the divisor.</p>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.</p>\n          </div></emu-note>\n          <p>The result of a floating-point remainder operation as computed by the <code>%</code> operator is not the same as the &#8220;remainder&#8221; operation defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> &#8220;remainder&#8221; operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> remainder operator. Instead the ECMAScript language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the Java <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> remainder operator; this may be compared with the C library function fmod.</p>\n          <p>The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sign of the result equals the sign of the dividend.\n            \n            </li>\n            <li>\n              If the dividend is an infinity, or the divisor is a zero, or both, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n            \n            </li>\n            <li>\n              If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity, nor a zero, nor <emu-val>NaN</emu-val> is involved, the floating-point remainder <var>r</var> from a dividend <var>n</var> and a divisor <var>d</var> is defined by the mathematical relation <var>r</var> = <var>n</var> - (<var>d</var> &#215; <var>q</var>) where <var>q</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is negative only if <var>n</var>/<var>d</var> is negative and positive only if <var>n</var>/<var>d</var> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <var>n</var> and <var>d</var>. <var>r</var> is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode.\n            \n            </li>\n          </ul>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseXOR": {"num": "6.1.6.1.18", "title": "#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseXOR\">#sec-numeric-types-number-bitwiseXOR</span> Number::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-unaryMinus": {"num": "6.1.6.1.1", "title": "#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unaryMinus\">#sec-numeric-types-number-unaryMinus</span> Number::unaryMinus ( <var>x</var> )</h1>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>Return the result of negating <var>x</var>; that is, compute a Number with the same magnitude but opposite sign.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseAND": {"num": "6.1.6.2.20", "title": "#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseAND\">#sec-numeric-types-bigint-bitwiseAND</span> BigInt::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"&amp;\"</emu-val>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-add": {"num": "6.1.6.1.7", "title": "#sec-numeric-types-number-add Number::add ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-add\" oldids=\"sec-applying-the-additive-operators-to-numbers\">\n          <span id=\"sec-applying-the-additive-operators-to-numbers\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-add\">#sec-numeric-types-number-add</span> Number::add ( <var>x</var>, <var>y</var> )</h1>\n          <p>The <code>+</code> operator performs addition when applied to <var>x</var> and <var>y</var>, producing the sum of the operands.</p>\n          <p>Addition is a commutative operation, but not always associative.</p>\n          <p>The result of an addition is determined using the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sum of two infinities of opposite sign is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sum of two infinities of the same sign is the infinity of that sign.\n            \n            </li>\n            <li>\n              The sum of an infinity and a finite value is equal to the infinite operand.\n            \n            </li>\n            <li>\n              The sum of two negative zeroes is <emu-val>-0</emu-val>. The sum of two positive zeroes, or of two zeroes of opposite sign, is <emu-val>+0</emu-val>.\n            \n            </li>\n            <li>\n              The sum of a zero and a nonzero finite value is equal to the nonzero operand.\n            \n            </li>\n            <li>\n              The sum of two nonzero finite values of the same magnitude and opposite sign is <emu-val>+0</emu-val>.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity, nor a zero, nor <emu-val>NaN</emu-val> is involved, and the operands have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>.\n            \n            </li>\n          </ul>\n        </emu-clause>\n\n        "}}, "figData": {}}, "to": {"secList": ["sec-numeric-types-number-unsignedRightShift", "sec-numeric-types-bigint-exponentiate", "sec-numeric-types-bigint-bitwiseXOR", "sec-numeric-types-number-leftShift", "sec-numeric-types-number-sameValueZero", "sec-numeric-types-number-bitwiseAND", "sec-numeric-types-bigint-remainder", "sec-numeric-types-number-sameValue", "sec-numeric-types-number-bitwiseNOT", "sec-numeric-types-bigint-bitwiseOR", "sec-numeric-types-number-bitwiseOR", "sec-subtraction-operator-minus", "sec-numeric-types-number-lessThan", "sec-numeric-types-bigint-divide", "sec-numeric-types-number-subtract", "sec-numeric-types-number-multiply", "sec-numeric-types-number-signedRightShift", "sec-numeric-types-number-divide", "sec-numeric-types-number-equal", "sec-numeric-types-bigint-unaryMinus", "sec-numeric-types-number-exponentiate", "sec-multiplicative-operators", "sec-numeric-types-number-remainder", "sec-numeric-types-number-bitwiseXOR", "sec-numeric-types-number-unaryMinus", "sec-numeric-types-bigint-bitwiseAND", "sec-numeric-types-number-add"], "secData": {"sec-numeric-types-number-unsignedRightShift": {"num": "6.1.6.1.11", "title": "#sec-numeric-types-number-unsignedRightShift Number::unsignedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-unsignedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unsignedRightShift\">#sec-numeric-types-number-unsignedRightShift</span> Number::unsignedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::unsignedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be the result of masking out all but the least significant 5 bits of <var>rnum</var>, that is, compute <var>rnum</var> &amp; 0x1F.</li><li>Return the result of performing a zero-filling right shift of <var>lnum</var> by <var>shiftCount</var> bits. Vacated bits are filled with zero. The result is an unsigned 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-exponentiate": {"num": "6.1.6.2.3", "title": "#sec-numeric-types-bigint-exponentiate BigInt::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-bigint-exponentiate\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-exponentiate\">#sec-numeric-types-bigint-exponentiate</span> BigInt::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>The abstract operation BigInt::exponentiate takes arguments <var>base</var> (a BigInt) and <var>exponent</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>exponent</var> &lt; <emu-val>0n</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>base</var> is <emu-val>0n</emu-val> and <var>exponent</var> is <emu-val>0n</emu-val>, return <emu-val>1n</emu-val>.</li><li>Return the BigInt value that represents the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>base</var> raised to the power <var>exponent</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseXOR": {"num": "6.1.6.2.21", "title": "#sec-numeric-types-bigint-bitwiseXOR BigInt::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseXOR\">#sec-numeric-types-bigint-bitwiseXOR</span> BigInt::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseXOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"^\"</emu-val>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-leftShift": {"num": "6.1.6.1.9", "title": "#sec-numeric-types-number-leftShift Number::leftShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-leftShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-leftShift\">#sec-numeric-types-number-leftShift</span> Number::leftShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::leftShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be the result of masking out all but the least significant 5 bits of <var>rnum</var>, that is, compute <var>rnum</var> &amp; 0x1F.</li><li>Return the result of left shifting <var>lnum</var> by <var>shiftCount</var> bits. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-sameValueZero": {"num": "6.1.6.1.15", "title": "#sec-numeric-types-number-sameValueZero Number::sameValueZero ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValueZero\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValueZero\">#sec-numeric-types-number-sameValueZero</span> Number::sameValueZero ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::sameValueZero takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseAND": {"num": "6.1.6.1.17", "title": "#sec-numeric-types-number-bitwiseAND Number::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseAND\">#sec-numeric-types-number-bitwiseAND</span> Number::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseAND takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>&amp;</code>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-remainder": {"num": "6.1.6.2.6", "title": "#sec-numeric-types-bigint-remainder BigInt::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-bigint-remainder\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-remainder\">#sec-numeric-types-bigint-remainder</span> BigInt::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The abstract operation BigInt::remainder takes arguments <var>n</var> (a BigInt) and <var>d</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>d</var> is <emu-val>0n</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>If <var>n</var> is <emu-val>0n</emu-val>, return <emu-val>0n</emu-val>.</li><li>Let <var>r</var> be the BigInt defined by the mathematical relation <var>r</var> = <var>n</var> - (<var>d</var> &#215; <var>q</var>) where <var>q</var> is a BigInt that is negative only if <var>n</var>/<var>d</var> is negative and positive only if <var>n</var>/<var>d</var> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <var>n</var> and <var>d</var>.</li><li>Return <var>r</var>.\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">The sign of the result equals the sign of the dividend.</div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-sameValue": {"num": "6.1.6.1.14", "title": "#sec-numeric-types-number-sameValue Number::sameValue ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-sameValue\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-sameValue\">#sec-numeric-types-number-sameValue</span> Number::sameValue ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::sameValue takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val> and <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseNOT": {"num": "6.1.6.1.2", "title": "#sec-numeric-types-number-bitwiseNOT Number::bitwiseNOT ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseNOT\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseNOT\">#sec-numeric-types-number-bitwiseNOT</span> Number::bitwiseNOT ( <var>x</var> )</h1>\n          <p>The abstract operation Number::bitwiseNOT takes argument <var>x</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>oldValue</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Return the result of applying bitwise complement to <var>oldValue</var>. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseOR": {"num": "6.1.6.2.22", "title": "#sec-numeric-types-bigint-bitwiseOR BigInt::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseOR\">#sec-numeric-types-bigint-bitwiseOR</span> BigInt::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseOR takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"|\"</emu-val>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseOR": {"num": "6.1.6.1.19", "title": "#sec-numeric-types-number-bitwiseOR Number::bitwiseOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseOR\">#sec-numeric-types-number-bitwiseOR</span> Number::bitwiseOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseOR takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>|</code>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-subtraction-operator-minus": {"num": "12.8.4", "title": "#sec-subtraction-operator-minus The Subtraction Operator ( - )", "html": "<emu-clause id=\"sec-subtraction-operator-minus\">\n      <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-subtraction-operator-minus\">#sec-subtraction-operator-minus</span> The Subtraction Operator ( <code>-</code> )</h1>\n      <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n        <p>The <code>-</code> operator performs subtraction, producing the difference of its operands.</p>\n      </div></emu-note>\n\n      <div id=\"excluded-sec-subtraction-operator-minus-runtime-semantics-evaluation\"><h1><span class=\"secnum\">12.8.4.1</span>#sec-subtraction-operator-minus-runtime-semantics-evaluation Runtime Semantics: Evaluation</h1>...</div></emu-clause>\n  "}, "sec-numeric-types-number-lessThan": {"num": "6.1.6.1.12", "title": "#sec-numeric-types-number-lessThan Number::lessThan ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-lessThan\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-lessThan\">#sec-numeric-types-number-lessThan</span> Number::lessThan ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::lessThan takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>undefined</emu-val>.</li><li>If <var>x</var> and <var>y</var> are the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>+&#8734;</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>+&#8734;</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>y</var> is <emu-val>-&#8734;</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is <emu-val>-&#8734;</emu-val>, return <emu-val>true</emu-val>.</li><li>If the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>x</var> is less than the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>y</var>&#8212;note that these mathematical values are both finite and not both zero&#8212;return <emu-val>true</emu-val>. Otherwise, return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-divide": {"num": "6.1.6.2.5", "title": "#sec-numeric-types-bigint-divide BigInt::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-divide\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-divide\">#sec-numeric-types-bigint-divide</span> BigInt::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::divide takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>y</var> is <emu-val>0n</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>quotient</var> be the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of <var>x</var> divided by <var>y</var>.</li><li>Return the BigInt value that represents <var>quotient</var> rounded towards 0 to the next integral value.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-subtract": {"num": "6.1.6.1.8", "title": "#sec-numeric-types-number-subtract Number::subtract ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-subtract\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-subtract\">#sec-numeric-types-number-subtract</span> Number::subtract ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::subtract takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs subtraction, producing the difference of its operands; <var>x</var> is the minuend and <var>y</var> is the subtrahend. It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return Number::add(<var>x</var>, Number::unaryMinus(<var>y</var>)).\n          </li></ol></emu-alg>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>It is always the case that <code>x - y</code> produces the same result as <code>x + (-y)</code>.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-multiply": {"num": "6.1.6.1.4", "title": "#sec-numeric-types-number-multiply Number::multiply ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-multiply\" oldids=\"sec-applying-the-mul-operator\">\n          <span id=\"sec-applying-the-mul-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-multiply\">#sec-numeric-types-number-multiply</span> Number::multiply ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::multiply takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs multiplication, producing the product of <var>x</var> and <var>y</var>, as determined by the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n            \n            </li>\n            <li>\n              Multiplication of an infinity by a zero results in <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity nor <emu-val>NaN</emu-val> is involved, the product is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>.\n            \n            </li>\n          </ul>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>Finite-precision multiplication is commutative, but not always associative.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-signedRightShift": {"num": "6.1.6.1.10", "title": "#sec-numeric-types-number-signedRightShift Number::signedRightShift ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-signedRightShift\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-signedRightShift\">#sec-numeric-types-number-signedRightShift</span> Number::signedRightShift ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::signedRightShift takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Let <var>lnum</var> be !&#160;<emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>(<var>x</var>).</li><li>Let <var>rnum</var> be !&#160;<emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>(<var>y</var>).</li><li>Let <var>shiftCount</var> be the result of masking out all but the least significant 5 bits of <var>rnum</var>, that is, compute <var>rnum</var> &amp; 0x1F.</li><li>Return the result of performing a sign-extending right shift of <var>lnum</var> by <var>shiftCount</var> bits. The most significant bit is propagated. The result is a signed 32-bit <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-divide": {"num": "6.1.6.1.5", "title": "#sec-numeric-types-number-divide Number::divide ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-divide\" oldids=\"sec-applying-the-div-operator\">\n          <span id=\"sec-applying-the-div-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-divide\">#sec-numeric-types-number-divide</span> Number::divide ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::divide takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs division, producing the quotient of <var>x</var> and <var>y</var>; <var>x</var> is the dividend and <var>y</var> is the divisor. The result is determined by the specification of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n            \n            </li>\n            <li>\n              Division of an infinity by an infinity results in <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of a zero by a zero results in <emu-val>NaN</emu-val>; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n            \n            </li>\n            <li>\n              Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity, nor a zero, nor <emu-val>NaN</emu-val> is involved, the quotient is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode. If the magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of gradual underflow as defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>.\n            \n            </li>\n          </ul>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-equal": {"num": "6.1.6.1.13", "title": "#sec-numeric-types-number-equal Number::equal ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-equal\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-equal\">#sec-numeric-types-number-equal</span> Number::equal ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::equal takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>y</var> is <emu-val>NaN</emu-val>, return <emu-val>false</emu-val>.</li><li>If <var>x</var> is the same <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> as <var>y</var>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>+0</emu-val> and <var>y</var> is <emu-val>-0</emu-val>, return <emu-val>true</emu-val>.</li><li>If <var>x</var> is <emu-val>-0</emu-val> and <var>y</var> is <emu-val>+0</emu-val>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-unaryMinus": {"num": "6.1.6.2.1", "title": "#sec-numeric-types-bigint-unaryMinus BigInt::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-bigint-unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-unaryMinus\">#sec-numeric-types-bigint-unaryMinus</span> BigInt::unaryMinus ( <var>x</var> )</h1>\n          <p>The abstract operation BigInt::unaryMinus takes argument <var>x</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>0n</emu-val>, return <emu-val>0n</emu-val>.</li><li>Return the BigInt value that represents the <emu-xref href=\"#mathematical-value\"><a href=\"#mathematical-value\">mathematical value</a></emu-xref> of negating <var>x</var>.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-exponentiate": {"num": "6.1.6.1.3", "title": "#sec-numeric-types-number-exponentiate Number::exponentiate ( base, exponent )", "html": "<emu-clause id=\"sec-numeric-types-number-exponentiate\" oldids=\"sec-applying-the-exp-operator\">\n          <span id=\"sec-applying-the-exp-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-exponentiate\">#sec-numeric-types-number-exponentiate</span> Number::exponentiate ( <var>base</var>, <var>exponent</var> )</h1>\n          <p>The abstract operation Number::exponentiate takes arguments <var>base</var> (a Number) and <var>exponent</var> (a Number). It returns an implementation-dependent approximation of the result of raising <var>base</var> to the power <var>exponent</var>, subject to the following requirements:</p>\n          <ul>\n            <li>If <var>exponent</var> is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <var>exponent</var> is <emu-val>+0</emu-val>, the result is 1, even if <var>base</var> is <emu-val>NaN</emu-val>.</li>\n            <li>If <var>exponent</var> is <emu-val>-0</emu-val>, the result is 1, even if <var>base</var> is <emu-val>NaN</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>NaN</emu-val> and <var>exponent</var> is nonzero, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &gt; 1 and <var>exponent</var> is <emu-val>+&#8734;</emu-val>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &gt; 1 and <var>exponent</var> is <emu-val>-&#8734;</emu-val>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) is 1 and <var>exponent</var> is <emu-val>+&#8734;</emu-val>, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) is 1 and <var>exponent</var> is <emu-val>-&#8734;</emu-val>, the result is <emu-val>NaN</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &lt; 1 and <var>exponent</var> is <emu-val>+&#8734;</emu-val>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <emu-xref aoid=\"abs\"><a href=\"#eqn-abs\">abs</a></emu-xref>(<var>base</var>) &lt; 1 and <var>exponent</var> is <emu-val>-&#8734;</emu-val>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+&#8734;</emu-val> and <var>exponent</var> &gt; 0, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+&#8734;</emu-val> and <var>exponent</var> &lt; 0, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-&#8734;</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+0</emu-val> and <var>exponent</var> &gt; 0, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>+0</emu-val> and <var>exponent</var> &lt; 0, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &gt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+0</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>-&#8734;</emu-val>.</li>\n            <li>If <var>base</var> is <emu-val>-0</emu-val> and <var>exponent</var> &lt; 0 and <var>exponent</var> is not an odd <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>+&#8734;</emu-val>.</li>\n            <li>If <var>base</var> &lt; 0 and <var>base</var> is finite and <var>exponent</var> is finite and <var>exponent</var> is not an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>, the result is <emu-val>NaN</emu-val>.</li>\n          </ul>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>The result of <var>base</var> <code>**</code> <var>exponent</var> when <var>base</var> is <emu-val>1</emu-val> or <emu-val>-1</emu-val> and <var>exponent</var> is <emu-val>+Infinity</emu-val> or <emu-val>-Infinity</emu-val> differs from <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The first edition of ECMAScript specified a result of <emu-val>NaN</emu-val> for this operation, whereas later versions of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> specified <emu-val>1</emu-val>. The historical ECMAScript behaviour is preserved for compatibility reasons.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}, "sec-multiplicative-operators": {"num": "12.7", "title": "#sec-multiplicative-operators Multiplicative Operators", "html": "<emu-clause id=\"sec-multiplicative-operators\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-multiplicative-operators\">#sec-multiplicative-operators</span> Multiplicative Operators</h1>\n    <h2>Syntax</h2>\n    <emu-grammar type=\"definition\"><emu-production name=\"MultiplicativeExpression\" params=\"Yield, Await\" id=\"prod-MultiplicativeExpression\">\n    <emu-nt params=\"Yield, Await\"><a href=\"#prod-MultiplicativeExpression\">MultiplicativeExpression</a><emu-mods><emu-params>[Yield, Await]</emu-params></emu-mods></emu-nt><emu-geq>:</emu-geq><emu-rhs a=\"677909b0\"><emu-nt params=\"?Yield, ?Await\"><a href=\"#prod-ExponentiationExpression\">ExponentiationExpression</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>\n    <emu-rhs a=\"c0a3a33f\"><emu-nt params=\"?Yield, ?Await\"><a href=\"#prod-MultiplicativeExpression\">MultiplicativeExpression</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt><emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt><emu-nt params=\"?Yield, ?Await\"><a href=\"#prod-ExponentiationExpression\">ExponentiationExpression</a><emu-mods><emu-params>[?Yield, ?Await]</emu-params></emu-mods></emu-nt></emu-rhs>\n</emu-production>\n<emu-production name=\"MultiplicativeOperator\" oneof=\"\" id=\"prod-MultiplicativeOperator\">\n    <emu-nt><a href=\"#prod-MultiplicativeOperator\">MultiplicativeOperator</a></emu-nt><emu-geq>:</emu-geq><emu-oneof>one of</emu-oneof><emu-rhs><emu-t>*</emu-t><emu-t>/</emu-t><emu-t>%</emu-t></emu-rhs>\n</emu-production></emu-grammar>\n    <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n      <ul>\n        <li>The <code>*</code> operator performs multiplication, producing the product of its operands.</li>\n        <li>The <code>/</code> operator performs division, producing the quotient of its operands.</li>\n        <li>The <code>%</code> operator yields the remainder of its operands from an implied division.</li>\n      </ul>\n    </div></emu-note>\n\n    <div id=\"excluded-sec-multiplicative-operators-static-semantics-isfunctiondefinition\"><h1><span class=\"secnum\">12.7.1</span>#sec-multiplicative-operators-static-semantics-isfunctiondefinition Static Semantics: IsFunctionDefinition</h1>...</div><div id=\"excluded-sec-multiplicative-operators-static-semantics-assignmenttargettype\"><h1><span class=\"secnum\">12.7.2</span>#sec-multiplicative-operators-static-semantics-assignmenttargettype Static Semantics: AssignmentTargetType</h1>...</div><div id=\"excluded-sec-multiplicative-operators-runtime-semantics-evaluation\"><h1><span class=\"secnum\">12.7.3</span>#sec-multiplicative-operators-runtime-semantics-evaluation Runtime Semantics: Evaluation</h1>...</div></emu-clause>\n\n  "}, "sec-numeric-types-number-remainder": {"num": "6.1.6.1.6", "title": "#sec-numeric-types-number-remainder Number::remainder ( n, d )", "html": "<emu-clause id=\"sec-numeric-types-number-remainder\" oldids=\"sec-applying-the-mod-operator\">\n          <span id=\"sec-applying-the-mod-operator\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-remainder\">#sec-numeric-types-number-remainder</span> Number::remainder ( <var>n</var>, <var>d</var> )</h1>\n          <p>The abstract operation Number::remainder takes arguments <var>n</var> (a Number) and <var>d</var> (a Number). It yields the remainder of its operands from an implied division; <var>n</var> is the dividend and <var>d</var> is the divisor.</p>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.</p>\n          </div></emu-note>\n          <p>The result of a floating-point remainder operation as computed by the <code>%</code> operator is not the same as the &#8220;remainder&#8221; operation defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>. The <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> &#8220;remainder&#8221; operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> remainder operator. Instead the ECMAScript language defines <code>%</code> on floating-point operations to behave in a manner analogous to that of the Java <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> remainder operator; this may be compared with the C library function fmod.</p>\n          <p>The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sign of the result equals the sign of the dividend.\n            \n            </li>\n            <li>\n              If the dividend is an infinity, or the divisor is a zero, or both, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              If the dividend is finite and the divisor is an infinity, the result equals the dividend.\n            \n            </li>\n            <li>\n              If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity, nor a zero, nor <emu-val>NaN</emu-val> is involved, the floating-point remainder <var>r</var> from a dividend <var>n</var> and a divisor <var>d</var> is defined by the mathematical relation <var>r</var> = <var>n</var> - (<var>d</var> &#215; <var>q</var>) where <var>q</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> that is negative only if <var>n</var>/<var>d</var> is negative and positive only if <var>n</var>/<var>d</var> is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of <var>n</var> and <var>d</var>. <var>r</var> is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode.\n            \n            </li>\n          </ul>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-bitwiseXOR": {"num": "6.1.6.1.18", "title": "#sec-numeric-types-number-bitwiseXOR Number::bitwiseXOR ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-bitwiseXOR\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-bitwiseXOR\">#sec-numeric-types-number-bitwiseXOR</span> Number::bitwiseXOR ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::bitwiseXOR takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"NumberBitwiseOp\"><a href=\"#sec-numberbitwiseop\">NumberBitwiseOp</a></emu-xref>(<code>^</code>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-unaryMinus": {"num": "6.1.6.1.1", "title": "#sec-numeric-types-number-unaryMinus Number::unaryMinus ( x )", "html": "<emu-clause id=\"sec-numeric-types-number-unaryMinus\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-unaryMinus\">#sec-numeric-types-number-unaryMinus</span> Number::unaryMinus ( <var>x</var> )</h1>\n          <p>The abstract operation Number::unaryMinus takes argument <var>x</var> (a Number). It performs the following steps when called:</p>\n          <emu-alg><ol><li>If <var>x</var> is <emu-val>NaN</emu-val>, return <emu-val>NaN</emu-val>.</li><li>Return the result of negating <var>x</var>; that is, compute a Number with the same magnitude but opposite sign.\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-bigint-bitwiseAND": {"num": "6.1.6.2.20", "title": "#sec-numeric-types-bigint-bitwiseAND BigInt::bitwiseAND ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-bigint-bitwiseAND\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-bigint-bitwiseAND\">#sec-numeric-types-bigint-bitwiseAND</span> BigInt::bitwiseAND ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation BigInt::bitwiseAND takes arguments <var>x</var> (a BigInt) and <var>y</var> (a BigInt). It performs the following steps when called:</p>\n          <emu-alg><ol><li>Return <emu-xref aoid=\"BigIntBitwiseOp\"><a href=\"#sec-bigintbitwiseop\">BigIntBitwiseOp</a></emu-xref>(<emu-val>\"&amp;\"</emu-val>, <var>x</var>, <var>y</var>).\n          </li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-numeric-types-number-add": {"num": "6.1.6.1.7", "title": "#sec-numeric-types-number-add Number::add ( x, y )", "html": "<emu-clause id=\"sec-numeric-types-number-add\" oldids=\"sec-applying-the-additive-operators-to-numbers\">\n          <span id=\"sec-applying-the-additive-operators-to-numbers\"></span><h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numeric-types-number-add\">#sec-numeric-types-number-add</span> Number::add ( <var>x</var>, <var>y</var> )</h1>\n          <p>The abstract operation Number::add takes arguments <var>x</var> (a Number) and <var>y</var> (a Number). It performs addition, producing the sum of <var>x</var> and <var>y</var> as determined using the rules of <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary double-precision arithmetic:</p>\n          <ul>\n            <li>\n              If either operand is <emu-val>NaN</emu-val>, the result is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sum of two infinities of opposite sign is <emu-val>NaN</emu-val>.\n            \n            </li>\n            <li>\n              The sum of two infinities of the same sign is the infinity of that sign.\n            \n            </li>\n            <li>\n              The sum of an infinity and a finite value is equal to the infinite operand.\n            \n            </li>\n            <li>\n              The sum of two negative zeroes is <emu-val>-0</emu-val>. The sum of two positive zeroes, or of two zeroes of opposite sign, is <emu-val>+0</emu-val>.\n            \n            </li>\n            <li>\n              The sum of a zero and a nonzero finite value is equal to the nonzero operand.\n            \n            </li>\n            <li>\n              The sum of two nonzero finite values of the same magnitude and opposite sign is <emu-val>+0</emu-val>.\n            \n            </li>\n            <li>\n              In the remaining cases, where neither an infinity, nor a zero, nor <emu-val>NaN</emu-val> is involved, and the operands have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> roundTiesToEven mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref>.\n            \n            </li>\n          </ul>\n          <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n            <p>Finite-precision addition is commutative, but not always associative.</p>\n          </div></emu-note>\n        </emu-clause>\n\n        "}}, "figData": {}}}