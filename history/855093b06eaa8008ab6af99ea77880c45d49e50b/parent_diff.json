{"from": {"secList": ["sec-promise.all", "sec-promise.race", "sec-performpromiserace", "sec-performpromiseallsettled", "sec-promise.allsettled", "sec-performpromiseall"], "secData": {"sec-promise.all": {"num": "25.6.4.1", "title": "#sec-promise.all Promise.all ( iterable )", "html": "<emu-clause id=\"sec-promise.all\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.all\">#sec-promise.all</span> Promise.all ( <var>iterable</var> )</h1>\n        <p>The <code>all</code> function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>promiseCapability</var> be ?&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<var>C</var>).</li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>iterable</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>iteratorRecord</var>, <var>promiseCapability</var>).</li><li>Let <var>result</var> be <emu-xref aoid=\"PerformPromiseAll\"><a href=\"#sec-performpromiseall\">PerformPromiseAll</a></emu-xref>(<var>iteratorRecord</var>, <var>C</var>, <var>promiseCapability</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, set <var>result</var> to <emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>result</var>, <var>promiseCapability</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        <p>This function is the <dfn>%Promise_all%</dfn> intrinsic object.</p>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The <code>all</code> function requires its <emu-val>this</emu-val> value to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-performpromiseall\"><h1><span class=\"secnum\">25.6.4.1.1</span>#sec-performpromiseall Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability )</h1>...</div><div id=\"excluded-sec-promise.all-resolve-element-functions\"><h1><span class=\"secnum\">25.6.4.1.2</span>#sec-promise.all-resolve-element-functions Promise.all Resolve Element Functions</h1>...</div></emu-clause>\n\n      "}, "sec-promise.race": {"num": "25.6.4.4", "title": "#sec-promise.race Promise.race ( iterable )", "html": "<emu-clause id=\"sec-promise.race\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.race\">#sec-promise.race</span> Promise.race ( <var>iterable</var> )</h1>\n        <p>The <code>race</code> function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed <var>iterable</var> to promises as it runs this algorithm.</p>\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>promiseCapability</var> be ?&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<var>C</var>).</li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>iterable</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>iteratorRecord</var>, <var>promiseCapability</var>).</li><li>Let <var>result</var> be <emu-xref aoid=\"PerformPromiseRace\"><a href=\"#sec-performpromiserace\">PerformPromiseRace</a></emu-xref>(<var>iteratorRecord</var>, <var>C</var>, <var>promiseCapability</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, set <var>result</var> to <emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>result</var>, <var>promiseCapability</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>If the <var>iterable</var> argument is empty or if none of the promises in <var>iterable</var> ever settle then the pending promise returned by this method will never be settled.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>race</code> function expects its <emu-val>this</emu-val> value to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>. It also expects that its <emu-val>this</emu-val> value provides a <code>resolve</code> method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-performpromiserace\"><h1><span class=\"secnum\">25.6.4.4.1</span>#sec-performpromiserace Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability )</h1>...</div></emu-clause>\n\n      "}, "sec-performpromiserace": {"num": "25.6.4.4.1", "title": "#sec-performpromiserace Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability )", "html": "<emu-clause id=\"sec-performpromiserace\" aoid=\"PerformPromiseRace\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiserace\">#sec-performpromiserace</span> Runtime Semantics: PerformPromiseRace ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var> )</h1>\n          <p>The abstract operation PerformPromiseRace takes arguments <var>iteratorRecord</var>, <var>constructor</var>, and <var>resultCapability</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>promiseResolve</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>constructor</var>, <emu-val>\"resolve\"</emu-val>).</li><li>If !&#160;<emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resultCapability</var>.[[Resolve]], <var>resultCapability</var>.[[Reject]] &#187;).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-performpromiseallsettled": {"num": "25.6.4.2.1", "title": "#sec-performpromiseallsettled Runtime Semantics: PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability )", "html": "<emu-clause id=\"sec-performpromiseallsettled\" aoid=\"PerformPromiseAllSettled\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseallsettled\">#sec-performpromiseallsettled</span> Runtime Semantics: PerformPromiseAllSettled ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var> )</h1>\n          <p>The abstract operation PerformPromiseAllSettled takes arguments <var>iteratorRecord</var>, <var>constructor</var>, and <var>resultCapability</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: !&#160;<emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Let <var>promiseResolve</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>constructor</var>, <emu-val>\"resolve\"</emu-val>).</li><li>If <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-resolve-element-functions\"><code>Promise.allSettled</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Let <var>alreadyCalled</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Let <var>rejectSteps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-reject-element-functions\"><code>Promise.allSettled</code> Reject Element Functions</a></emu-xref>.</li><li>Let <var>rejectElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectSteps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>rejectElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>rejectElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>rejectElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>rejectElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>rejectElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>rejectElement</var> &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-promise.allsettled": {"num": "25.6.4.2", "title": "#sec-promise.allsettled Promise.allSettled ( iterable )", "html": "<emu-clause id=\"sec-promise.allsettled\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.allsettled\">#sec-promise.allsettled</span> Promise.allSettled ( <var>iterable</var> )</h1>\n        <p>The <code>allSettled</code> function returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>promiseCapability</var> be ?&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<var>C</var>).</li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>iterable</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>iteratorRecord</var>, <var>promiseCapability</var>).</li><li>Let <var>result</var> be <emu-xref aoid=\"PerformPromiseAllSettled\"><a href=\"#sec-performpromiseallsettled\">PerformPromiseAllSettled</a></emu-xref>(<var>iteratorRecord</var>, <var>C</var>, <var>promiseCapability</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, set <var>result</var> to <emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>result</var>, <var>promiseCapability</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The <code>allSettled</code> function requires its <emu-val>this</emu-val> value to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-performpromiseallsettled\"><h1><span class=\"secnum\">25.6.4.2.1</span>#sec-performpromiseallsettled Runtime Semantics: PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability )</h1>...</div><div id=\"excluded-sec-promise.allsettled-resolve-element-functions\"><h1><span class=\"secnum\">25.6.4.2.2</span>#sec-promise.allsettled-resolve-element-functions Promise.allSettled Resolve Element Functions</h1>...</div><div id=\"excluded-sec-promise.allsettled-reject-element-functions\"><h1><span class=\"secnum\">25.6.4.2.3</span>#sec-promise.allsettled-reject-element-functions Promise.allSettled Reject Element Functions</h1>...</div></emu-clause>\n\n      "}, "sec-performpromiseall": {"num": "25.6.4.1.1", "title": "#sec-performpromiseall Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability )", "html": "<emu-clause id=\"sec-performpromiseall\" aoid=\"PerformPromiseAll\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseall\">#sec-performpromiseall</span> Runtime Semantics: PerformPromiseAll ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var> )</h1>\n          <p>The abstract operation PerformPromiseAll takes arguments <var>iteratorRecord</var>, <var>constructor</var>, and <var>resultCapability</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>promiseResolve</var> be ?&#160;<emu-xref aoid=\"Get\"><a href=\"#sec-get-o-p\">Get</a></emu-xref>(<var>constructor</var>, <emu-val>\"resolve\"</emu-val>).</li><li>If !&#160;<emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.all-resolve-element-functions\"><code>Promise.all</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>resultCapability</var>.[[Reject]] &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}, "to": {"secList": ["sec-promise.all", "sec-promise.race", "sec-performpromiserace", "sec-performpromiseallsettled", "sec-promise.allsettled", "sec-performpromiseall"], "secData": {"sec-promise.all": {"num": "25.6.4.1", "title": "#sec-promise.all Promise.all ( iterable )", "html": "<emu-clause id=\"sec-promise.all\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.all\">#sec-promise.all</span> Promise.all ( <var>iterable</var> )</h1>\n        <p>The <code>all</code> function returns a new promise which is fulfilled with an array of fulfillment values for the passed promises, or rejects with the reason of the first passed promise that rejects. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>promiseCapability</var> be ?&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<var>C</var>).</li><li>Let <var>promiseResolve</var> be <emu-xref aoid=\"GetPromiseResolve\"><a href=\"#sec-getpromiseresolve\">GetPromiseResolve</a></emu-xref>(<var>C</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>promiseResolve</var>, <var>promiseCapability</var>).</li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>iterable</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>iteratorRecord</var>, <var>promiseCapability</var>).</li><li>Let <var>result</var> be <emu-xref aoid=\"PerformPromiseAll\"><a href=\"#sec-performpromiseall\">PerformPromiseAll</a></emu-xref>(<var>iteratorRecord</var>, <var>C</var>, <var>promiseCapability</var>, <var>promiseResolve</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, set <var>result</var> to <emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>result</var>, <var>promiseCapability</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        <p>This function is the <dfn>%Promise_all%</dfn> intrinsic object.</p>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The <code>all</code> function requires its <emu-val>this</emu-val> value to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-getpromiseresolve\"><h1><span class=\"secnum\">25.6.4.1.1</span>#sec-getpromiseresolve Runtime Semantics: GetPromiseResolve ( promiseConstructor )</h1>...</div><div id=\"excluded-sec-performpromiseall\"><h1><span class=\"secnum\">25.6.4.1.2</span>#sec-performpromiseall Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability, promiseResolve )</h1>...</div><div id=\"excluded-sec-promise.all-resolve-element-functions\"><h1><span class=\"secnum\">25.6.4.1.3</span>#sec-promise.all-resolve-element-functions Promise.all Resolve Element Functions</h1>...</div></emu-clause>\n\n      "}, "sec-promise.race": {"num": "25.6.4.4", "title": "#sec-promise.race Promise.race ( iterable )", "html": "<emu-clause id=\"sec-promise.race\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.race\">#sec-promise.race</span> Promise.race ( <var>iterable</var> )</h1>\n        <p>The <code>race</code> function returns a new promise which is settled in the same way as the first passed promise to settle. It resolves all elements of the passed <var>iterable</var> to promises as it runs this algorithm.</p>\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>promiseCapability</var> be ?&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<var>C</var>).</li><li>Let <var>promiseResolve</var> be <emu-xref aoid=\"GetPromiseResolve\"><a href=\"#sec-getpromiseresolve\">GetPromiseResolve</a></emu-xref>(<var>C</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>promiseResolve</var>, <var>promiseCapability</var>).</li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>iterable</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>iteratorRecord</var>, <var>promiseCapability</var>).</li><li>Let <var>result</var> be <emu-xref aoid=\"PerformPromiseRace\"><a href=\"#sec-performpromiserace\">PerformPromiseRace</a></emu-xref>(<var>iteratorRecord</var>, <var>C</var>, <var>promiseCapability</var>, <var>promiseResolve</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, set <var>result</var> to <emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>result</var>, <var>promiseCapability</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note 1</span><div class=\"note-contents\">\n          <p>If the <var>iterable</var> argument is empty or if none of the promises in <var>iterable</var> ever settle then the pending promise returned by this method will never be settled.</p>\n        </div></emu-note>\n        <emu-note><span class=\"note\">Note 2</span><div class=\"note-contents\">\n          <p>The <code>race</code> function expects its <emu-val>this</emu-val> value to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>. It also expects that its <emu-val>this</emu-val> value provides a <code>resolve</code> method.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-performpromiserace\"><h1><span class=\"secnum\">25.6.4.4.1</span>#sec-performpromiserace Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )</h1>...</div></emu-clause>\n\n      "}, "sec-performpromiserace": {"num": "25.6.4.4.1", "title": "#sec-performpromiserace Runtime Semantics: PerformPromiseRace ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiserace\" aoid=\"PerformPromiseRace\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiserace\">#sec-performpromiserace</span> Runtime Semantics: PerformPromiseRace ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseRace takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resultCapability</var>.[[Resolve]], <var>resultCapability</var>.[[Reject]] &#187;).</li></ol></li></ol></emu-alg>\n        </emu-clause>\n      "}, "sec-performpromiseallsettled": {"num": "25.6.4.2.1", "title": "#sec-performpromiseallsettled Runtime Semantics: PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiseallsettled\" aoid=\"PerformPromiseAllSettled\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseallsettled\">#sec-performpromiseallsettled</span> Runtime Semantics: PerformPromiseAllSettled ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseAllSettled takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: !&#160;<emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-resolve-element-functions\"><code>Promise.allSettled</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Let <var>alreadyCalled</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Let <var>rejectSteps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title=\"\"><a href=\"#sec-promise.allsettled-reject-element-functions\"><code>Promise.allSettled</code> Reject Element Functions</a></emu-xref>.</li><li>Let <var>rejectElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>rejectSteps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>rejectElement</var>.[[AlreadyCalled]] to <var>alreadyCalled</var>.</li><li>Set <var>rejectElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>rejectElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>rejectElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>rejectElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>rejectElement</var> &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}, "sec-promise.allsettled": {"num": "25.6.4.2", "title": "#sec-promise.allsettled Promise.allSettled ( iterable )", "html": "<emu-clause id=\"sec-promise.allsettled\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-promise.allsettled\">#sec-promise.allsettled</span> Promise.allSettled ( <var>iterable</var> )</h1>\n        <p>The <code>allSettled</code> function returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected. It resolves all elements of the passed iterable to promises as it runs this algorithm.</p>\n        <emu-alg><ol><li>Let <var>C</var> be the <emu-val>this</emu-val> value.</li><li>Let <var>promiseCapability</var> be ?&#160;<emu-xref aoid=\"NewPromiseCapability\"><a href=\"#sec-newpromisecapability\">NewPromiseCapability</a></emu-xref>(<var>C</var>).</li><li>Let <var>promiseResolve</var> be <emu-xref aoid=\"GetPromiseResolve\"><a href=\"#sec-getpromiseresolve\">GetPromiseResolve</a></emu-xref>(<var>C</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>promiseResolve</var>, <var>promiseCapability</var>).</li><li>Let <var>iteratorRecord</var> be <emu-xref aoid=\"GetIterator\"><a href=\"#sec-getiterator\">GetIterator</a></emu-xref>(<var>iterable</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>iteratorRecord</var>, <var>promiseCapability</var>).</li><li>Let <var>result</var> be <emu-xref aoid=\"PerformPromiseAllSettled\"><a href=\"#sec-performpromiseallsettled\">PerformPromiseAllSettled</a></emu-xref>(<var>iteratorRecord</var>, <var>C</var>, <var>promiseCapability</var>, <var>promiseResolve</var>).</li><li>If <var>result</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, then<ol><li>If <var>iteratorRecord</var>.[[Done]] is <emu-val>false</emu-val>, set <var>result</var> to <emu-xref aoid=\"IteratorClose\"><a href=\"#sec-iteratorclose\">IteratorClose</a></emu-xref>(<var>iteratorRecord</var>, <var>result</var>).</li><li><emu-xref aoid=\"IfAbruptRejectPromise\"><a href=\"#sec-ifabruptrejectpromise\">IfAbruptRejectPromise</a></emu-xref>(<var>result</var>, <var>promiseCapability</var>).</li></ol></li><li>Return <emu-xref aoid=\"Completion\"><a href=\"#sec-completion-record-specification-type\">Completion</a></emu-xref>(<var>result</var>).</li></ol></emu-alg>\n        <emu-note><span class=\"note\">Note</span><div class=\"note-contents\">\n          <p>The <code>allSettled</code> function requires its <emu-val>this</emu-val> value to be a <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> function that supports the parameter conventions of the Promise <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>.</p>\n        </div></emu-note>\n\n        <div id=\"excluded-sec-performpromiseallsettled\"><h1><span class=\"secnum\">25.6.4.2.1</span>#sec-performpromiseallsettled Runtime Semantics: PerformPromiseAllSettled ( iteratorRecord, constructor, resultCapability, promiseResolve )</h1>...</div><div id=\"excluded-sec-promise.allsettled-resolve-element-functions\"><h1><span class=\"secnum\">25.6.4.2.2</span>#sec-promise.allsettled-resolve-element-functions Promise.allSettled Resolve Element Functions</h1>...</div><div id=\"excluded-sec-promise.allsettled-reject-element-functions\"><h1><span class=\"secnum\">25.6.4.2.3</span>#sec-promise.allsettled-reject-element-functions Promise.allSettled Reject Element Functions</h1>...</div></emu-clause>\n\n      "}, "sec-performpromiseall": {"num": "25.6.4.1.2", "title": "#sec-performpromiseall Runtime Semantics: PerformPromiseAll ( iteratorRecord, constructor, resultCapability, promiseResolve )", "html": "<emu-clause id=\"sec-performpromiseall\" aoid=\"PerformPromiseAll\">\n          <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-performpromiseall\">#sec-performpromiseall</span> Runtime Semantics: PerformPromiseAll ( <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, <var>promiseResolve</var> )</h1>\n          <p>The abstract operation PerformPromiseAll takes arguments <var>iteratorRecord</var>, <var>constructor</var>, <var>resultCapability</var>, and <var>promiseResolve</var>. It performs the following steps when called:</p>\n          <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsConstructor\"><a href=\"#sec-isconstructor\">IsConstructor</a></emu-xref>(<var>constructor</var>) is <emu-val>true</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <var>resultCapability</var> is a PromiseCapability <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsCallable\"><a href=\"#sec-iscallable\">IsCallable</a></emu-xref>(<var>promiseResolve</var>) is <emu-val>true</emu-val>.</li><li>Let <var>values</var> be a new empty <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>.</li><li>Let <var>remainingElementsCount</var> be the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: 1 }.</li><li>Let <var>index</var> be 0.</li><li>Repeat,<ol><li>Let <var>next</var> be <emu-xref aoid=\"IteratorStep\"><a href=\"#sec-iteratorstep\">IteratorStep</a></emu-xref>(<var>iteratorRecord</var>).</li><li>If <var>next</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>next</var>).</li><li>If <var>next</var> is <emu-val>false</emu-val>, then<ol><li>Set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] - 1.</li><li>If <var>remainingElementsCount</var>.[[Value]] is 0, then<ol><li>Let <var>valuesArray</var> be !&#160;<emu-xref aoid=\"CreateArrayFromList\"><a href=\"#sec-createarrayfromlist\">CreateArrayFromList</a></emu-xref>(<var>values</var>).</li><li>Perform ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>resultCapability</var>.[[Resolve]], <emu-val>undefined</emu-val>, &#171; <var>valuesArray</var> &#187;).</li></ol></li><li>Return <var>resultCapability</var>.[[Promise]].</li></ol></li><li>Let <var>nextValue</var> be <emu-xref aoid=\"IteratorValue\"><a href=\"#sec-iteratorvalue\">IteratorValue</a></emu-xref>(<var>next</var>).</li><li>If <var>nextValue</var> is an <emu-xref href=\"#sec-completion-record-specification-type\"><a href=\"#sec-completion-record-specification-type\">abrupt completion</a></emu-xref>, set <var>iteratorRecord</var>.[[Done]] to <emu-val>true</emu-val>.</li><li><emu-xref aoid=\"ReturnIfAbrupt\"><a href=\"#sec-returnifabrupt\">ReturnIfAbrupt</a></emu-xref>(<var>nextValue</var>).</li><li>Append <emu-val>undefined</emu-val> to <var>values</var>.</li><li>Let <var>nextPromise</var> be ?&#160;<emu-xref aoid=\"Call\"><a href=\"#sec-call\">Call</a></emu-xref>(<var>promiseResolve</var>, <var>constructor</var>, &#171; <var>nextValue</var> &#187;).</li><li>Let <var>steps</var> be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title=\"\"><a href=\"#sec-promise.all-resolve-element-functions\"><code>Promise.all</code> Resolve Element Functions</a></emu-xref>.</li><li>Let <var>resolveElement</var> be !&#160;<emu-xref aoid=\"CreateBuiltinFunction\"><a href=\"#sec-createbuiltinfunction\">CreateBuiltinFunction</a></emu-xref>(<var>steps</var>, &#171; [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] &#187;).</li><li>Set <var>resolveElement</var>.[[AlreadyCalled]] to the <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">Record</a></emu-xref> { [[Value]]: <emu-val>false</emu-val> }.</li><li>Set <var>resolveElement</var>.[[Index]] to <var>index</var>.</li><li>Set <var>resolveElement</var>.[[Values]] to <var>values</var>.</li><li>Set <var>resolveElement</var>.[[Capability]] to <var>resultCapability</var>.</li><li>Set <var>resolveElement</var>.[[RemainingElements]] to <var>remainingElementsCount</var>.</li><li>Set <var>remainingElementsCount</var>.[[Value]] to <var>remainingElementsCount</var>.[[Value]] + 1.</li><li>Perform ?&#160;<emu-xref aoid=\"Invoke\"><a href=\"#sec-invoke\">Invoke</a></emu-xref>(<var>nextPromise</var>, <emu-val>\"then\"</emu-val>, &#171; <var>resolveElement</var>, <var>resultCapability</var>.[[Reject]] &#187;).</li><li>Set <var>index</var> to <var>index</var> + 1.</li></ol></li></ol></emu-alg>\n        </emu-clause>\n\n        "}}, "figData": {}}}