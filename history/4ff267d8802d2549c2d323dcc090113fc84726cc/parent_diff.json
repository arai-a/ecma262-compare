{"from": {"secList": ["sec-typedarray-objects", "sec-isbigintelementtype", "sec-getmodifysetvalueinbuffer", "sec-setvalueinbuffer", "sec-isunclampedintegerelementtype", "sec-rawbytestonumeric", "sec-isunsignedelementtype", "sec-getvaluefrombuffer", "sec-numerictorawbytes"], "secData": {"sec-typedarray-objects": {"num": "23.2", "title": "#sec-typedarray-objects TypedArray Objects", "html": "<emu-clause id=\"sec-typedarray-objects\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-typedarray-objects\">#sec-typedarray-objects</span> TypedArray Objects</h1>\n    <p><var>TypedArray</var> objects present an array-like view of an underlying binary data buffer (<emu-xref href=\"#sec-arraybuffer-objects\"><a href=\"#sec-arraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-arraybuffer-objects\">#sec-arraybuffer-objects</a></emu-xref>). Each element of a <var>TypedArray</var> instance has the same underlying binary scalar data type. There is a distinct <var>TypedArray</var> <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>, listed in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref>, for each of the supported element types. Each <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> has a corresponding distinct prototype object.</p>\n    <emu-table id=\"table-the-typedarray-constructors\" caption=\"The TypedArray Constructors\" oldids=\"table-49\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</span>: The TypedArray Constructors</figcaption><span id=\"table-49\"></span>\n      <table>\n        <tbody>\n        <tr>\n          <th>\n            <emu-xref href=\"#constructor\"><a href=\"#constructor\">Constructor</a></emu-xref> Name and Intrinsic\n          </th>\n          <th>\n            Element Type\n          </th>\n          <th>\n            Element Size\n          </th>\n          <th>\n            Conversion Operation\n          </th>\n          <th>\n            Description\n          </th>\n        </tr>\n        <tr>\n          <td>\n            Int8Array\n            <br>\n            <dfn>%Int8Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Int8</emu-const>\n          </td>\n          <td>\n            1\n          </td>\n          <td>\n            <emu-xref aoid=\"ToInt8\"><a href=\"#sec-toint8\">ToInt8</a></emu-xref>\n          </td>\n          <td>\n            8-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint8Array\n            <br>\n            <dfn>%Uint8Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint8</emu-const>\n          </td>\n          <td>\n            1\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint8\"><a href=\"#sec-touint8\">ToUint8</a></emu-xref>\n          </td>\n          <td>\n            8-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint8ClampedArray\n            <br>\n            <dfn>%Uint8ClampedArray%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint8C</emu-const>\n          </td>\n          <td>\n            1\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint8Clamp\"><a href=\"#sec-touint8clamp\">ToUint8Clamp</a></emu-xref>\n          </td>\n          <td>\n            8-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> (clamped conversion)\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Int16Array\n            <br>\n            <dfn>%Int16Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Int16</emu-const>\n          </td>\n          <td>\n            2\n          </td>\n          <td>\n            <emu-xref aoid=\"ToInt16\"><a href=\"#sec-toint16\">ToInt16</a></emu-xref>\n          </td>\n          <td>\n            16-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint16Array\n            <br>\n            <dfn>%Uint16Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint16</emu-const>\n          </td>\n          <td>\n            2\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint16\"><a href=\"#sec-touint16\">ToUint16</a></emu-xref>\n          </td>\n          <td>\n            16-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Int32Array\n            <br>\n            <dfn>%Int32Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Int32</emu-const>\n          </td>\n          <td>\n            4\n          </td>\n          <td>\n            <emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>\n          </td>\n          <td>\n            32-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint32Array\n            <br>\n            <dfn>%Uint32Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint32</emu-const>\n          </td>\n          <td>\n            4\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>\n          </td>\n          <td>\n            32-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            BigInt64Array\n            <br>\n            <dfn>%BigInt64Array%</dfn>\n          </td>\n          <td>\n            <emu-const>BigInt64</emu-const>\n          </td>\n          <td>\n            8\n          </td>\n          <td>\n            <emu-xref aoid=\"ToBigInt64\"><a href=\"#sec-tobigint64\">ToBigInt64</a></emu-xref>\n          </td>\n          <td>\n            64-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            BigUint64Array\n            <br>\n            <dfn>%BigUint64Array%</dfn>\n          </td>\n          <td>\n            <emu-const>BigUint64</emu-const>\n          </td>\n          <td>\n            8\n          </td>\n          <td>\n            <emu-xref aoid=\"ToBigUint64\"><a href=\"#sec-tobiguint64\">ToBigUint64</a></emu-xref>\n          </td>\n          <td>\n            64-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Float32Array\n            <br>\n            <dfn>%Float32Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Float32</emu-const>\n          </td>\n          <td>\n            4\n          </td>\n          <td>\n          </td>\n          <td>\n            32-bit IEEE floating point\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Float64Array\n            <br>\n            <dfn>%Float64Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Float64</emu-const>\n          </td>\n          <td>\n            8\n          </td>\n          <td>\n          </td>\n          <td>\n            64-bit IEEE floating point\n          </td>\n        </tr>\n        </tbody>\n      </table>\n    </figure></emu-table>\n    <p>In the definitions below, references to <var>TypedArray</var> should be replaced with the appropriate <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> name from the above table.</p>\n\n    <div id=\"excluded-sec-%typedarray%-intrinsic-object\"><h1><span class=\"secnum\">23.2.1</span>#sec-%typedarray%-intrinsic-object The %TypedArray% Intrinsic Object</h1>...</div><div id=\"excluded-sec-properties-of-the-%typedarray%-intrinsic-object\"><h1><span class=\"secnum\">23.2.2</span>#sec-properties-of-the-%typedarray%-intrinsic-object Properties of the %TypedArray% Intrinsic Object</h1>...</div><div id=\"excluded-sec-properties-of-the-%typedarrayprototype%-object\"><h1><span class=\"secnum\">23.2.3</span>#sec-properties-of-the-%typedarrayprototype%-object Properties of the %TypedArray% Prototype Object</h1>...</div><div id=\"excluded-sec-abstract-operations-for-typedarray-objects\"><h1><span class=\"secnum\">23.2.4</span>#sec-abstract-operations-for-typedarray-objects Abstract Operations for TypedArray Objects</h1>...</div><div id=\"excluded-sec-typedarray-constructors\"><h1><span class=\"secnum\">23.2.5</span>#sec-typedarray-constructors The TypedArray Constructors</h1>...</div><div id=\"excluded-sec-properties-of-the-typedarray-constructors\"><h1><span class=\"secnum\">23.2.6</span>#sec-properties-of-the-typedarray-constructors Properties of the TypedArray Constructors</h1>...</div><div id=\"excluded-sec-properties-of-typedarray-prototype-objects\"><h1><span class=\"secnum\">23.2.7</span>#sec-properties-of-typedarray-prototype-objects Properties of the TypedArray Prototype Objects</h1>...</div><div id=\"excluded-sec-properties-of-typedarray-instances\"><h1><span class=\"secnum\">23.2.8</span>#sec-properties-of-typedarray-instances Properties of TypedArray Instances</h1>...</div></emu-clause>\n"}, "sec-isbigintelementtype": {"num": "25.1.2.7", "title": "#sec-isbigintelementtype IsBigIntElementType ( type )", "html": "<emu-clause id=\"sec-isbigintelementtype\" aoid=\"IsBigIntElementType\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isbigintelementtype\">#sec-isbigintelementtype</span> IsBigIntElementType ( <var>type</var> )</h1>\n        <p>The abstract operation IsBigIntElementType takes argument <var>type</var>. It verifies if the argument <var>type</var> is a BigInt TypedArray element type. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>BigUint64</emu-const> or <emu-const>BigInt64</emu-const>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-getmodifysetvalueinbuffer": {"num": "25.1.2.13", "title": "#sec-getmodifysetvalueinbuffer GetModifySetValueInBuffer ( arrayBuffer, byteIndex, type, value, op [ , isLittleEndian ] )", "html": "<emu-clause id=\"sec-getmodifysetvalueinbuffer\" aoid=\"GetModifySetValueInBuffer\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getmodifysetvalueinbuffer\">#sec-getmodifysetvalueinbuffer</span> GetModifySetValueInBuffer ( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>op</var> [ , <var>isLittleEndian</var> ] )</h1>\n        <p>The abstract operation GetModifySetValueInBuffer takes arguments <var>arrayBuffer</var> (an ArrayBuffer object or a SharedArrayBuffer object), <var>byteIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>type</var> (a TypedArray element type), <var>value</var> (a Number or a BigInt), and <var>op</var> (a <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref>) and optional argument <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is BigInt if !&#160;<emu-xref aoid=\"IsBigIntElementType\"><a href=\"#sec-isbigintelementtype\">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>; otherwise, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is Number.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>rawBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>value</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>rawBytesRead</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are nondeterministically chosen byte values.</li><li>NOTE: In implementations, <var>rawBytesRead</var> is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>rmwEvent</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadModifyWriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>rawBytes</var>, [[ModifyOp]]: <var>op</var> }.</li><li>Append <var>rmwEvent</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>rmwEvent</var>, [[ChosenValue]]: <var>rawBytesRead</var> } to <var>execution</var>.[[ChosenValues]].</li></ol></li><li>Else,<ol><li>Let <var>rawBytesRead</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are the sequence of <var>elementSize</var> bytes starting with <var>block</var>[<var>byteIndex</var>].</li><li>Let <var>rawBytesModified</var> be <var>op</var>(<var>rawBytesRead</var>, <var>rawBytes</var>).</li><li>Store the individual bytes of <var>rawBytesModified</var> into <var>block</var>, starting at <var>block</var>[<var>byteIndex</var>].</li></ol></li><li>Return <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>rawBytesRead</var>, <var>isLittleEndian</var>).</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-setvalueinbuffer": {"num": "25.1.2.12", "title": "#sec-setvalueinbuffer SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )", "html": "<emu-clause id=\"sec-setvalueinbuffer\" aoid=\"SetValueInBuffer\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-setvalueinbuffer\">#sec-setvalueinbuffer</span> SetValueInBuffer ( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>isTypedArray</var>, <var>order</var> [ , <var>isLittleEndian</var> ] )</h1>\n        <p>The abstract operation SetValueInBuffer takes arguments <var>arrayBuffer</var> (an ArrayBuffer or SharedArrayBuffer), <var>byteIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>type</var> (a TypedArray element type), <var>value</var> (a Number or a BigInt), <var>isTypedArray</var> (a Boolean), and <var>order</var> (one of <emu-const>SeqCst</emu-const>, <emu-const>Unordered</emu-const>, or <emu-const>Init</emu-const>) and optional argument <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is BigInt if !&#160;<emu-xref aoid=\"IsBigIntElementType\"><a href=\"#sec-isbigintelementtype\">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>; otherwise, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is Number.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>rawBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>value</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>If <var>isTypedArray</var> is <emu-val>true</emu-val> and <emu-xref aoid=\"IsNoTearConfiguration\"><a href=\"#sec-isnotearconfiguration\">IsNoTearConfiguration</a></emu-xref>(<var>type</var>, <var>order</var>) is <emu-val>true</emu-val>, let <var>noTear</var> be <emu-val>true</emu-val>; otherwise let <var>noTear</var> be <emu-val>false</emu-val>.</li><li>Append <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">WriteSharedMemory</a></emu-xref> { [[Order]]: <var>order</var>, [[NoTear]]: <var>noTear</var>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>rawBytes</var> } to <var>eventList</var>.</li></ol></li><li>Else, store the individual bytes of <var>rawBytes</var> into <var>block</var>, starting at <var>block</var>[<var>byteIndex</var>].</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isunclampedintegerelementtype": {"num": "25.1.2.6", "title": "#sec-isunclampedintegerelementtype IsUnclampedIntegerElementType ( type )", "html": "<emu-clause id=\"sec-isunclampedintegerelementtype\" aoid=\"IsUnclampedIntegerElementType\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isunclampedintegerelementtype\">#sec-isunclampedintegerelementtype</span> IsUnclampedIntegerElementType ( <var>type</var> )</h1>\n        <p>The abstract operation IsUnclampedIntegerElementType takes argument <var>type</var>. It verifies if the argument <var>type</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">Integer</a></emu-xref> TypedArray element type not including <emu-const>Uint8C</emu-const>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>Int8</emu-const>, <emu-const>Uint8</emu-const>, <emu-const>Int16</emu-const>, <emu-const>Uint16</emu-const>, <emu-const>Int32</emu-const>, or <emu-const>Uint32</emu-const>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-rawbytestonumeric": {"num": "25.1.2.9", "title": "#sec-rawbytestonumeric RawBytesToNumeric ( type, rawBytes, isLittleEndian )", "html": "<emu-clause id=\"sec-rawbytestonumeric\" aoid=\"RawBytesToNumeric\" oldids=\"sec-rawbytestonumber\"><span id=\"sec-rawbytestonumber\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-rawbytestonumeric\">#sec-rawbytestonumeric</span> RawBytesToNumeric ( <var>type</var>, <var>rawBytes</var>, <var>isLittleEndian</var> )</h1>\n        <p>The abstract operation RawBytesToNumeric takes arguments <var>type</var> (a TypedArray element type), <var>rawBytes</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>), and <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawBytes</var>.</li><li>If <var>type</var> is <emu-const>Float32</emu-const>, then<ol><li>Let <var>value</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a little-endian bit string encoding of an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 value.</li><li>If <var>value</var> is an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 NaN value, return the <emu-val>NaN</emu-val> <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that corresponds to <var>value</var>.</li></ol></li><li>If <var>type</var> is <emu-const>Float64</emu-const>, then<ol><li>Let <var>value</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a little-endian bit string encoding of an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 value.</li><li>If <var>value</var> is an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 NaN value, return the <emu-val>NaN</emu-val> <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that corresponds to <var>value</var>.</li></ol></li><li>If !&#160;<emu-xref aoid=\"IsUnsignedElementType\"><a href=\"#sec-isunsignedelementtype\">IsUnsignedElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>intValue</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</li></ol></li><li>Else,<ol><li>Let <var>intValue</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length <var>elementSize</var> &#215; 8.</li></ol></li><li>If !&#160;<emu-xref aoid=\"IsBigIntElementType\"><a href=\"#sec-isbigintelementtype\">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, return the BigInt value that corresponds to <var>intValue</var>.</li><li>Otherwise, return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that corresponds to <var>intValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isunsignedelementtype": {"num": "25.1.2.5", "title": "#sec-isunsignedelementtype IsUnsignedElementType ( type )", "html": "<emu-clause id=\"sec-isunsignedelementtype\" aoid=\"IsUnsignedElementType\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isunsignedelementtype\">#sec-isunsignedelementtype</span> IsUnsignedElementType ( <var>type</var> )</h1>\n        <p>The abstract operation IsUnsignedElementType takes argument <var>type</var>. It verifies if the argument <var>type</var> is an unsigned TypedArray element type. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>Uint8</emu-const>, <emu-const>Uint8C</emu-const>, <emu-const>Uint16</emu-const>, <emu-const>Uint32</emu-const>, or <emu-const>BigUint64</emu-const>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-getvaluefrombuffer": {"num": "25.1.2.10", "title": "#sec-getvaluefrombuffer GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )", "html": "<emu-clause id=\"sec-getvaluefrombuffer\" aoid=\"GetValueFromBuffer\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getvaluefrombuffer\">#sec-getvaluefrombuffer</span> GetValueFromBuffer ( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>order</var> [ , <var>isLittleEndian</var> ] )</h1>\n        <p>The abstract operation GetValueFromBuffer takes arguments <var>arrayBuffer</var> (an ArrayBuffer or SharedArrayBuffer), <var>byteIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>type</var> (a TypedArray element type), <var>isTypedArray</var> (a Boolean), and <var>order</var> (either <emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>) and optional argument <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>If <var>isTypedArray</var> is <emu-val>true</emu-val> and <emu-xref aoid=\"IsNoTearConfiguration\"><a href=\"#sec-isnotearconfiguration\">IsNoTearConfiguration</a></emu-xref>(<var>type</var>, <var>order</var>) is <emu-val>true</emu-val>, let <var>noTear</var> be <emu-val>true</emu-val>; otherwise let <var>noTear</var> be <emu-val>false</emu-val>.</li><li>Let <var>rawValue</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are nondeterministically chosen byte values.</li><li>NOTE: In implementations, <var>rawValue</var> is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>readEvent</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadSharedMemory</a></emu-xref> { [[Order]]: <var>order</var>, [[NoTear]]: <var>noTear</var>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var> }.</li><li>Append <var>readEvent</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>readEvent</var>, [[ChosenValue]]: <var>rawValue</var> } to <var>execution</var>.[[ChosenValues]].</li></ol></li><li>Else, let <var>rawValue</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are bytes from <var>block</var> at indices <var>byteIndex</var> (inclusive) through <var>byteIndex</var> + <var>elementSize</var> (exclusive).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The number of elements in <var>rawValue</var> is <var>elementSize</var>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Return <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>rawValue</var>, <var>isLittleEndian</var>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numerictorawbytes": {"num": "25.1.2.11", "title": "#sec-numerictorawbytes NumericToRawBytes ( type, value, isLittleEndian )", "html": "<emu-clause id=\"sec-numerictorawbytes\" aoid=\"NumericToRawBytes\" oldids=\"sec-numbertorawbytes\"><span id=\"sec-numbertorawbytes\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numerictorawbytes\">#sec-numerictorawbytes</span> NumericToRawBytes ( <var>type</var>, <var>value</var>, <var>isLittleEndian</var> )</h1>\n        <p>The abstract operation NumericToRawBytes takes arguments <var>type</var> (a TypedArray element type), <var>value</var> (a BigInt or a Number), and <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>Float32</emu-const>, then<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the 4 bytes that are the result of converting <var>value</var> to <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 format using roundTiesToEven mode. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawBytes</var> may be set to any implementation chosen <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</li></ol></li><li>Else if <var>type</var> is <emu-const>Float64</emu-const>, then<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the 8 bytes that are the <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 format encoding of <var>value</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawBytes</var> may be set to any implementation chosen <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</li></ol></li><li>Else,<ol><li>Let <var>n</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>convOp</var> be the abstract operation named in the Conversion Operation column in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>intValue</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>convOp</var>(<var>value</var>)).</li><li>If <var>intValue</var> &#8805; 0, then<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the <var>n</var>-byte binary encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</li></ol></li><li>Else,<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the <var>n</var>-byte binary two's complement encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</li></ol></li></ol></li><li>Return <var>rawBytes</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {"table-the-typedarray-constructors": "Table 60"}}, "to": {"secList": ["sec-typedarray-objects", "sec-isbigintelementtype", "sec-getmodifysetvalueinbuffer", "sec-setvalueinbuffer", "sec-isunclampedintegerelementtype", "sec-rawbytestonumeric", "sec-isunsignedelementtype", "sec-getvaluefrombuffer", "sec-numerictorawbytes"], "secData": {"sec-typedarray-objects": {"num": "23.2", "title": "#sec-typedarray-objects TypedArray Objects", "html": "<emu-clause id=\"sec-typedarray-objects\">\n    <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-typedarray-objects\">#sec-typedarray-objects</span> TypedArray Objects</h1>\n    <p><var>TypedArray</var> objects present an array-like view of an underlying binary data buffer (<emu-xref href=\"#sec-arraybuffer-objects\"><a href=\"#sec-arraybuffer-objects\" class=\"excluded-xref\" excluded-id=\"sec-arraybuffer-objects\">#sec-arraybuffer-objects</a></emu-xref>). A <dfn>TypedArray element type</dfn> is the underlying binary scalar data type that all elements of a <var>TypedArray</var> instance have. There is a distinct <var>TypedArray</var> <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref>, listed in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref>, for each of the supported element types. Each <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> has a corresponding distinct prototype object.</p>\n    <emu-table id=\"table-the-typedarray-constructors\" caption=\"The TypedArray Constructors\" oldids=\"table-49\"><figure><figcaption><span class=\"excluded-caption-num\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</span>: The TypedArray Constructors</figcaption><span id=\"table-49\"></span>\n      <table>\n        <tbody>\n        <tr>\n          <th>\n            <emu-xref href=\"#constructor\"><a href=\"#constructor\">Constructor</a></emu-xref> Name and Intrinsic\n          </th>\n          <th>\n            Element Type\n          </th>\n          <th>\n            Element Size\n          </th>\n          <th>\n            Conversion Operation\n          </th>\n          <th>\n            Description\n          </th>\n        </tr>\n        <tr>\n          <td>\n            Int8Array\n            <br>\n            <dfn>%Int8Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Int8</emu-const>\n          </td>\n          <td>\n            1\n          </td>\n          <td>\n            <emu-xref aoid=\"ToInt8\"><a href=\"#sec-toint8\">ToInt8</a></emu-xref>\n          </td>\n          <td>\n            8-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint8Array\n            <br>\n            <dfn>%Uint8Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint8</emu-const>\n          </td>\n          <td>\n            1\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint8\"><a href=\"#sec-touint8\">ToUint8</a></emu-xref>\n          </td>\n          <td>\n            8-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint8ClampedArray\n            <br>\n            <dfn>%Uint8ClampedArray%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint8C</emu-const>\n          </td>\n          <td>\n            1\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint8Clamp\"><a href=\"#sec-touint8clamp\">ToUint8Clamp</a></emu-xref>\n          </td>\n          <td>\n            8-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref> (clamped conversion)\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Int16Array\n            <br>\n            <dfn>%Int16Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Int16</emu-const>\n          </td>\n          <td>\n            2\n          </td>\n          <td>\n            <emu-xref aoid=\"ToInt16\"><a href=\"#sec-toint16\">ToInt16</a></emu-xref>\n          </td>\n          <td>\n            16-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint16Array\n            <br>\n            <dfn>%Uint16Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint16</emu-const>\n          </td>\n          <td>\n            2\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint16\"><a href=\"#sec-touint16\">ToUint16</a></emu-xref>\n          </td>\n          <td>\n            16-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Int32Array\n            <br>\n            <dfn>%Int32Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Int32</emu-const>\n          </td>\n          <td>\n            4\n          </td>\n          <td>\n            <emu-xref aoid=\"ToInt32\"><a href=\"#sec-toint32\">ToInt32</a></emu-xref>\n          </td>\n          <td>\n            32-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Uint32Array\n            <br>\n            <dfn>%Uint32Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Uint32</emu-const>\n          </td>\n          <td>\n            4\n          </td>\n          <td>\n            <emu-xref aoid=\"ToUint32\"><a href=\"#sec-touint32\">ToUint32</a></emu-xref>\n          </td>\n          <td>\n            32-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            BigInt64Array\n            <br>\n            <dfn>%BigInt64Array%</dfn>\n          </td>\n          <td>\n            <emu-const>BigInt64</emu-const>\n          </td>\n          <td>\n            8\n          </td>\n          <td>\n            <emu-xref aoid=\"ToBigInt64\"><a href=\"#sec-tobigint64\">ToBigInt64</a></emu-xref>\n          </td>\n          <td>\n            64-bit two's complement signed <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            BigUint64Array\n            <br>\n            <dfn>%BigUint64Array%</dfn>\n          </td>\n          <td>\n            <emu-const>BigUint64</emu-const>\n          </td>\n          <td>\n            8\n          </td>\n          <td>\n            <emu-xref aoid=\"ToBigUint64\"><a href=\"#sec-tobiguint64\">ToBigUint64</a></emu-xref>\n          </td>\n          <td>\n            64-bit unsigned <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Float32Array\n            <br>\n            <dfn>%Float32Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Float32</emu-const>\n          </td>\n          <td>\n            4\n          </td>\n          <td>\n          </td>\n          <td>\n            32-bit IEEE floating point\n          </td>\n        </tr>\n        <tr>\n          <td>\n            Float64Array\n            <br>\n            <dfn>%Float64Array%</dfn>\n          </td>\n          <td>\n            <emu-const>Float64</emu-const>\n          </td>\n          <td>\n            8\n          </td>\n          <td>\n          </td>\n          <td>\n            64-bit IEEE floating point\n          </td>\n        </tr>\n        </tbody>\n      </table>\n    </figure></emu-table>\n    <p>In the definitions below, references to <var>TypedArray</var> should be replaced with the appropriate <emu-xref href=\"#constructor\"><a href=\"#constructor\">constructor</a></emu-xref> name from the above table.</p>\n\n    <div id=\"excluded-sec-%typedarray%-intrinsic-object\"><h1><span class=\"secnum\">23.2.1</span>#sec-%typedarray%-intrinsic-object The %TypedArray% Intrinsic Object</h1>...</div><div id=\"excluded-sec-properties-of-the-%typedarray%-intrinsic-object\"><h1><span class=\"secnum\">23.2.2</span>#sec-properties-of-the-%typedarray%-intrinsic-object Properties of the %TypedArray% Intrinsic Object</h1>...</div><div id=\"excluded-sec-properties-of-the-%typedarrayprototype%-object\"><h1><span class=\"secnum\">23.2.3</span>#sec-properties-of-the-%typedarrayprototype%-object Properties of the %TypedArray% Prototype Object</h1>...</div><div id=\"excluded-sec-abstract-operations-for-typedarray-objects\"><h1><span class=\"secnum\">23.2.4</span>#sec-abstract-operations-for-typedarray-objects Abstract Operations for TypedArray Objects</h1>...</div><div id=\"excluded-sec-typedarray-constructors\"><h1><span class=\"secnum\">23.2.5</span>#sec-typedarray-constructors The TypedArray Constructors</h1>...</div><div id=\"excluded-sec-properties-of-the-typedarray-constructors\"><h1><span class=\"secnum\">23.2.6</span>#sec-properties-of-the-typedarray-constructors Properties of the TypedArray Constructors</h1>...</div><div id=\"excluded-sec-properties-of-typedarray-prototype-objects\"><h1><span class=\"secnum\">23.2.7</span>#sec-properties-of-typedarray-prototype-objects Properties of the TypedArray Prototype Objects</h1>...</div><div id=\"excluded-sec-properties-of-typedarray-instances\"><h1><span class=\"secnum\">23.2.8</span>#sec-properties-of-typedarray-instances Properties of TypedArray Instances</h1>...</div></emu-clause>\n"}, "sec-isbigintelementtype": {"num": "25.1.2.7", "title": "#sec-isbigintelementtype IsBigIntElementType ( type )", "html": "<emu-clause id=\"sec-isbigintelementtype\" aoid=\"IsBigIntElementType\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isbigintelementtype\">#sec-isbigintelementtype</span> IsBigIntElementType ( <var>type</var> )</h1>\n        <p>The abstract operation IsBigIntElementType takes argument <var>type</var>. It verifies if the argument <var>type</var> is a BigInt <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>BigUint64</emu-const> or <emu-const>BigInt64</emu-const>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-getmodifysetvalueinbuffer": {"num": "25.1.2.13", "title": "#sec-getmodifysetvalueinbuffer GetModifySetValueInBuffer ( arrayBuffer, byteIndex, type, value, op [ , isLittleEndian ] )", "html": "<emu-clause id=\"sec-getmodifysetvalueinbuffer\" aoid=\"GetModifySetValueInBuffer\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getmodifysetvalueinbuffer\">#sec-getmodifysetvalueinbuffer</span> GetModifySetValueInBuffer ( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>op</var> [ , <var>isLittleEndian</var> ] )</h1>\n        <p>The abstract operation GetModifySetValueInBuffer takes arguments <var>arrayBuffer</var> (an ArrayBuffer object or a SharedArrayBuffer object), <var>byteIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>type</var> (a <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>), <var>value</var> (a Number or a BigInt), and <var>op</var> (a <emu-xref href=\"#sec-arraybuffer-notation\"><a href=\"#sec-arraybuffer-notation\">read-modify-write modification function</a></emu-xref>) and optional argument <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is BigInt if !&#160;<emu-xref aoid=\"IsBigIntElementType\"><a href=\"#sec-isbigintelementtype\">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>; otherwise, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is Number.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>rawBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>value</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>Let <var>rawBytesRead</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are nondeterministically chosen byte values.</li><li>NOTE: In implementations, <var>rawBytesRead</var> is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>rmwEvent</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadModifyWriteSharedMemory</a></emu-xref> { [[Order]]: <emu-const>SeqCst</emu-const>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>rawBytes</var>, [[ModifyOp]]: <var>op</var> }.</li><li>Append <var>rmwEvent</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>rmwEvent</var>, [[ChosenValue]]: <var>rawBytesRead</var> } to <var>execution</var>.[[ChosenValues]].</li></ol></li><li>Else,<ol><li>Let <var>rawBytesRead</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are the sequence of <var>elementSize</var> bytes starting with <var>block</var>[<var>byteIndex</var>].</li><li>Let <var>rawBytesModified</var> be <var>op</var>(<var>rawBytesRead</var>, <var>rawBytes</var>).</li><li>Store the individual bytes of <var>rawBytesModified</var> into <var>block</var>, starting at <var>block</var>[<var>byteIndex</var>].</li></ol></li><li>Return <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>rawBytesRead</var>, <var>isLittleEndian</var>).</li></ol></emu-alg>\n      </emu-clause>\n    "}, "sec-setvalueinbuffer": {"num": "25.1.2.12", "title": "#sec-setvalueinbuffer SetValueInBuffer ( arrayBuffer, byteIndex, type, value, isTypedArray, order [ , isLittleEndian ] )", "html": "<emu-clause id=\"sec-setvalueinbuffer\" aoid=\"SetValueInBuffer\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-setvalueinbuffer\">#sec-setvalueinbuffer</span> SetValueInBuffer ( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>isTypedArray</var>, <var>order</var> [ , <var>isLittleEndian</var> ] )</h1>\n        <p>The abstract operation SetValueInBuffer takes arguments <var>arrayBuffer</var> (an ArrayBuffer or SharedArrayBuffer), <var>byteIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>type</var> (a <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>), <var>value</var> (a Number or a BigInt), <var>isTypedArray</var> (a Boolean), and <var>order</var> (one of <emu-const>SeqCst</emu-const>, <emu-const>Unordered</emu-const>, or <emu-const>Init</emu-const>) and optional argument <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is BigInt if !&#160;<emu-xref aoid=\"IsBigIntElementType\"><a href=\"#sec-isbigintelementtype\">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>; otherwise, <emu-xref aoid=\"Type\"><a href=\"#sec-ecmascript-data-types-and-values\">Type</a></emu-xref>(<var>value</var>) is Number.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>rawBytes</var> be <emu-xref aoid=\"NumericToRawBytes\"><a href=\"#sec-numerictorawbytes\">NumericToRawBytes</a></emu-xref>(<var>type</var>, <var>value</var>, <var>isLittleEndian</var>).</li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>If <var>isTypedArray</var> is <emu-val>true</emu-val> and <emu-xref aoid=\"IsNoTearConfiguration\"><a href=\"#sec-isnotearconfiguration\">IsNoTearConfiguration</a></emu-xref>(<var>type</var>, <var>order</var>) is <emu-val>true</emu-val>, let <var>noTear</var> be <emu-val>true</emu-val>; otherwise let <var>noTear</var> be <emu-val>false</emu-val>.</li><li>Append <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">WriteSharedMemory</a></emu-xref> { [[Order]]: <var>order</var>, [[NoTear]]: <var>noTear</var>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>rawBytes</var> } to <var>eventList</var>.</li></ol></li><li>Else, store the individual bytes of <var>rawBytes</var> into <var>block</var>, starting at <var>block</var>[<var>byteIndex</var>].</li><li>Return <emu-xref aoid=\"NormalCompletion\"><a href=\"#sec-normalcompletion\">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isunclampedintegerelementtype": {"num": "25.1.2.6", "title": "#sec-isunclampedintegerelementtype IsUnclampedIntegerElementType ( type )", "html": "<emu-clause id=\"sec-isunclampedintegerelementtype\" aoid=\"IsUnclampedIntegerElementType\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isunclampedintegerelementtype\">#sec-isunclampedintegerelementtype</span> IsUnclampedIntegerElementType ( <var>type</var> )</h1>\n        <p>The abstract operation IsUnclampedIntegerElementType takes argument <var>type</var>. It verifies if the argument <var>type</var> is an <emu-xref href=\"#integer\"><a href=\"#integer\">Integer</a></emu-xref> <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref> not including <emu-const>Uint8C</emu-const>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>Int8</emu-const>, <emu-const>Uint8</emu-const>, <emu-const>Int16</emu-const>, <emu-const>Uint16</emu-const>, <emu-const>Int32</emu-const>, or <emu-const>Uint32</emu-const>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-rawbytestonumeric": {"num": "25.1.2.9", "title": "#sec-rawbytestonumeric RawBytesToNumeric ( type, rawBytes, isLittleEndian )", "html": "<emu-clause id=\"sec-rawbytestonumeric\" aoid=\"RawBytesToNumeric\" oldids=\"sec-rawbytestonumber\"><span id=\"sec-rawbytestonumber\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-rawbytestonumeric\">#sec-rawbytestonumeric</span> RawBytesToNumeric ( <var>type</var>, <var>rawBytes</var>, <var>isLittleEndian</var> )</h1>\n        <p>The abstract operation RawBytesToNumeric takes arguments <var>type</var> (a <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>), <var>rawBytes</var> (a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref>), and <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawBytes</var>.</li><li>If <var>type</var> is <emu-const>Float32</emu-const>, then<ol><li>Let <var>value</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a little-endian bit string encoding of an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 value.</li><li>If <var>value</var> is an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 NaN value, return the <emu-val>NaN</emu-val> <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that corresponds to <var>value</var>.</li></ol></li><li>If <var>type</var> is <emu-const>Float64</emu-const>, then<ol><li>Let <var>value</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a little-endian bit string encoding of an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 value.</li><li>If <var>value</var> is an <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 NaN value, return the <emu-val>NaN</emu-val> <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref>.</li><li>Return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that corresponds to <var>value</var>.</li></ol></li><li>If !&#160;<emu-xref aoid=\"IsUnsignedElementType\"><a href=\"#sec-isunsignedelementtype\">IsUnsignedElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>intValue</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</li></ol></li><li>Else,<ol><li>Let <var>intValue</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length <var>elementSize</var> &#215; 8.</li></ol></li><li>If !&#160;<emu-xref aoid=\"IsBigIntElementType\"><a href=\"#sec-isbigintelementtype\">IsBigIntElementType</a></emu-xref>(<var>type</var>) is <emu-val>true</emu-val>, return the BigInt value that corresponds to <var>intValue</var>.</li><li>Otherwise, return the <emu-xref href=\"#number-value\"><a href=\"#number-value\">Number value</a></emu-xref> that corresponds to <var>intValue</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-isunsignedelementtype": {"num": "25.1.2.5", "title": "#sec-isunsignedelementtype IsUnsignedElementType ( type )", "html": "<emu-clause id=\"sec-isunsignedelementtype\" aoid=\"IsUnsignedElementType\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-isunsignedelementtype\">#sec-isunsignedelementtype</span> IsUnsignedElementType ( <var>type</var> )</h1>\n        <p>The abstract operation IsUnsignedElementType takes argument <var>type</var>. It verifies if the argument <var>type</var> is an unsigned <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>. It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>Uint8</emu-const>, <emu-const>Uint8C</emu-const>, <emu-const>Uint16</emu-const>, <emu-const>Uint32</emu-const>, or <emu-const>BigUint64</emu-const>, return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-getvaluefrombuffer": {"num": "25.1.2.10", "title": "#sec-getvaluefrombuffer GetValueFromBuffer ( arrayBuffer, byteIndex, type, isTypedArray, order [ , isLittleEndian ] )", "html": "<emu-clause id=\"sec-getvaluefrombuffer\" aoid=\"GetValueFromBuffer\">\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-getvaluefrombuffer\">#sec-getvaluefrombuffer</span> GetValueFromBuffer ( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>order</var> [ , <var>isLittleEndian</var> ] )</h1>\n        <p>The abstract operation GetValueFromBuffer takes arguments <var>arrayBuffer</var> (an ArrayBuffer or SharedArrayBuffer), <var>byteIndex</var> (a non-negative <emu-xref href=\"#integer\"><a href=\"#integer\">integer</a></emu-xref>), <var>type</var> (a <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>), <var>isTypedArray</var> (a Boolean), and <var>order</var> (either <emu-const>SeqCst</emu-const> or <emu-const>Unordered</emu-const>) and optional argument <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: <emu-xref aoid=\"IsDetachedBuffer\"><a href=\"#sec-isdetachedbuffer\">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>If <emu-xref aoid=\"IsSharedArrayBuffer\"><a href=\"#sec-issharedarraybuffer\">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then<ol><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventsRecords]] whose [[AgentSignifier]] is <emu-xref aoid=\"AgentSignifier\"><a href=\"#sec-agentsignifier\">AgentSignifier</a></emu-xref>().</li><li>If <var>isTypedArray</var> is <emu-val>true</emu-val> and <emu-xref aoid=\"IsNoTearConfiguration\"><a href=\"#sec-isnotearconfiguration\">IsNoTearConfiguration</a></emu-xref>(<var>type</var>, <var>order</var>) is <emu-val>true</emu-val>, let <var>noTear</var> be <emu-val>true</emu-val>; otherwise let <var>noTear</var> be <emu-val>false</emu-val>.</li><li>Let <var>rawValue</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> of length <var>elementSize</var> whose elements are nondeterministically chosen byte values.</li><li>NOTE: In implementations, <var>rawValue</var> is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href=\"#sec-memory-model\"><a href=\"#sec-memory-model\">memory model</a></emu-xref> to describe observable behaviour of hardware with weak consistency.</li><li>Let <var>readEvent</var> be <emu-xref href=\"#sec-memory-model-fundamentals\"><a href=\"#sec-memory-model-fundamentals\">ReadSharedMemory</a></emu-xref> { [[Order]]: <var>order</var>, [[NoTear]]: <var>noTear</var>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var> }.</li><li>Append <var>readEvent</var> to <var>eventList</var>.</li><li>Append <emu-xref href=\"#sec-chosen-value-records\"><a href=\"#sec-chosen-value-records\">Chosen Value Record</a></emu-xref> { [[Event]]: <var>readEvent</var>, [[ChosenValue]]: <var>rawValue</var> } to <var>execution</var>.[[ChosenValues]].</li></ol></li><li>Else, let <var>rawValue</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are bytes from <var>block</var> at indices <var>byteIndex</var> (inclusive) through <var>byteIndex</var> + <var>elementSize</var> (exclusive).</li><li><emu-xref href=\"#assert\"><a href=\"#assert\">Assert</a></emu-xref>: The number of elements in <var>rawValue</var> is <var>elementSize</var>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] field of the <emu-xref href=\"#surrounding-agent\"><a href=\"#surrounding-agent\">surrounding agent</a></emu-xref>'s <emu-xref href=\"#agent-record\"><a href=\"#agent-record\">Agent Record</a></emu-xref>.</li><li>Return <emu-xref aoid=\"RawBytesToNumeric\"><a href=\"#sec-rawbytestonumeric\">RawBytesToNumeric</a></emu-xref>(<var>type</var>, <var>rawValue</var>, <var>isLittleEndian</var>).</li></ol></emu-alg>\n      </emu-clause>\n\n      "}, "sec-numerictorawbytes": {"num": "25.1.2.11", "title": "#sec-numerictorawbytes NumericToRawBytes ( type, value, isLittleEndian )", "html": "<emu-clause id=\"sec-numerictorawbytes\" aoid=\"NumericToRawBytes\" oldids=\"sec-numbertorawbytes\"><span id=\"sec-numbertorawbytes\"></span>\n        <h1><span class=\"secnum excluded-secnum\" excluded-id=\"sec-numerictorawbytes\">#sec-numerictorawbytes</span> NumericToRawBytes ( <var>type</var>, <var>value</var>, <var>isLittleEndian</var> )</h1>\n        <p>The abstract operation NumericToRawBytes takes arguments <var>type</var> (a <emu-xref href=\"#sec-typedarray-objects\"><a href=\"#sec-typedarray-objects\">TypedArray element type</a></emu-xref>), <var>value</var> (a BigInt or a Number), and <var>isLittleEndian</var> (a Boolean). It performs the following steps when called:</p>\n        <emu-alg><ol><li>If <var>type</var> is <emu-const>Float32</emu-const>, then<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the 4 bytes that are the result of converting <var>value</var> to <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 format using roundTiesToEven mode. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawBytes</var> may be set to any implementation chosen <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</li></ol></li><li>Else if <var>type</var> is <emu-const>Float64</emu-const>, then<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the 8 bytes that are the <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 format encoding of <var>value</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawBytes</var> may be set to any implementation chosen <emu-xref href=\"#sec-bibliography\"><a href=\"#sec-bibliography\">IEEE 754-2019</a></emu-xref> binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</li></ol></li><li>Else,<ol><li>Let <var>n</var> be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>convOp</var> be the abstract operation named in the Conversion Operation column in <emu-xref href=\"#table-the-typedarray-constructors\"><a href=\"#table-the-typedarray-constructors\" class=\"excluded-xref\" excluded-id=\"table-the-typedarray-constructors\">#table-the-typedarray-constructors</a></emu-xref> for Element Type <var>type</var>.</li><li>Let <var>intValue</var> be <emu-xref href=\"#%E2%84%9D\"><a href=\"#%E2%84%9D\">&#8477;</a></emu-xref>(<var>convOp</var>(<var>value</var>)).</li><li>If <var>intValue</var> &#8805; 0, then<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the <var>n</var>-byte binary encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</li></ol></li><li>Else,<ol><li>Let <var>rawBytes</var> be a <emu-xref href=\"#sec-list-and-record-specification-type\"><a href=\"#sec-list-and-record-specification-type\">List</a></emu-xref> whose elements are the <var>n</var>-byte binary two's complement encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</li></ol></li></ol></li><li>Return <var>rawBytes</var>.</li></ol></emu-alg>\n      </emu-clause>\n\n      "}}, "figData": {"table-the-typedarray-constructors": "Table 60"}}}